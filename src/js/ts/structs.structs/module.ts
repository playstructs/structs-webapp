// Generated by Ignite ignite.com/cli

import { SigningStargateClient, DeliverTxResponse, StdFee } from "@cosmjs/stargate";
import { EncodeObject, GeneratedType, OfflineSigner, Registry } from "@cosmjs/proto-signing";
import { msgTypes } from './registry';
import { IgniteClient } from "../client"
import { MissingWalletError } from "../helpers"
import { Api } from "./rest";
import { MsgFleetMoveResponse } from "./types/structs/structs/tx";
import { MsgPermissionSetOnObject } from "./types/structs/structs/tx";
import { EventGuild } from "./types/structs/structs/events";
import { EventOreTheft } from "./types/structs/structs/events";
import { MsgStructMove } from "./types/structs/structs/tx";
import { MsgStructOreMinerComplete } from "./types/structs/structs/tx";
import { QueryAllAddressByPlayerRequest } from "./types/structs/structs/query";
import { EventOreMigrateDetail } from "./types/structs/structs/events";
import { MsgGuildBankRedeemResponse } from "./types/structs/structs/tx";
import { MsgStructBuildComplete } from "./types/structs/structs/tx";
import { MsgStructDefenseSet } from "./types/structs/structs/tx";
import { MsgProviderUpdateAccessPolicy } from "./types/structs/structs/tx";
import { QueryAllFleetRequest } from "./types/structs/structs/query";
import { MsgAllocationCreate } from "./types/structs/structs/tx";
import { MsgPermissionResponse } from "./types/structs/structs/tx";
import { QueryParamsRequest } from "./types/structs/structs/query";
import { QueryAllFleetResponse } from "./types/structs/structs/query";
import { PlayerInventory } from "./types/structs/structs/player";
import { EventProviderGrantGuildDetail } from "./types/structs/structs/events";
import { EventGuildBankMintDetail } from "./types/structs/structs/events";
import { MsgSubstationCreateResponse } from "./types/structs/structs/tx";
import { MsgSubstationPlayerMigrateResponse } from "./types/structs/structs/tx";
import { MsgProviderUpdateCapacityMinimum } from "./types/structs/structs/tx";
import { QueryGetGuildMembershipApplicationResponse } from "./types/structs/structs/query";
import { QueryGetPlayerResponse } from "./types/structs/structs/query";
import { QueryGetSubstationResponse } from "./types/structs/structs/query";
import { StructDefender } from "./types/structs/structs/struct";
import { MsgReactorDefuseResponse } from "./types/structs/structs/tx";
import { MsgStructAttack } from "./types/structs/structs/tx";
import { EventTime } from "./types/structs/structs/events";
import { MsgSubstationDelete } from "./types/structs/structs/tx";
import { Guild } from "./types/structs/structs/guild";
import { QueryGetProviderRequest } from "./types/structs/structs/query";
import { MsgAllocationUpdate } from "./types/structs/structs/tx";
import { MsgSubstationPlayerDisconnectResponse } from "./types/structs/structs/tx";
import { EventAlphaRefineDetail } from "./types/structs/structs/events";
import { MsgAllocationDeleteResponse } from "./types/structs/structs/tx";
import { MsgGuildMembershipInviteRevoke } from "./types/structs/structs/tx";
import { MsgProviderUpdateDurationMinimum } from "./types/structs/structs/tx";
import { InternalAddressAssociation } from "./types/structs/structs/address";
import { Params } from "./types/structs/structs/params";
import { PermissionRecord } from "./types/structs/structs/permission";
import { EventReactor } from "./types/structs/structs/events";
import { EventStructAttribute } from "./types/structs/structs/events";
import { MsgAddressRevoke } from "./types/structs/structs/tx";
import { MsgSubstationPlayerConnectResponse } from "./types/structs/structs/tx";
import { QueryGetFleetRequest } from "./types/structs/structs/query";
import { QueryGetInfusionResponse } from "./types/structs/structs/query";
import { QueryGetStructTypeRequest } from "./types/structs/structs/query";
import { EventAttackDefenderCounterDetail } from "./types/structs/structs/events";
import { MsgStructGeneratorInfuse } from "./types/structs/structs/tx";
import { QueryAllPlayerHaltedResponse } from "./types/structs/structs/query";
import { EventProviderRevokeGuildDetail } from "./types/structs/structs/events";
import { PlanetAttributeRecord } from "./types/structs/structs/planet";
import { MsgPlanetExploreResponse } from "./types/structs/structs/tx";
import { QueryGetStructTypeResponse } from "./types/structs/structs/query";
import { EventInfusion } from "./types/structs/structs/events";
import { PlanetAttributes } from "./types/structs/structs/planet";
import { MsgStructOreRefineryStatusResponse } from "./types/structs/structs/tx";
import { QueryAllAgreementByProviderRequest } from "./types/structs/structs/query";
import { QueryAllGuildResponse } from "./types/structs/structs/query";
import { QueryGetGuildMembershipApplicationRequest } from "./types/structs/structs/query";
import { QueryGetProviderByCollateralAddressRequest } from "./types/structs/structs/query";
import { EventGuildBankAddressDetail } from "./types/structs/structs/events";
import { MsgGuildUpdateJoinInfusionMinimumBypassByRequest } from "./types/structs/structs/tx";
import { MsgPermissionRevokeOnAddress } from "./types/structs/structs/tx";
import { QueryParamsResponse } from "./types/structs/structs/query";
import { QueryAllPlanetRequest } from "./types/structs/structs/query";
import { QueryAllPlayerResponse } from "./types/structs/structs/query";
import { MsgAddressRevokeResponse } from "./types/structs/structs/tx";
import { MsgStructActivate } from "./types/structs/structs/tx";
import { MsgStructGeneratorStatusResponse } from "./types/structs/structs/tx";
import { MsgAgreementCapacityIncrease } from "./types/structs/structs/tx";
import { QueryGetGuildByBankCollateralAddressRequest } from "./types/structs/structs/query";
import { QueryValidateSignatureRequest } from "./types/structs/structs/query";
import { MsgPlanetRaidComplete } from "./types/structs/structs/tx";
import { QueryAllAgreementRequest } from "./types/structs/structs/query";
import { QueryAllStructResponse } from "./types/structs/structs/query";
import { QueryAllSubstationResponse } from "./types/structs/structs/query";
import { EventPlayerResumed } from "./types/structs/structs/events";
import { QueryAllGuildBankCollateralAddressRequest } from "./types/structs/structs/query";
import { EventStructDefender } from "./types/structs/structs/events";
import { EventAttackDetail } from "./types/structs/structs/events";
import { MsgAddressRegister } from "./types/structs/structs/tx";
import { MsgGuildMembershipRequestApprove } from "./types/structs/structs/tx";
import { MsgStructOreMinerStatusResponse } from "./types/structs/structs/tx";
import { QueryAllAllocationRequest } from "./types/structs/structs/query";
import { QueryAllAllocationBySourceRequest } from "./types/structs/structs/query";
import { GridAttributes } from "./types/structs/structs/grid";
import { StructsPacketData } from "./types/structs/structs/packet";
import { EventSubstation } from "./types/structs/structs/events";
import { MsgFleetMove } from "./types/structs/structs/tx";
import { MsgGuildBankRedeem } from "./types/structs/structs/tx";
import { QueryGetFleetByIndexRequest } from "./types/structs/structs/query";
import { QueryGetGridResponse } from "./types/structs/structs/query";
import { QueryGetInfusionRequest } from "./types/structs/structs/query";
import { QueryAllInfusionResponse } from "./types/structs/structs/query";
import { EventProviderAddressDetail } from "./types/structs/structs/events";
import { MsgGuildUpdateEndpoint } from "./types/structs/structs/tx";
import { MsgAgreementDurationIncrease } from "./types/structs/structs/tx";
import { QueryAllAllocationResponse } from "./types/structs/structs/query";
import { QueryAllReactorResponse } from "./types/structs/structs/query";
import { EventStructType } from "./types/structs/structs/events";
import { EventGrid } from "./types/structs/structs/events";
import { EventGuildBankRedeem } from "./types/structs/structs/events";
import { EventOreMineDetail } from "./types/structs/structs/events";
import { QueryAllAllocationByDestinationRequest } from "./types/structs/structs/query";
import { Player } from "./types/structs/structs/player";
import { MsgPlayerResumeResponse } from "./types/structs/structs/tx";
import { MsgStructStatusResponse } from "./types/structs/structs/tx";
import { MsgStructStorageRecall } from "./types/structs/structs/tx";
import { MsgAgreementResponse } from "./types/structs/structs/tx";
import { MsgProviderCreate } from "./types/structs/structs/tx";
import { MsgPlayerSendResponse } from "./types/structs/structs/tx";
import { QueryAllAddressRequest } from "./types/structs/structs/query";
import { QueryGetReactorResponse } from "./types/structs/structs/query";
import { EventProviderGrantGuild } from "./types/structs/structs/events";
import { EventGuildBankConfiscateAndBurn } from "./types/structs/structs/events";
import { QueryBlockHeightResponse } from "./types/structs/structs/query";
import { QueryAllPlanetByPlayerRequest } from "./types/structs/structs/query";
import { MsgGuildMembershipRequestRevoke } from "./types/structs/structs/tx";
import { QueryAllStructAttributeRequest } from "./types/structs/structs/query";
import { Reactor } from "./types/structs/structs/reactor";
import { EventAttack } from "./types/structs/structs/events";
import { MsgSubstationAllocationDisconnectResponse } from "./types/structs/structs/tx";
import { MsgAgreementCapacityDecrease } from "./types/structs/structs/tx";
import { QueryAllGuildBankCollateralAddressResponse } from "./types/structs/structs/query";
import { QueryAllSubstationRequest } from "./types/structs/structs/query";
import { QueryValidateSignatureResponse } from "./types/structs/structs/query";
import { EventFleet } from "./types/structs/structs/events";
import { Provider } from "./types/structs/structs/provider";
import { QueryBlockHeight } from "./types/structs/structs/query";
import { QueryGetReactorRequest } from "./types/structs/structs/query";
import { GridRecord } from "./types/structs/structs/grid";
import { MsgGuildUpdateJoinInfusionMinimumBypassByInvite } from "./types/structs/structs/tx";
import { MsgReactorInfuseResponse } from "./types/structs/structs/tx";
import { MsgStructBuildCancel } from "./types/structs/structs/tx";
import { Substation } from "./types/structs/structs/substation";
import { MsgGuildUpdateOwnerId } from "./types/structs/structs/tx";
import { MsgGuildMembershipInviteDeny } from "./types/structs/structs/tx";
import { MsgSubstationDeleteResponse } from "./types/structs/structs/tx";
import { Fleet } from "./types/structs/structs/fleet";
import { QueryAllPlanetAttributeRequest } from "./types/structs/structs/query";
import { QueryAllReactorRequest } from "./types/structs/structs/query";
import { EventProvider } from "./types/structs/structs/events";
import { EventGuildBankRedeemDetail } from "./types/structs/structs/events";
import { MsgPlayerResume } from "./types/structs/structs/tx";
import { MsgProviderWithdrawBalance } from "./types/structs/structs/tx";
import { MsgProviderUpdateDurationMaximum } from "./types/structs/structs/tx";
import { QueryAllInfusionRequest } from "./types/structs/structs/query";
import { QueryGetProviderResponse } from "./types/structs/structs/query";
import { QueryAllProviderCollateralAddressResponse } from "./types/structs/structs/query";
import { NoData } from "./types/structs/structs/packet";
import { MsgReactorBeginMigration } from "./types/structs/structs/tx";
import { MsgReactorBeginMigrationResponse } from "./types/structs/structs/tx";
import { MsgSubstationPlayerDisconnect } from "./types/structs/structs/tx";
import { GuildMembershipApplication } from "./types/structs/structs/guild";
import { QueryGetAllocationRequest } from "./types/structs/structs/query";
import { EventAgreement } from "./types/structs/structs/events";
import { MsgAllocationDelete } from "./types/structs/structs/tx";
import { MsgAgreementOpen } from "./types/structs/structs/tx";
import { MsgPlayerSend } from "./types/structs/structs/tx";
import { QueryGetGuildRequest } from "./types/structs/structs/query";
import { Planet } from "./types/structs/structs/planet";
import { MsgAllocationTransferResponse } from "./types/structs/structs/tx";
import { MsgStructDefenseClear } from "./types/structs/structs/tx";
import { QueryAllAgreementResponse } from "./types/structs/structs/query";
import { QueryAllPermissionByObjectRequest } from "./types/structs/structs/query";
import { QueryAllStructAttributeResponse } from "./types/structs/structs/query";
import { EventAlphaDefuseDetail } from "./types/structs/structs/events";
import { MsgGuildMembershipJoinProxy } from "./types/structs/structs/tx";
import { MsgStructBuildInitiate } from "./types/structs/structs/tx";
import { GenesisState } from "./types/structs/structs/genesis";
import { QueryGetFleetResponse } from "./types/structs/structs/query";
import { QueryAllGuildRequest } from "./types/structs/structs/query";
import { QueryGetPlanetAttributeResponse } from "./types/structs/structs/query";
import { MsgGuildBankMintResponse } from "./types/structs/structs/tx";
import { MsgGuildBankConfiscateAndBurn } from "./types/structs/structs/tx";
import { MsgSubstationPlayerConnect } from "./types/structs/structs/tx";
import { QueryAllGuildMembershipApplicationResponse } from "./types/structs/structs/query";
import { QueryAllProviderRequest } from "./types/structs/structs/query";
import { QueryGetProviderByEarningsAddressRequest } from "./types/structs/structs/query";
import { EventPlayer } from "./types/structs/structs/events";
import { EventProviderRevokeGuild } from "./types/structs/structs/events";
import { MsgAddressRegisterResponse } from "./types/structs/structs/tx";
import { MsgPermissionGrantOnObject } from "./types/structs/structs/tx";
import { QueryGetPlayerRequest } from "./types/structs/structs/query";
import { QueryAllStructTypeResponse } from "./types/structs/structs/query";
import { MsgPlanetRaidCompleteResponse } from "./types/structs/structs/tx";
import { MsgReactorDefuse } from "./types/structs/structs/tx";
import { MsgStructStealthActivate } from "./types/structs/structs/tx";
import { QueryGetGuildBankCollateralAddressRequest } from "./types/structs/structs/query";
import { QueryAllGuildMembershipApplicationRequest } from "./types/structs/structs/query";
import { QueryAllPermissionRequest } from "./types/structs/structs/query";
import { QueryAllProviderEarningsAddressResponse } from "./types/structs/structs/query";
import { Struct } from "./types/structs/structs/struct";
import { EventProviderAddress } from "./types/structs/structs/events";
import { MsgSubstationAllocationDisconnect } from "./types/structs/structs/tx";
import { QueryGetAddressRequest } from "./types/structs/structs/query";
import { EventPlayerHalted } from "./types/structs/structs/events";
import { MsgUpdateParams } from "./types/structs/structs/tx";
import { MsgGuildBankMint } from "./types/structs/structs/tx";
import { MsgGuildUpdateJoinInfusionMinimum } from "./types/structs/structs/tx";
import { QueryAllPermissionResponse } from "./types/structs/structs/query";
import { EventAllocation } from "./types/structs/structs/events";
import { EventTimeDetail } from "./types/structs/structs/events";
import { MsgPlayerUpdatePrimaryAddress } from "./types/structs/structs/tx";
import { QueryGetAgreementRequest } from "./types/structs/structs/query";
import { MsgPermissionGrantOnAddress } from "./types/structs/structs/tx";
import { MsgPermissionSetOnAddress } from "./types/structs/structs/tx";
import { EventAddressActivity } from "./types/structs/structs/events";
import { EventRaid } from "./types/structs/structs/events";
import { MsgAllocationUpdateResponse } from "./types/structs/structs/tx";
import { MsgStructAttackResponse } from "./types/structs/structs/tx";
import { MsgSubstationCreate } from "./types/structs/structs/tx";
import { QueryAllPlanetAttributeResponse } from "./types/structs/structs/query";
import { QueryAllProviderEarningsAddressRequest } from "./types/structs/structs/query";
import { QueryAllPlayerRequest } from "./types/structs/structs/query";
import { QueryGetStructAttributeRequest } from "./types/structs/structs/query";
import { EventGuildBankAddress } from "./types/structs/structs/events";
import { MsgAllocationCreateResponse } from "./types/structs/structs/tx";
import { Allocation } from "./types/structs/structs/allocation";
import { QueryAllPermissionByPlayerRequest } from "./types/structs/structs/query";
import { QueryAllProviderCollateralAddressRequest } from "./types/structs/structs/query";
import { QueryGetProviderEarningsAddressRequest } from "./types/structs/structs/query";
import { MsgAllocationTransfer } from "./types/structs/structs/tx";
import { MsgGuildBankConfiscateAndBurnResponse } from "./types/structs/structs/tx";
import { MsgGuildMembershipKick } from "./types/structs/structs/tx";
import { QueryAllGridResponse } from "./types/structs/structs/query";
import { FleetAttributeRecord } from "./types/structs/structs/fleet";
import { MsgSubstationPlayerMigrate } from "./types/structs/structs/tx";
import { MsgProviderUpdateCapacityMaximum } from "./types/structs/structs/tx";
import { EventDelete } from "./types/structs/structs/events";
import { EventGuildBankMint } from "./types/structs/structs/events";
import { QueryGetGridRequest } from "./types/structs/structs/query";
import { QueryGetGuildResponse } from "./types/structs/structs/query";
import { QueryGetProviderCollateralAddressRequest } from "./types/structs/structs/query";
import { QueryGetStructRequest } from "./types/structs/structs/query";
import { QueryGetStructAttributeResponse } from "./types/structs/structs/query";
import { QueryAllStructTypeRequest } from "./types/structs/structs/query";
import { EventAlphaRefine } from "./types/structs/structs/events";
import { QueryAllInfusionByDestinationRequest } from "./types/structs/structs/query";
import { QueryGetPermissionRequest } from "./types/structs/structs/query";
import { QueryGetStructResponse } from "./types/structs/structs/query";
import { QueryGetSubstationRequest } from "./types/structs/structs/query";
import { EventRaidDetail } from "./types/structs/structs/events";
import { MsgGuildMembershipInvite } from "./types/structs/structs/tx";
import { MsgGuildMembershipInviteApprove } from "./types/structs/structs/tx";
import { QueryGetAllocationResponse } from "./types/structs/structs/query";
import { QueryAllGridRequest } from "./types/structs/structs/query";
import { QueryAllStructRequest } from "./types/structs/structs/query";
import { StructAttributeRecord } from "./types/structs/structs/struct";
import { EventPlanetAttribute } from "./types/structs/structs/events";
import { EventOreMine } from "./types/structs/structs/events";
import { EventAttackShotDetail } from "./types/structs/structs/events";
import { MsgStructStealthDeactivate } from "./types/structs/structs/tx";
import { StructAttributes } from "./types/structs/structs/struct";
import { EventStruct } from "./types/structs/structs/events";
import { MsgGuildUpdateResponse } from "./types/structs/structs/tx";
import { MsgProviderGuildRevoke } from "./types/structs/structs/tx";
import { MsgProviderDelete } from "./types/structs/structs/tx";
import { Agreement } from "./types/structs/structs/agreement";
import { EventGuildBankConfiscateAndBurnDetail } from "./types/structs/structs/events";
import { EventGuildMembershipApplication } from "./types/structs/structs/events";
import { MsgGuildMembershipJoin } from "./types/structs/structs/tx";
import { MsgPlanetExplore } from "./types/structs/structs/tx";
import { MsgStructStorageStash } from "./types/structs/structs/tx";
import { MsgSubstationAllocationConnectResponse } from "./types/structs/structs/tx";
import { MsgPermissionRevokeOnObject } from "./types/structs/structs/tx";
import { MsgReactorCancelDefusion } from "./types/structs/structs/tx";
import { MsgSubstationAllocationConnect } from "./types/structs/structs/tx";
import { QueryGetPlanetRequest } from "./types/structs/structs/query";
import { StructType } from "./types/structs/structs/struct";
import { MsgGuildMembershipResponse } from "./types/structs/structs/tx";
import { MsgReactorInfuse } from "./types/structs/structs/tx";
import { MsgStructBuildCompleteAndStash } from "./types/structs/structs/tx";
import { AddressAssociation } from "./types/structs/structs/address";
import { EventAddressAssociation } from "./types/structs/structs/events";
import { MsgReactorCancelDefusionResponse } from "./types/structs/structs/tx";
import { AddressRecord } from "./types/structs/structs/address";
import { StructDefenders } from "./types/structs/structs/struct";
import { EventPlanet } from "./types/structs/structs/events";
import { MsgGuildUpdateEntrySubstationId } from "./types/structs/structs/tx";
import { AddressActivity } from "./types/structs/structs/address";
import { EventAlphaInfuse } from "./types/structs/structs/events";
import { MsgUpdateParamsResponse } from "./types/structs/structs/tx";
import { MsgStructOreRefineryComplete } from "./types/structs/structs/tx";
import { QueryAllPlayerHaltedRequest } from "./types/structs/structs/query";
import { EventAlphaDefuse } from "./types/structs/structs/events";
import { QueryAllAddressResponse } from "./types/structs/structs/query";
import { QueryGetPermissionResponse } from "./types/structs/structs/query";
import { QueryGetPlanetAttributeRequest } from "./types/structs/structs/query";
import { EventPermission } from "./types/structs/structs/events";
import { EventOreTheftDetail } from "./types/structs/structs/events";
import { QueryGetPlanetResponse } from "./types/structs/structs/query";
import { Infusion } from "./types/structs/structs/infusion";
import { MsgGuildCreate } from "./types/structs/structs/tx";
import { MsgGuildMembershipRequest } from "./types/structs/structs/tx";
import { MsgPlayerUpdatePrimaryAddressResponse } from "./types/structs/structs/tx";
import { MsgAgreementClose } from "./types/structs/structs/tx";
import { QueryGetAgreementResponse } from "./types/structs/structs/query";
import { EventOreMigrate } from "./types/structs/structs/events";
import { MsgGuildCreateResponse } from "./types/structs/structs/tx";
import { MsgProviderGuildGrant } from "./types/structs/structs/tx";
import { QueryAddressResponse } from "./types/structs/structs/query";
import { MsgGuildMembershipRequestDeny } from "./types/structs/structs/tx";
import { MsgStructDeactivate } from "./types/structs/structs/tx";
import { MsgProviderResponse } from "./types/structs/structs/tx";
import { QueryAllPlanetResponse } from "./types/structs/structs/query";
import { QueryAllProviderResponse } from "./types/structs/structs/query";
import { EventAlphaInfuseDetail } from "./types/structs/structs/events";


export { MsgFleetMoveResponse, MsgPermissionSetOnObject, EventGuild, EventOreTheft, MsgStructMove, MsgStructOreMinerComplete, QueryAllAddressByPlayerRequest, EventOreMigrateDetail, MsgGuildBankRedeemResponse, MsgStructBuildComplete, MsgStructDefenseSet, MsgProviderUpdateAccessPolicy, QueryAllFleetRequest, MsgAllocationCreate, MsgPermissionResponse, QueryParamsRequest, QueryAllFleetResponse, PlayerInventory, EventProviderGrantGuildDetail, EventGuildBankMintDetail, MsgSubstationCreateResponse, MsgSubstationPlayerMigrateResponse, MsgProviderUpdateCapacityMinimum, QueryGetGuildMembershipApplicationResponse, QueryGetPlayerResponse, QueryGetSubstationResponse, StructDefender, MsgReactorDefuseResponse, MsgStructAttack, EventTime, MsgSubstationDelete, Guild, QueryGetProviderRequest, MsgAllocationUpdate, MsgSubstationPlayerDisconnectResponse, EventAlphaRefineDetail, MsgAllocationDeleteResponse, MsgGuildMembershipInviteRevoke, MsgProviderUpdateDurationMinimum, InternalAddressAssociation, Params, PermissionRecord, EventReactor, EventStructAttribute, MsgAddressRevoke, MsgSubstationPlayerConnectResponse, QueryGetFleetRequest, QueryGetInfusionResponse, QueryGetStructTypeRequest, EventAttackDefenderCounterDetail, MsgStructGeneratorInfuse, QueryAllPlayerHaltedResponse, EventProviderRevokeGuildDetail, PlanetAttributeRecord, MsgPlanetExploreResponse, QueryGetStructTypeResponse, EventInfusion, PlanetAttributes, MsgStructOreRefineryStatusResponse, QueryAllAgreementByProviderRequest, QueryAllGuildResponse, QueryGetGuildMembershipApplicationRequest, QueryGetProviderByCollateralAddressRequest, EventGuildBankAddressDetail, MsgGuildUpdateJoinInfusionMinimumBypassByRequest, MsgPermissionRevokeOnAddress, QueryParamsResponse, QueryAllPlanetRequest, QueryAllPlayerResponse, MsgAddressRevokeResponse, MsgStructActivate, MsgStructGeneratorStatusResponse, MsgAgreementCapacityIncrease, QueryGetGuildByBankCollateralAddressRequest, QueryValidateSignatureRequest, MsgPlanetRaidComplete, QueryAllAgreementRequest, QueryAllStructResponse, QueryAllSubstationResponse, EventPlayerResumed, QueryAllGuildBankCollateralAddressRequest, EventStructDefender, EventAttackDetail, MsgAddressRegister, MsgGuildMembershipRequestApprove, MsgStructOreMinerStatusResponse, QueryAllAllocationRequest, QueryAllAllocationBySourceRequest, GridAttributes, StructsPacketData, EventSubstation, MsgFleetMove, MsgGuildBankRedeem, QueryGetFleetByIndexRequest, QueryGetGridResponse, QueryGetInfusionRequest, QueryAllInfusionResponse, EventProviderAddressDetail, MsgGuildUpdateEndpoint, MsgAgreementDurationIncrease, QueryAllAllocationResponse, QueryAllReactorResponse, EventStructType, EventGrid, EventGuildBankRedeem, EventOreMineDetail, QueryAllAllocationByDestinationRequest, Player, MsgPlayerResumeResponse, MsgStructStatusResponse, MsgStructStorageRecall, MsgAgreementResponse, MsgProviderCreate, MsgPlayerSendResponse, QueryAllAddressRequest, QueryGetReactorResponse, EventProviderGrantGuild, EventGuildBankConfiscateAndBurn, QueryBlockHeightResponse, QueryAllPlanetByPlayerRequest, MsgGuildMembershipRequestRevoke, QueryAllStructAttributeRequest, Reactor, EventAttack, MsgSubstationAllocationDisconnectResponse, MsgAgreementCapacityDecrease, QueryAllGuildBankCollateralAddressResponse, QueryAllSubstationRequest, QueryValidateSignatureResponse, EventFleet, Provider, QueryBlockHeight, QueryGetReactorRequest, GridRecord, MsgGuildUpdateJoinInfusionMinimumBypassByInvite, MsgReactorInfuseResponse, MsgStructBuildCancel, Substation, MsgGuildUpdateOwnerId, MsgGuildMembershipInviteDeny, MsgSubstationDeleteResponse, Fleet, QueryAllPlanetAttributeRequest, QueryAllReactorRequest, EventProvider, EventGuildBankRedeemDetail, MsgPlayerResume, MsgProviderWithdrawBalance, MsgProviderUpdateDurationMaximum, QueryAllInfusionRequest, QueryGetProviderResponse, QueryAllProviderCollateralAddressResponse, NoData, MsgReactorBeginMigration, MsgReactorBeginMigrationResponse, MsgSubstationPlayerDisconnect, GuildMembershipApplication, QueryGetAllocationRequest, EventAgreement, MsgAllocationDelete, MsgAgreementOpen, MsgPlayerSend, QueryGetGuildRequest, Planet, MsgAllocationTransferResponse, MsgStructDefenseClear, QueryAllAgreementResponse, QueryAllPermissionByObjectRequest, QueryAllStructAttributeResponse, EventAlphaDefuseDetail, MsgGuildMembershipJoinProxy, MsgStructBuildInitiate, GenesisState, QueryGetFleetResponse, QueryAllGuildRequest, QueryGetPlanetAttributeResponse, MsgGuildBankMintResponse, MsgGuildBankConfiscateAndBurn, MsgSubstationPlayerConnect, QueryAllGuildMembershipApplicationResponse, QueryAllProviderRequest, QueryGetProviderByEarningsAddressRequest, EventPlayer, EventProviderRevokeGuild, MsgAddressRegisterResponse, MsgPermissionGrantOnObject, QueryGetPlayerRequest, QueryAllStructTypeResponse, MsgPlanetRaidCompleteResponse, MsgReactorDefuse, MsgStructStealthActivate, QueryGetGuildBankCollateralAddressRequest, QueryAllGuildMembershipApplicationRequest, QueryAllPermissionRequest, QueryAllProviderEarningsAddressResponse, Struct, EventProviderAddress, MsgSubstationAllocationDisconnect, QueryGetAddressRequest, EventPlayerHalted, MsgUpdateParams, MsgGuildBankMint, MsgGuildUpdateJoinInfusionMinimum, QueryAllPermissionResponse, EventAllocation, EventTimeDetail, MsgPlayerUpdatePrimaryAddress, QueryGetAgreementRequest, MsgPermissionGrantOnAddress, MsgPermissionSetOnAddress, EventAddressActivity, EventRaid, MsgAllocationUpdateResponse, MsgStructAttackResponse, MsgSubstationCreate, QueryAllPlanetAttributeResponse, QueryAllProviderEarningsAddressRequest, QueryAllPlayerRequest, QueryGetStructAttributeRequest, EventGuildBankAddress, MsgAllocationCreateResponse, Allocation, QueryAllPermissionByPlayerRequest, QueryAllProviderCollateralAddressRequest, QueryGetProviderEarningsAddressRequest, MsgAllocationTransfer, MsgGuildBankConfiscateAndBurnResponse, MsgGuildMembershipKick, QueryAllGridResponse, FleetAttributeRecord, MsgSubstationPlayerMigrate, MsgProviderUpdateCapacityMaximum, EventDelete, EventGuildBankMint, QueryGetGridRequest, QueryGetGuildResponse, QueryGetProviderCollateralAddressRequest, QueryGetStructRequest, QueryGetStructAttributeResponse, QueryAllStructTypeRequest, EventAlphaRefine, QueryAllInfusionByDestinationRequest, QueryGetPermissionRequest, QueryGetStructResponse, QueryGetSubstationRequest, EventRaidDetail, MsgGuildMembershipInvite, MsgGuildMembershipInviteApprove, QueryGetAllocationResponse, QueryAllGridRequest, QueryAllStructRequest, StructAttributeRecord, EventPlanetAttribute, EventOreMine, EventAttackShotDetail, MsgStructStealthDeactivate, StructAttributes, EventStruct, MsgGuildUpdateResponse, MsgProviderGuildRevoke, MsgProviderDelete, Agreement, EventGuildBankConfiscateAndBurnDetail, EventGuildMembershipApplication, MsgGuildMembershipJoin, MsgPlanetExplore, MsgStructStorageStash, MsgSubstationAllocationConnectResponse, MsgPermissionRevokeOnObject, MsgReactorCancelDefusion, MsgSubstationAllocationConnect, QueryGetPlanetRequest, StructType, MsgGuildMembershipResponse, MsgReactorInfuse, MsgStructBuildCompleteAndStash, AddressAssociation, EventAddressAssociation, MsgReactorCancelDefusionResponse, AddressRecord, StructDefenders, EventPlanet, MsgGuildUpdateEntrySubstationId, AddressActivity, EventAlphaInfuse, MsgUpdateParamsResponse, MsgStructOreRefineryComplete, QueryAllPlayerHaltedRequest, EventAlphaDefuse, QueryAllAddressResponse, QueryGetPermissionResponse, QueryGetPlanetAttributeRequest, EventPermission, EventOreTheftDetail, QueryGetPlanetResponse, Infusion, MsgGuildCreate, MsgGuildMembershipRequest, MsgPlayerUpdatePrimaryAddressResponse, MsgAgreementClose, QueryGetAgreementResponse, EventOreMigrate, MsgGuildCreateResponse, MsgProviderGuildGrant, QueryAddressResponse, MsgGuildMembershipRequestDeny, MsgStructDeactivate, MsgProviderResponse, QueryAllPlanetResponse, QueryAllProviderResponse, EventAlphaInfuseDetail };

type sendMsgFleetMoveResponseParams = {
  value: MsgFleetMoveResponse,
  fee?: StdFee,
  memo?: string
};

type sendMsgPermissionSetOnObjectParams = {
  value: MsgPermissionSetOnObject,
  fee?: StdFee,
  memo?: string
};

type sendEventGuildParams = {
  value: EventGuild,
  fee?: StdFee,
  memo?: string
};

type sendEventOreTheftParams = {
  value: EventOreTheft,
  fee?: StdFee,
  memo?: string
};

type sendMsgStructMoveParams = {
  value: MsgStructMove,
  fee?: StdFee,
  memo?: string
};

type sendMsgStructOreMinerCompleteParams = {
  value: MsgStructOreMinerComplete,
  fee?: StdFee,
  memo?: string
};

type sendQueryAllAddressByPlayerRequestParams = {
  value: QueryAllAddressByPlayerRequest,
  fee?: StdFee,
  memo?: string
};

type sendEventOreMigrateDetailParams = {
  value: EventOreMigrateDetail,
  fee?: StdFee,
  memo?: string
};

type sendMsgGuildBankRedeemResponseParams = {
  value: MsgGuildBankRedeemResponse,
  fee?: StdFee,
  memo?: string
};

type sendMsgStructBuildCompleteParams = {
  value: MsgStructBuildComplete,
  fee?: StdFee,
  memo?: string
};

type sendMsgStructDefenseSetParams = {
  value: MsgStructDefenseSet,
  fee?: StdFee,
  memo?: string
};

type sendMsgProviderUpdateAccessPolicyParams = {
  value: MsgProviderUpdateAccessPolicy,
  fee?: StdFee,
  memo?: string
};

type sendQueryAllFleetRequestParams = {
  value: QueryAllFleetRequest,
  fee?: StdFee,
  memo?: string
};

type sendMsgAllocationCreateParams = {
  value: MsgAllocationCreate,
  fee?: StdFee,
  memo?: string
};

type sendMsgPermissionResponseParams = {
  value: MsgPermissionResponse,
  fee?: StdFee,
  memo?: string
};

type sendQueryParamsRequestParams = {
  value: QueryParamsRequest,
  fee?: StdFee,
  memo?: string
};

type sendQueryAllFleetResponseParams = {
  value: QueryAllFleetResponse,
  fee?: StdFee,
  memo?: string
};

type sendPlayerInventoryParams = {
  value: PlayerInventory,
  fee?: StdFee,
  memo?: string
};

type sendEventProviderGrantGuildDetailParams = {
  value: EventProviderGrantGuildDetail,
  fee?: StdFee,
  memo?: string
};

type sendEventGuildBankMintDetailParams = {
  value: EventGuildBankMintDetail,
  fee?: StdFee,
  memo?: string
};

type sendMsgSubstationCreateResponseParams = {
  value: MsgSubstationCreateResponse,
  fee?: StdFee,
  memo?: string
};

type sendMsgSubstationPlayerMigrateResponseParams = {
  value: MsgSubstationPlayerMigrateResponse,
  fee?: StdFee,
  memo?: string
};

type sendMsgProviderUpdateCapacityMinimumParams = {
  value: MsgProviderUpdateCapacityMinimum,
  fee?: StdFee,
  memo?: string
};

type sendQueryGetGuildMembershipApplicationResponseParams = {
  value: QueryGetGuildMembershipApplicationResponse,
  fee?: StdFee,
  memo?: string
};

type sendQueryGetPlayerResponseParams = {
  value: QueryGetPlayerResponse,
  fee?: StdFee,
  memo?: string
};

type sendQueryGetSubstationResponseParams = {
  value: QueryGetSubstationResponse,
  fee?: StdFee,
  memo?: string
};

type sendStructDefenderParams = {
  value: StructDefender,
  fee?: StdFee,
  memo?: string
};

type sendMsgReactorDefuseResponseParams = {
  value: MsgReactorDefuseResponse,
  fee?: StdFee,
  memo?: string
};

type sendMsgStructAttackParams = {
  value: MsgStructAttack,
  fee?: StdFee,
  memo?: string
};

type sendEventTimeParams = {
  value: EventTime,
  fee?: StdFee,
  memo?: string
};

type sendMsgSubstationDeleteParams = {
  value: MsgSubstationDelete,
  fee?: StdFee,
  memo?: string
};

type sendGuildParams = {
  value: Guild,
  fee?: StdFee,
  memo?: string
};

type sendQueryGetProviderRequestParams = {
  value: QueryGetProviderRequest,
  fee?: StdFee,
  memo?: string
};

type sendMsgAllocationUpdateParams = {
  value: MsgAllocationUpdate,
  fee?: StdFee,
  memo?: string
};

type sendMsgSubstationPlayerDisconnectResponseParams = {
  value: MsgSubstationPlayerDisconnectResponse,
  fee?: StdFee,
  memo?: string
};

type sendEventAlphaRefineDetailParams = {
  value: EventAlphaRefineDetail,
  fee?: StdFee,
  memo?: string
};

type sendMsgAllocationDeleteResponseParams = {
  value: MsgAllocationDeleteResponse,
  fee?: StdFee,
  memo?: string
};

type sendMsgGuildMembershipInviteRevokeParams = {
  value: MsgGuildMembershipInviteRevoke,
  fee?: StdFee,
  memo?: string
};

type sendMsgProviderUpdateDurationMinimumParams = {
  value: MsgProviderUpdateDurationMinimum,
  fee?: StdFee,
  memo?: string
};

type sendInternalAddressAssociationParams = {
  value: InternalAddressAssociation,
  fee?: StdFee,
  memo?: string
};

type sendParamsParams = {
  value: Params,
  fee?: StdFee,
  memo?: string
};

type sendPermissionRecordParams = {
  value: PermissionRecord,
  fee?: StdFee,
  memo?: string
};

type sendEventReactorParams = {
  value: EventReactor,
  fee?: StdFee,
  memo?: string
};

type sendEventStructAttributeParams = {
  value: EventStructAttribute,
  fee?: StdFee,
  memo?: string
};

type sendMsgAddressRevokeParams = {
  value: MsgAddressRevoke,
  fee?: StdFee,
  memo?: string
};

type sendMsgSubstationPlayerConnectResponseParams = {
  value: MsgSubstationPlayerConnectResponse,
  fee?: StdFee,
  memo?: string
};

type sendQueryGetFleetRequestParams = {
  value: QueryGetFleetRequest,
  fee?: StdFee,
  memo?: string
};

type sendQueryGetInfusionResponseParams = {
  value: QueryGetInfusionResponse,
  fee?: StdFee,
  memo?: string
};

type sendQueryGetStructTypeRequestParams = {
  value: QueryGetStructTypeRequest,
  fee?: StdFee,
  memo?: string
};

type sendEventAttackDefenderCounterDetailParams = {
  value: EventAttackDefenderCounterDetail,
  fee?: StdFee,
  memo?: string
};

type sendMsgStructGeneratorInfuseParams = {
  value: MsgStructGeneratorInfuse,
  fee?: StdFee,
  memo?: string
};

type sendQueryAllPlayerHaltedResponseParams = {
  value: QueryAllPlayerHaltedResponse,
  fee?: StdFee,
  memo?: string
};

type sendEventProviderRevokeGuildDetailParams = {
  value: EventProviderRevokeGuildDetail,
  fee?: StdFee,
  memo?: string
};

type sendPlanetAttributeRecordParams = {
  value: PlanetAttributeRecord,
  fee?: StdFee,
  memo?: string
};

type sendMsgPlanetExploreResponseParams = {
  value: MsgPlanetExploreResponse,
  fee?: StdFee,
  memo?: string
};

type sendQueryGetStructTypeResponseParams = {
  value: QueryGetStructTypeResponse,
  fee?: StdFee,
  memo?: string
};

type sendEventInfusionParams = {
  value: EventInfusion,
  fee?: StdFee,
  memo?: string
};

type sendPlanetAttributesParams = {
  value: PlanetAttributes,
  fee?: StdFee,
  memo?: string
};

type sendMsgStructOreRefineryStatusResponseParams = {
  value: MsgStructOreRefineryStatusResponse,
  fee?: StdFee,
  memo?: string
};

type sendQueryAllAgreementByProviderRequestParams = {
  value: QueryAllAgreementByProviderRequest,
  fee?: StdFee,
  memo?: string
};

type sendQueryAllGuildResponseParams = {
  value: QueryAllGuildResponse,
  fee?: StdFee,
  memo?: string
};

type sendQueryGetGuildMembershipApplicationRequestParams = {
  value: QueryGetGuildMembershipApplicationRequest,
  fee?: StdFee,
  memo?: string
};

type sendQueryGetProviderByCollateralAddressRequestParams = {
  value: QueryGetProviderByCollateralAddressRequest,
  fee?: StdFee,
  memo?: string
};

type sendEventGuildBankAddressDetailParams = {
  value: EventGuildBankAddressDetail,
  fee?: StdFee,
  memo?: string
};

type sendMsgGuildUpdateJoinInfusionMinimumBypassByRequestParams = {
  value: MsgGuildUpdateJoinInfusionMinimumBypassByRequest,
  fee?: StdFee,
  memo?: string
};

type sendMsgPermissionRevokeOnAddressParams = {
  value: MsgPermissionRevokeOnAddress,
  fee?: StdFee,
  memo?: string
};

type sendQueryParamsResponseParams = {
  value: QueryParamsResponse,
  fee?: StdFee,
  memo?: string
};

type sendQueryAllPlanetRequestParams = {
  value: QueryAllPlanetRequest,
  fee?: StdFee,
  memo?: string
};

type sendQueryAllPlayerResponseParams = {
  value: QueryAllPlayerResponse,
  fee?: StdFee,
  memo?: string
};

type sendMsgAddressRevokeResponseParams = {
  value: MsgAddressRevokeResponse,
  fee?: StdFee,
  memo?: string
};

type sendMsgStructActivateParams = {
  value: MsgStructActivate,
  fee?: StdFee,
  memo?: string
};

type sendMsgStructGeneratorStatusResponseParams = {
  value: MsgStructGeneratorStatusResponse,
  fee?: StdFee,
  memo?: string
};

type sendMsgAgreementCapacityIncreaseParams = {
  value: MsgAgreementCapacityIncrease,
  fee?: StdFee,
  memo?: string
};

type sendQueryGetGuildByBankCollateralAddressRequestParams = {
  value: QueryGetGuildByBankCollateralAddressRequest,
  fee?: StdFee,
  memo?: string
};

type sendQueryValidateSignatureRequestParams = {
  value: QueryValidateSignatureRequest,
  fee?: StdFee,
  memo?: string
};

type sendMsgPlanetRaidCompleteParams = {
  value: MsgPlanetRaidComplete,
  fee?: StdFee,
  memo?: string
};

type sendQueryAllAgreementRequestParams = {
  value: QueryAllAgreementRequest,
  fee?: StdFee,
  memo?: string
};

type sendQueryAllStructResponseParams = {
  value: QueryAllStructResponse,
  fee?: StdFee,
  memo?: string
};

type sendQueryAllSubstationResponseParams = {
  value: QueryAllSubstationResponse,
  fee?: StdFee,
  memo?: string
};

type sendEventPlayerResumedParams = {
  value: EventPlayerResumed,
  fee?: StdFee,
  memo?: string
};

type sendQueryAllGuildBankCollateralAddressRequestParams = {
  value: QueryAllGuildBankCollateralAddressRequest,
  fee?: StdFee,
  memo?: string
};

type sendEventStructDefenderParams = {
  value: EventStructDefender,
  fee?: StdFee,
  memo?: string
};

type sendEventAttackDetailParams = {
  value: EventAttackDetail,
  fee?: StdFee,
  memo?: string
};

type sendMsgAddressRegisterParams = {
  value: MsgAddressRegister,
  fee?: StdFee,
  memo?: string
};

type sendMsgGuildMembershipRequestApproveParams = {
  value: MsgGuildMembershipRequestApprove,
  fee?: StdFee,
  memo?: string
};

type sendMsgStructOreMinerStatusResponseParams = {
  value: MsgStructOreMinerStatusResponse,
  fee?: StdFee,
  memo?: string
};

type sendQueryAllAllocationRequestParams = {
  value: QueryAllAllocationRequest,
  fee?: StdFee,
  memo?: string
};

type sendQueryAllAllocationBySourceRequestParams = {
  value: QueryAllAllocationBySourceRequest,
  fee?: StdFee,
  memo?: string
};

type sendGridAttributesParams = {
  value: GridAttributes,
  fee?: StdFee,
  memo?: string
};

type sendStructsPacketDataParams = {
  value: StructsPacketData,
  fee?: StdFee,
  memo?: string
};

type sendEventSubstationParams = {
  value: EventSubstation,
  fee?: StdFee,
  memo?: string
};

type sendMsgFleetMoveParams = {
  value: MsgFleetMove,
  fee?: StdFee,
  memo?: string
};

type sendMsgGuildBankRedeemParams = {
  value: MsgGuildBankRedeem,
  fee?: StdFee,
  memo?: string
};

type sendQueryGetFleetByIndexRequestParams = {
  value: QueryGetFleetByIndexRequest,
  fee?: StdFee,
  memo?: string
};

type sendQueryGetGridResponseParams = {
  value: QueryGetGridResponse,
  fee?: StdFee,
  memo?: string
};

type sendQueryGetInfusionRequestParams = {
  value: QueryGetInfusionRequest,
  fee?: StdFee,
  memo?: string
};

type sendQueryAllInfusionResponseParams = {
  value: QueryAllInfusionResponse,
  fee?: StdFee,
  memo?: string
};

type sendEventProviderAddressDetailParams = {
  value: EventProviderAddressDetail,
  fee?: StdFee,
  memo?: string
};

type sendMsgGuildUpdateEndpointParams = {
  value: MsgGuildUpdateEndpoint,
  fee?: StdFee,
  memo?: string
};

type sendMsgAgreementDurationIncreaseParams = {
  value: MsgAgreementDurationIncrease,
  fee?: StdFee,
  memo?: string
};

type sendQueryAllAllocationResponseParams = {
  value: QueryAllAllocationResponse,
  fee?: StdFee,
  memo?: string
};

type sendQueryAllReactorResponseParams = {
  value: QueryAllReactorResponse,
  fee?: StdFee,
  memo?: string
};

type sendEventStructTypeParams = {
  value: EventStructType,
  fee?: StdFee,
  memo?: string
};

type sendEventGridParams = {
  value: EventGrid,
  fee?: StdFee,
  memo?: string
};

type sendEventGuildBankRedeemParams = {
  value: EventGuildBankRedeem,
  fee?: StdFee,
  memo?: string
};

type sendEventOreMineDetailParams = {
  value: EventOreMineDetail,
  fee?: StdFee,
  memo?: string
};

type sendQueryAllAllocationByDestinationRequestParams = {
  value: QueryAllAllocationByDestinationRequest,
  fee?: StdFee,
  memo?: string
};

type sendPlayerParams = {
  value: Player,
  fee?: StdFee,
  memo?: string
};

type sendMsgPlayerResumeResponseParams = {
  value: MsgPlayerResumeResponse,
  fee?: StdFee,
  memo?: string
};

type sendMsgStructStatusResponseParams = {
  value: MsgStructStatusResponse,
  fee?: StdFee,
  memo?: string
};

type sendMsgStructStorageRecallParams = {
  value: MsgStructStorageRecall,
  fee?: StdFee,
  memo?: string
};

type sendMsgAgreementResponseParams = {
  value: MsgAgreementResponse,
  fee?: StdFee,
  memo?: string
};

type sendMsgProviderCreateParams = {
  value: MsgProviderCreate,
  fee?: StdFee,
  memo?: string
};

type sendMsgPlayerSendResponseParams = {
  value: MsgPlayerSendResponse,
  fee?: StdFee,
  memo?: string
};

type sendQueryAllAddressRequestParams = {
  value: QueryAllAddressRequest,
  fee?: StdFee,
  memo?: string
};

type sendQueryGetReactorResponseParams = {
  value: QueryGetReactorResponse,
  fee?: StdFee,
  memo?: string
};

type sendEventProviderGrantGuildParams = {
  value: EventProviderGrantGuild,
  fee?: StdFee,
  memo?: string
};

type sendEventGuildBankConfiscateAndBurnParams = {
  value: EventGuildBankConfiscateAndBurn,
  fee?: StdFee,
  memo?: string
};

type sendQueryBlockHeightResponseParams = {
  value: QueryBlockHeightResponse,
  fee?: StdFee,
  memo?: string
};

type sendQueryAllPlanetByPlayerRequestParams = {
  value: QueryAllPlanetByPlayerRequest,
  fee?: StdFee,
  memo?: string
};

type sendMsgGuildMembershipRequestRevokeParams = {
  value: MsgGuildMembershipRequestRevoke,
  fee?: StdFee,
  memo?: string
};

type sendQueryAllStructAttributeRequestParams = {
  value: QueryAllStructAttributeRequest,
  fee?: StdFee,
  memo?: string
};

type sendReactorParams = {
  value: Reactor,
  fee?: StdFee,
  memo?: string
};

type sendEventAttackParams = {
  value: EventAttack,
  fee?: StdFee,
  memo?: string
};

type sendMsgSubstationAllocationDisconnectResponseParams = {
  value: MsgSubstationAllocationDisconnectResponse,
  fee?: StdFee,
  memo?: string
};

type sendMsgAgreementCapacityDecreaseParams = {
  value: MsgAgreementCapacityDecrease,
  fee?: StdFee,
  memo?: string
};

type sendQueryAllGuildBankCollateralAddressResponseParams = {
  value: QueryAllGuildBankCollateralAddressResponse,
  fee?: StdFee,
  memo?: string
};

type sendQueryAllSubstationRequestParams = {
  value: QueryAllSubstationRequest,
  fee?: StdFee,
  memo?: string
};

type sendQueryValidateSignatureResponseParams = {
  value: QueryValidateSignatureResponse,
  fee?: StdFee,
  memo?: string
};

type sendEventFleetParams = {
  value: EventFleet,
  fee?: StdFee,
  memo?: string
};

type sendProviderParams = {
  value: Provider,
  fee?: StdFee,
  memo?: string
};

type sendQueryBlockHeightParams = {
  value: QueryBlockHeight,
  fee?: StdFee,
  memo?: string
};

type sendQueryGetReactorRequestParams = {
  value: QueryGetReactorRequest,
  fee?: StdFee,
  memo?: string
};

type sendGridRecordParams = {
  value: GridRecord,
  fee?: StdFee,
  memo?: string
};

type sendMsgGuildUpdateJoinInfusionMinimumBypassByInviteParams = {
  value: MsgGuildUpdateJoinInfusionMinimumBypassByInvite,
  fee?: StdFee,
  memo?: string
};

type sendMsgReactorInfuseResponseParams = {
  value: MsgReactorInfuseResponse,
  fee?: StdFee,
  memo?: string
};

type sendMsgStructBuildCancelParams = {
  value: MsgStructBuildCancel,
  fee?: StdFee,
  memo?: string
};

type sendSubstationParams = {
  value: Substation,
  fee?: StdFee,
  memo?: string
};

type sendMsgGuildUpdateOwnerIdParams = {
  value: MsgGuildUpdateOwnerId,
  fee?: StdFee,
  memo?: string
};

type sendMsgGuildMembershipInviteDenyParams = {
  value: MsgGuildMembershipInviteDeny,
  fee?: StdFee,
  memo?: string
};

type sendMsgSubstationDeleteResponseParams = {
  value: MsgSubstationDeleteResponse,
  fee?: StdFee,
  memo?: string
};

type sendFleetParams = {
  value: Fleet,
  fee?: StdFee,
  memo?: string
};

type sendQueryAllPlanetAttributeRequestParams = {
  value: QueryAllPlanetAttributeRequest,
  fee?: StdFee,
  memo?: string
};

type sendQueryAllReactorRequestParams = {
  value: QueryAllReactorRequest,
  fee?: StdFee,
  memo?: string
};

type sendEventProviderParams = {
  value: EventProvider,
  fee?: StdFee,
  memo?: string
};

type sendEventGuildBankRedeemDetailParams = {
  value: EventGuildBankRedeemDetail,
  fee?: StdFee,
  memo?: string
};

type sendMsgPlayerResumeParams = {
  value: MsgPlayerResume,
  fee?: StdFee,
  memo?: string
};

type sendMsgProviderWithdrawBalanceParams = {
  value: MsgProviderWithdrawBalance,
  fee?: StdFee,
  memo?: string
};

type sendMsgProviderUpdateDurationMaximumParams = {
  value: MsgProviderUpdateDurationMaximum,
  fee?: StdFee,
  memo?: string
};

type sendQueryAllInfusionRequestParams = {
  value: QueryAllInfusionRequest,
  fee?: StdFee,
  memo?: string
};

type sendQueryGetProviderResponseParams = {
  value: QueryGetProviderResponse,
  fee?: StdFee,
  memo?: string
};

type sendQueryAllProviderCollateralAddressResponseParams = {
  value: QueryAllProviderCollateralAddressResponse,
  fee?: StdFee,
  memo?: string
};

type sendNoDataParams = {
  value: NoData,
  fee?: StdFee,
  memo?: string
};

type sendMsgReactorBeginMigrationParams = {
  value: MsgReactorBeginMigration,
  fee?: StdFee,
  memo?: string
};

type sendMsgReactorBeginMigrationResponseParams = {
  value: MsgReactorBeginMigrationResponse,
  fee?: StdFee,
  memo?: string
};

type sendMsgSubstationPlayerDisconnectParams = {
  value: MsgSubstationPlayerDisconnect,
  fee?: StdFee,
  memo?: string
};

type sendGuildMembershipApplicationParams = {
  value: GuildMembershipApplication,
  fee?: StdFee,
  memo?: string
};

type sendQueryGetAllocationRequestParams = {
  value: QueryGetAllocationRequest,
  fee?: StdFee,
  memo?: string
};

type sendEventAgreementParams = {
  value: EventAgreement,
  fee?: StdFee,
  memo?: string
};

type sendMsgAllocationDeleteParams = {
  value: MsgAllocationDelete,
  fee?: StdFee,
  memo?: string
};

type sendMsgAgreementOpenParams = {
  value: MsgAgreementOpen,
  fee?: StdFee,
  memo?: string
};

type sendMsgPlayerSendParams = {
  value: MsgPlayerSend,
  fee?: StdFee,
  memo?: string
};

type sendQueryGetGuildRequestParams = {
  value: QueryGetGuildRequest,
  fee?: StdFee,
  memo?: string
};

type sendPlanetParams = {
  value: Planet,
  fee?: StdFee,
  memo?: string
};

type sendMsgAllocationTransferResponseParams = {
  value: MsgAllocationTransferResponse,
  fee?: StdFee,
  memo?: string
};

type sendMsgStructDefenseClearParams = {
  value: MsgStructDefenseClear,
  fee?: StdFee,
  memo?: string
};

type sendQueryAllAgreementResponseParams = {
  value: QueryAllAgreementResponse,
  fee?: StdFee,
  memo?: string
};

type sendQueryAllPermissionByObjectRequestParams = {
  value: QueryAllPermissionByObjectRequest,
  fee?: StdFee,
  memo?: string
};

type sendQueryAllStructAttributeResponseParams = {
  value: QueryAllStructAttributeResponse,
  fee?: StdFee,
  memo?: string
};

type sendEventAlphaDefuseDetailParams = {
  value: EventAlphaDefuseDetail,
  fee?: StdFee,
  memo?: string
};

type sendMsgGuildMembershipJoinProxyParams = {
  value: MsgGuildMembershipJoinProxy,
  fee?: StdFee,
  memo?: string
};

type sendMsgStructBuildInitiateParams = {
  value: MsgStructBuildInitiate,
  fee?: StdFee,
  memo?: string
};

type sendGenesisStateParams = {
  value: GenesisState,
  fee?: StdFee,
  memo?: string
};

type sendQueryGetFleetResponseParams = {
  value: QueryGetFleetResponse,
  fee?: StdFee,
  memo?: string
};

type sendQueryAllGuildRequestParams = {
  value: QueryAllGuildRequest,
  fee?: StdFee,
  memo?: string
};

type sendQueryGetPlanetAttributeResponseParams = {
  value: QueryGetPlanetAttributeResponse,
  fee?: StdFee,
  memo?: string
};

type sendMsgGuildBankMintResponseParams = {
  value: MsgGuildBankMintResponse,
  fee?: StdFee,
  memo?: string
};

type sendMsgGuildBankConfiscateAndBurnParams = {
  value: MsgGuildBankConfiscateAndBurn,
  fee?: StdFee,
  memo?: string
};

type sendMsgSubstationPlayerConnectParams = {
  value: MsgSubstationPlayerConnect,
  fee?: StdFee,
  memo?: string
};

type sendQueryAllGuildMembershipApplicationResponseParams = {
  value: QueryAllGuildMembershipApplicationResponse,
  fee?: StdFee,
  memo?: string
};

type sendQueryAllProviderRequestParams = {
  value: QueryAllProviderRequest,
  fee?: StdFee,
  memo?: string
};

type sendQueryGetProviderByEarningsAddressRequestParams = {
  value: QueryGetProviderByEarningsAddressRequest,
  fee?: StdFee,
  memo?: string
};

type sendEventPlayerParams = {
  value: EventPlayer,
  fee?: StdFee,
  memo?: string
};

type sendEventProviderRevokeGuildParams = {
  value: EventProviderRevokeGuild,
  fee?: StdFee,
  memo?: string
};

type sendMsgAddressRegisterResponseParams = {
  value: MsgAddressRegisterResponse,
  fee?: StdFee,
  memo?: string
};

type sendMsgPermissionGrantOnObjectParams = {
  value: MsgPermissionGrantOnObject,
  fee?: StdFee,
  memo?: string
};

type sendQueryGetPlayerRequestParams = {
  value: QueryGetPlayerRequest,
  fee?: StdFee,
  memo?: string
};

type sendQueryAllStructTypeResponseParams = {
  value: QueryAllStructTypeResponse,
  fee?: StdFee,
  memo?: string
};

type sendMsgPlanetRaidCompleteResponseParams = {
  value: MsgPlanetRaidCompleteResponse,
  fee?: StdFee,
  memo?: string
};

type sendMsgReactorDefuseParams = {
  value: MsgReactorDefuse,
  fee?: StdFee,
  memo?: string
};

type sendMsgStructStealthActivateParams = {
  value: MsgStructStealthActivate,
  fee?: StdFee,
  memo?: string
};

type sendQueryGetGuildBankCollateralAddressRequestParams = {
  value: QueryGetGuildBankCollateralAddressRequest,
  fee?: StdFee,
  memo?: string
};

type sendQueryAllGuildMembershipApplicationRequestParams = {
  value: QueryAllGuildMembershipApplicationRequest,
  fee?: StdFee,
  memo?: string
};

type sendQueryAllPermissionRequestParams = {
  value: QueryAllPermissionRequest,
  fee?: StdFee,
  memo?: string
};

type sendQueryAllProviderEarningsAddressResponseParams = {
  value: QueryAllProviderEarningsAddressResponse,
  fee?: StdFee,
  memo?: string
};

type sendStructParams = {
  value: Struct,
  fee?: StdFee,
  memo?: string
};

type sendEventProviderAddressParams = {
  value: EventProviderAddress,
  fee?: StdFee,
  memo?: string
};

type sendMsgSubstationAllocationDisconnectParams = {
  value: MsgSubstationAllocationDisconnect,
  fee?: StdFee,
  memo?: string
};

type sendQueryGetAddressRequestParams = {
  value: QueryGetAddressRequest,
  fee?: StdFee,
  memo?: string
};

type sendEventPlayerHaltedParams = {
  value: EventPlayerHalted,
  fee?: StdFee,
  memo?: string
};

type sendMsgUpdateParamsParams = {
  value: MsgUpdateParams,
  fee?: StdFee,
  memo?: string
};

type sendMsgGuildBankMintParams = {
  value: MsgGuildBankMint,
  fee?: StdFee,
  memo?: string
};

type sendMsgGuildUpdateJoinInfusionMinimumParams = {
  value: MsgGuildUpdateJoinInfusionMinimum,
  fee?: StdFee,
  memo?: string
};

type sendQueryAllPermissionResponseParams = {
  value: QueryAllPermissionResponse,
  fee?: StdFee,
  memo?: string
};

type sendEventAllocationParams = {
  value: EventAllocation,
  fee?: StdFee,
  memo?: string
};

type sendEventTimeDetailParams = {
  value: EventTimeDetail,
  fee?: StdFee,
  memo?: string
};

type sendMsgPlayerUpdatePrimaryAddressParams = {
  value: MsgPlayerUpdatePrimaryAddress,
  fee?: StdFee,
  memo?: string
};

type sendQueryGetAgreementRequestParams = {
  value: QueryGetAgreementRequest,
  fee?: StdFee,
  memo?: string
};

type sendMsgPermissionGrantOnAddressParams = {
  value: MsgPermissionGrantOnAddress,
  fee?: StdFee,
  memo?: string
};

type sendMsgPermissionSetOnAddressParams = {
  value: MsgPermissionSetOnAddress,
  fee?: StdFee,
  memo?: string
};

type sendEventAddressActivityParams = {
  value: EventAddressActivity,
  fee?: StdFee,
  memo?: string
};

type sendEventRaidParams = {
  value: EventRaid,
  fee?: StdFee,
  memo?: string
};

type sendMsgAllocationUpdateResponseParams = {
  value: MsgAllocationUpdateResponse,
  fee?: StdFee,
  memo?: string
};

type sendMsgStructAttackResponseParams = {
  value: MsgStructAttackResponse,
  fee?: StdFee,
  memo?: string
};

type sendMsgSubstationCreateParams = {
  value: MsgSubstationCreate,
  fee?: StdFee,
  memo?: string
};

type sendQueryAllPlanetAttributeResponseParams = {
  value: QueryAllPlanetAttributeResponse,
  fee?: StdFee,
  memo?: string
};

type sendQueryAllProviderEarningsAddressRequestParams = {
  value: QueryAllProviderEarningsAddressRequest,
  fee?: StdFee,
  memo?: string
};

type sendQueryAllPlayerRequestParams = {
  value: QueryAllPlayerRequest,
  fee?: StdFee,
  memo?: string
};

type sendQueryGetStructAttributeRequestParams = {
  value: QueryGetStructAttributeRequest,
  fee?: StdFee,
  memo?: string
};

type sendEventGuildBankAddressParams = {
  value: EventGuildBankAddress,
  fee?: StdFee,
  memo?: string
};

type sendMsgAllocationCreateResponseParams = {
  value: MsgAllocationCreateResponse,
  fee?: StdFee,
  memo?: string
};

type sendAllocationParams = {
  value: Allocation,
  fee?: StdFee,
  memo?: string
};

type sendQueryAllPermissionByPlayerRequestParams = {
  value: QueryAllPermissionByPlayerRequest,
  fee?: StdFee,
  memo?: string
};

type sendQueryAllProviderCollateralAddressRequestParams = {
  value: QueryAllProviderCollateralAddressRequest,
  fee?: StdFee,
  memo?: string
};

type sendQueryGetProviderEarningsAddressRequestParams = {
  value: QueryGetProviderEarningsAddressRequest,
  fee?: StdFee,
  memo?: string
};

type sendMsgAllocationTransferParams = {
  value: MsgAllocationTransfer,
  fee?: StdFee,
  memo?: string
};

type sendMsgGuildBankConfiscateAndBurnResponseParams = {
  value: MsgGuildBankConfiscateAndBurnResponse,
  fee?: StdFee,
  memo?: string
};

type sendMsgGuildMembershipKickParams = {
  value: MsgGuildMembershipKick,
  fee?: StdFee,
  memo?: string
};

type sendQueryAllGridResponseParams = {
  value: QueryAllGridResponse,
  fee?: StdFee,
  memo?: string
};

type sendFleetAttributeRecordParams = {
  value: FleetAttributeRecord,
  fee?: StdFee,
  memo?: string
};

type sendMsgSubstationPlayerMigrateParams = {
  value: MsgSubstationPlayerMigrate,
  fee?: StdFee,
  memo?: string
};

type sendMsgProviderUpdateCapacityMaximumParams = {
  value: MsgProviderUpdateCapacityMaximum,
  fee?: StdFee,
  memo?: string
};

type sendEventDeleteParams = {
  value: EventDelete,
  fee?: StdFee,
  memo?: string
};

type sendEventGuildBankMintParams = {
  value: EventGuildBankMint,
  fee?: StdFee,
  memo?: string
};

type sendQueryGetGridRequestParams = {
  value: QueryGetGridRequest,
  fee?: StdFee,
  memo?: string
};

type sendQueryGetGuildResponseParams = {
  value: QueryGetGuildResponse,
  fee?: StdFee,
  memo?: string
};

type sendQueryGetProviderCollateralAddressRequestParams = {
  value: QueryGetProviderCollateralAddressRequest,
  fee?: StdFee,
  memo?: string
};

type sendQueryGetStructRequestParams = {
  value: QueryGetStructRequest,
  fee?: StdFee,
  memo?: string
};

type sendQueryGetStructAttributeResponseParams = {
  value: QueryGetStructAttributeResponse,
  fee?: StdFee,
  memo?: string
};

type sendQueryAllStructTypeRequestParams = {
  value: QueryAllStructTypeRequest,
  fee?: StdFee,
  memo?: string
};

type sendEventAlphaRefineParams = {
  value: EventAlphaRefine,
  fee?: StdFee,
  memo?: string
};

type sendQueryAllInfusionByDestinationRequestParams = {
  value: QueryAllInfusionByDestinationRequest,
  fee?: StdFee,
  memo?: string
};

type sendQueryGetPermissionRequestParams = {
  value: QueryGetPermissionRequest,
  fee?: StdFee,
  memo?: string
};

type sendQueryGetStructResponseParams = {
  value: QueryGetStructResponse,
  fee?: StdFee,
  memo?: string
};

type sendQueryGetSubstationRequestParams = {
  value: QueryGetSubstationRequest,
  fee?: StdFee,
  memo?: string
};

type sendEventRaidDetailParams = {
  value: EventRaidDetail,
  fee?: StdFee,
  memo?: string
};

type sendMsgGuildMembershipInviteParams = {
  value: MsgGuildMembershipInvite,
  fee?: StdFee,
  memo?: string
};

type sendMsgGuildMembershipInviteApproveParams = {
  value: MsgGuildMembershipInviteApprove,
  fee?: StdFee,
  memo?: string
};

type sendQueryGetAllocationResponseParams = {
  value: QueryGetAllocationResponse,
  fee?: StdFee,
  memo?: string
};

type sendQueryAllGridRequestParams = {
  value: QueryAllGridRequest,
  fee?: StdFee,
  memo?: string
};

type sendQueryAllStructRequestParams = {
  value: QueryAllStructRequest,
  fee?: StdFee,
  memo?: string
};

type sendStructAttributeRecordParams = {
  value: StructAttributeRecord,
  fee?: StdFee,
  memo?: string
};

type sendEventPlanetAttributeParams = {
  value: EventPlanetAttribute,
  fee?: StdFee,
  memo?: string
};

type sendEventOreMineParams = {
  value: EventOreMine,
  fee?: StdFee,
  memo?: string
};

type sendEventAttackShotDetailParams = {
  value: EventAttackShotDetail,
  fee?: StdFee,
  memo?: string
};

type sendMsgStructStealthDeactivateParams = {
  value: MsgStructStealthDeactivate,
  fee?: StdFee,
  memo?: string
};

type sendStructAttributesParams = {
  value: StructAttributes,
  fee?: StdFee,
  memo?: string
};

type sendEventStructParams = {
  value: EventStruct,
  fee?: StdFee,
  memo?: string
};

type sendMsgGuildUpdateResponseParams = {
  value: MsgGuildUpdateResponse,
  fee?: StdFee,
  memo?: string
};

type sendMsgProviderGuildRevokeParams = {
  value: MsgProviderGuildRevoke,
  fee?: StdFee,
  memo?: string
};

type sendMsgProviderDeleteParams = {
  value: MsgProviderDelete,
  fee?: StdFee,
  memo?: string
};

type sendAgreementParams = {
  value: Agreement,
  fee?: StdFee,
  memo?: string
};

type sendEventGuildBankConfiscateAndBurnDetailParams = {
  value: EventGuildBankConfiscateAndBurnDetail,
  fee?: StdFee,
  memo?: string
};

type sendEventGuildMembershipApplicationParams = {
  value: EventGuildMembershipApplication,
  fee?: StdFee,
  memo?: string
};

type sendMsgGuildMembershipJoinParams = {
  value: MsgGuildMembershipJoin,
  fee?: StdFee,
  memo?: string
};

type sendMsgPlanetExploreParams = {
  value: MsgPlanetExplore,
  fee?: StdFee,
  memo?: string
};

type sendMsgStructStorageStashParams = {
  value: MsgStructStorageStash,
  fee?: StdFee,
  memo?: string
};

type sendMsgSubstationAllocationConnectResponseParams = {
  value: MsgSubstationAllocationConnectResponse,
  fee?: StdFee,
  memo?: string
};

type sendMsgPermissionRevokeOnObjectParams = {
  value: MsgPermissionRevokeOnObject,
  fee?: StdFee,
  memo?: string
};

type sendMsgReactorCancelDefusionParams = {
  value: MsgReactorCancelDefusion,
  fee?: StdFee,
  memo?: string
};

type sendMsgSubstationAllocationConnectParams = {
  value: MsgSubstationAllocationConnect,
  fee?: StdFee,
  memo?: string
};

type sendQueryGetPlanetRequestParams = {
  value: QueryGetPlanetRequest,
  fee?: StdFee,
  memo?: string
};

type sendStructTypeParams = {
  value: StructType,
  fee?: StdFee,
  memo?: string
};

type sendMsgGuildMembershipResponseParams = {
  value: MsgGuildMembershipResponse,
  fee?: StdFee,
  memo?: string
};

type sendMsgReactorInfuseParams = {
  value: MsgReactorInfuse,
  fee?: StdFee,
  memo?: string
};

type sendMsgStructBuildCompleteAndStashParams = {
  value: MsgStructBuildCompleteAndStash,
  fee?: StdFee,
  memo?: string
};

type sendAddressAssociationParams = {
  value: AddressAssociation,
  fee?: StdFee,
  memo?: string
};

type sendEventAddressAssociationParams = {
  value: EventAddressAssociation,
  fee?: StdFee,
  memo?: string
};

type sendMsgReactorCancelDefusionResponseParams = {
  value: MsgReactorCancelDefusionResponse,
  fee?: StdFee,
  memo?: string
};

type sendAddressRecordParams = {
  value: AddressRecord,
  fee?: StdFee,
  memo?: string
};

type sendStructDefendersParams = {
  value: StructDefenders,
  fee?: StdFee,
  memo?: string
};

type sendEventPlanetParams = {
  value: EventPlanet,
  fee?: StdFee,
  memo?: string
};

type sendMsgGuildUpdateEntrySubstationIdParams = {
  value: MsgGuildUpdateEntrySubstationId,
  fee?: StdFee,
  memo?: string
};

type sendAddressActivityParams = {
  value: AddressActivity,
  fee?: StdFee,
  memo?: string
};

type sendEventAlphaInfuseParams = {
  value: EventAlphaInfuse,
  fee?: StdFee,
  memo?: string
};

type sendMsgUpdateParamsResponseParams = {
  value: MsgUpdateParamsResponse,
  fee?: StdFee,
  memo?: string
};

type sendMsgStructOreRefineryCompleteParams = {
  value: MsgStructOreRefineryComplete,
  fee?: StdFee,
  memo?: string
};

type sendQueryAllPlayerHaltedRequestParams = {
  value: QueryAllPlayerHaltedRequest,
  fee?: StdFee,
  memo?: string
};

type sendEventAlphaDefuseParams = {
  value: EventAlphaDefuse,
  fee?: StdFee,
  memo?: string
};

type sendQueryAllAddressResponseParams = {
  value: QueryAllAddressResponse,
  fee?: StdFee,
  memo?: string
};

type sendQueryGetPermissionResponseParams = {
  value: QueryGetPermissionResponse,
  fee?: StdFee,
  memo?: string
};

type sendQueryGetPlanetAttributeRequestParams = {
  value: QueryGetPlanetAttributeRequest,
  fee?: StdFee,
  memo?: string
};

type sendEventPermissionParams = {
  value: EventPermission,
  fee?: StdFee,
  memo?: string
};

type sendEventOreTheftDetailParams = {
  value: EventOreTheftDetail,
  fee?: StdFee,
  memo?: string
};

type sendQueryGetPlanetResponseParams = {
  value: QueryGetPlanetResponse,
  fee?: StdFee,
  memo?: string
};

type sendInfusionParams = {
  value: Infusion,
  fee?: StdFee,
  memo?: string
};

type sendMsgGuildCreateParams = {
  value: MsgGuildCreate,
  fee?: StdFee,
  memo?: string
};

type sendMsgGuildMembershipRequestParams = {
  value: MsgGuildMembershipRequest,
  fee?: StdFee,
  memo?: string
};

type sendMsgPlayerUpdatePrimaryAddressResponseParams = {
  value: MsgPlayerUpdatePrimaryAddressResponse,
  fee?: StdFee,
  memo?: string
};

type sendMsgAgreementCloseParams = {
  value: MsgAgreementClose,
  fee?: StdFee,
  memo?: string
};

type sendQueryGetAgreementResponseParams = {
  value: QueryGetAgreementResponse,
  fee?: StdFee,
  memo?: string
};

type sendEventOreMigrateParams = {
  value: EventOreMigrate,
  fee?: StdFee,
  memo?: string
};

type sendMsgGuildCreateResponseParams = {
  value: MsgGuildCreateResponse,
  fee?: StdFee,
  memo?: string
};

type sendMsgProviderGuildGrantParams = {
  value: MsgProviderGuildGrant,
  fee?: StdFee,
  memo?: string
};

type sendQueryAddressResponseParams = {
  value: QueryAddressResponse,
  fee?: StdFee,
  memo?: string
};

type sendMsgGuildMembershipRequestDenyParams = {
  value: MsgGuildMembershipRequestDeny,
  fee?: StdFee,
  memo?: string
};

type sendMsgStructDeactivateParams = {
  value: MsgStructDeactivate,
  fee?: StdFee,
  memo?: string
};

type sendMsgProviderResponseParams = {
  value: MsgProviderResponse,
  fee?: StdFee,
  memo?: string
};

type sendQueryAllPlanetResponseParams = {
  value: QueryAllPlanetResponse,
  fee?: StdFee,
  memo?: string
};

type sendQueryAllProviderResponseParams = {
  value: QueryAllProviderResponse,
  fee?: StdFee,
  memo?: string
};

type sendEventAlphaInfuseDetailParams = {
  value: EventAlphaInfuseDetail,
  fee?: StdFee,
  memo?: string
};


type msgFleetMoveResponseParams = {
  value: MsgFleetMoveResponse,
};

type msgPermissionSetOnObjectParams = {
  value: MsgPermissionSetOnObject,
};

type eventGuildParams = {
  value: EventGuild,
};

type eventOreTheftParams = {
  value: EventOreTheft,
};

type msgStructMoveParams = {
  value: MsgStructMove,
};

type msgStructOreMinerCompleteParams = {
  value: MsgStructOreMinerComplete,
};

type queryAllAddressByPlayerRequestParams = {
  value: QueryAllAddressByPlayerRequest,
};

type eventOreMigrateDetailParams = {
  value: EventOreMigrateDetail,
};

type msgGuildBankRedeemResponseParams = {
  value: MsgGuildBankRedeemResponse,
};

type msgStructBuildCompleteParams = {
  value: MsgStructBuildComplete,
};

type msgStructDefenseSetParams = {
  value: MsgStructDefenseSet,
};

type msgProviderUpdateAccessPolicyParams = {
  value: MsgProviderUpdateAccessPolicy,
};

type queryAllFleetRequestParams = {
  value: QueryAllFleetRequest,
};

type msgAllocationCreateParams = {
  value: MsgAllocationCreate,
};

type msgPermissionResponseParams = {
  value: MsgPermissionResponse,
};

type queryParamsRequestParams = {
  value: QueryParamsRequest,
};

type queryAllFleetResponseParams = {
  value: QueryAllFleetResponse,
};

type playerInventoryParams = {
  value: PlayerInventory,
};

type eventProviderGrantGuildDetailParams = {
  value: EventProviderGrantGuildDetail,
};

type eventGuildBankMintDetailParams = {
  value: EventGuildBankMintDetail,
};

type msgSubstationCreateResponseParams = {
  value: MsgSubstationCreateResponse,
};

type msgSubstationPlayerMigrateResponseParams = {
  value: MsgSubstationPlayerMigrateResponse,
};

type msgProviderUpdateCapacityMinimumParams = {
  value: MsgProviderUpdateCapacityMinimum,
};

type queryGetGuildMembershipApplicationResponseParams = {
  value: QueryGetGuildMembershipApplicationResponse,
};

type queryGetPlayerResponseParams = {
  value: QueryGetPlayerResponse,
};

type queryGetSubstationResponseParams = {
  value: QueryGetSubstationResponse,
};

type structDefenderParams = {
  value: StructDefender,
};

type msgReactorDefuseResponseParams = {
  value: MsgReactorDefuseResponse,
};

type msgStructAttackParams = {
  value: MsgStructAttack,
};

type eventTimeParams = {
  value: EventTime,
};

type msgSubstationDeleteParams = {
  value: MsgSubstationDelete,
};

type guildParams = {
  value: Guild,
};

type queryGetProviderRequestParams = {
  value: QueryGetProviderRequest,
};

type msgAllocationUpdateParams = {
  value: MsgAllocationUpdate,
};

type msgSubstationPlayerDisconnectResponseParams = {
  value: MsgSubstationPlayerDisconnectResponse,
};

type eventAlphaRefineDetailParams = {
  value: EventAlphaRefineDetail,
};

type msgAllocationDeleteResponseParams = {
  value: MsgAllocationDeleteResponse,
};

type msgGuildMembershipInviteRevokeParams = {
  value: MsgGuildMembershipInviteRevoke,
};

type msgProviderUpdateDurationMinimumParams = {
  value: MsgProviderUpdateDurationMinimum,
};

type internalAddressAssociationParams = {
  value: InternalAddressAssociation,
};

type paramsParams = {
  value: Params,
};

type permissionRecordParams = {
  value: PermissionRecord,
};

type eventReactorParams = {
  value: EventReactor,
};

type eventStructAttributeParams = {
  value: EventStructAttribute,
};

type msgAddressRevokeParams = {
  value: MsgAddressRevoke,
};

type msgSubstationPlayerConnectResponseParams = {
  value: MsgSubstationPlayerConnectResponse,
};

type queryGetFleetRequestParams = {
  value: QueryGetFleetRequest,
};

type queryGetInfusionResponseParams = {
  value: QueryGetInfusionResponse,
};

type queryGetStructTypeRequestParams = {
  value: QueryGetStructTypeRequest,
};

type eventAttackDefenderCounterDetailParams = {
  value: EventAttackDefenderCounterDetail,
};

type msgStructGeneratorInfuseParams = {
  value: MsgStructGeneratorInfuse,
};

type queryAllPlayerHaltedResponseParams = {
  value: QueryAllPlayerHaltedResponse,
};

type eventProviderRevokeGuildDetailParams = {
  value: EventProviderRevokeGuildDetail,
};

type planetAttributeRecordParams = {
  value: PlanetAttributeRecord,
};

type msgPlanetExploreResponseParams = {
  value: MsgPlanetExploreResponse,
};

type queryGetStructTypeResponseParams = {
  value: QueryGetStructTypeResponse,
};

type eventInfusionParams = {
  value: EventInfusion,
};

type planetAttributesParams = {
  value: PlanetAttributes,
};

type msgStructOreRefineryStatusResponseParams = {
  value: MsgStructOreRefineryStatusResponse,
};

type queryAllAgreementByProviderRequestParams = {
  value: QueryAllAgreementByProviderRequest,
};

type queryAllGuildResponseParams = {
  value: QueryAllGuildResponse,
};

type queryGetGuildMembershipApplicationRequestParams = {
  value: QueryGetGuildMembershipApplicationRequest,
};

type queryGetProviderByCollateralAddressRequestParams = {
  value: QueryGetProviderByCollateralAddressRequest,
};

type eventGuildBankAddressDetailParams = {
  value: EventGuildBankAddressDetail,
};

type msgGuildUpdateJoinInfusionMinimumBypassByRequestParams = {
  value: MsgGuildUpdateJoinInfusionMinimumBypassByRequest,
};

type msgPermissionRevokeOnAddressParams = {
  value: MsgPermissionRevokeOnAddress,
};

type queryParamsResponseParams = {
  value: QueryParamsResponse,
};

type queryAllPlanetRequestParams = {
  value: QueryAllPlanetRequest,
};

type queryAllPlayerResponseParams = {
  value: QueryAllPlayerResponse,
};

type msgAddressRevokeResponseParams = {
  value: MsgAddressRevokeResponse,
};

type msgStructActivateParams = {
  value: MsgStructActivate,
};

type msgStructGeneratorStatusResponseParams = {
  value: MsgStructGeneratorStatusResponse,
};

type msgAgreementCapacityIncreaseParams = {
  value: MsgAgreementCapacityIncrease,
};

type queryGetGuildByBankCollateralAddressRequestParams = {
  value: QueryGetGuildByBankCollateralAddressRequest,
};

type queryValidateSignatureRequestParams = {
  value: QueryValidateSignatureRequest,
};

type msgPlanetRaidCompleteParams = {
  value: MsgPlanetRaidComplete,
};

type queryAllAgreementRequestParams = {
  value: QueryAllAgreementRequest,
};

type queryAllStructResponseParams = {
  value: QueryAllStructResponse,
};

type queryAllSubstationResponseParams = {
  value: QueryAllSubstationResponse,
};

type eventPlayerResumedParams = {
  value: EventPlayerResumed,
};

type queryAllGuildBankCollateralAddressRequestParams = {
  value: QueryAllGuildBankCollateralAddressRequest,
};

type eventStructDefenderParams = {
  value: EventStructDefender,
};

type eventAttackDetailParams = {
  value: EventAttackDetail,
};

type msgAddressRegisterParams = {
  value: MsgAddressRegister,
};

type msgGuildMembershipRequestApproveParams = {
  value: MsgGuildMembershipRequestApprove,
};

type msgStructOreMinerStatusResponseParams = {
  value: MsgStructOreMinerStatusResponse,
};

type queryAllAllocationRequestParams = {
  value: QueryAllAllocationRequest,
};

type queryAllAllocationBySourceRequestParams = {
  value: QueryAllAllocationBySourceRequest,
};

type gridAttributesParams = {
  value: GridAttributes,
};

type structsPacketDataParams = {
  value: StructsPacketData,
};

type eventSubstationParams = {
  value: EventSubstation,
};

type msgFleetMoveParams = {
  value: MsgFleetMove,
};

type msgGuildBankRedeemParams = {
  value: MsgGuildBankRedeem,
};

type queryGetFleetByIndexRequestParams = {
  value: QueryGetFleetByIndexRequest,
};

type queryGetGridResponseParams = {
  value: QueryGetGridResponse,
};

type queryGetInfusionRequestParams = {
  value: QueryGetInfusionRequest,
};

type queryAllInfusionResponseParams = {
  value: QueryAllInfusionResponse,
};

type eventProviderAddressDetailParams = {
  value: EventProviderAddressDetail,
};

type msgGuildUpdateEndpointParams = {
  value: MsgGuildUpdateEndpoint,
};

type msgAgreementDurationIncreaseParams = {
  value: MsgAgreementDurationIncrease,
};

type queryAllAllocationResponseParams = {
  value: QueryAllAllocationResponse,
};

type queryAllReactorResponseParams = {
  value: QueryAllReactorResponse,
};

type eventStructTypeParams = {
  value: EventStructType,
};

type eventGridParams = {
  value: EventGrid,
};

type eventGuildBankRedeemParams = {
  value: EventGuildBankRedeem,
};

type eventOreMineDetailParams = {
  value: EventOreMineDetail,
};

type queryAllAllocationByDestinationRequestParams = {
  value: QueryAllAllocationByDestinationRequest,
};

type playerParams = {
  value: Player,
};

type msgPlayerResumeResponseParams = {
  value: MsgPlayerResumeResponse,
};

type msgStructStatusResponseParams = {
  value: MsgStructStatusResponse,
};

type msgStructStorageRecallParams = {
  value: MsgStructStorageRecall,
};

type msgAgreementResponseParams = {
  value: MsgAgreementResponse,
};

type msgProviderCreateParams = {
  value: MsgProviderCreate,
};

type msgPlayerSendResponseParams = {
  value: MsgPlayerSendResponse,
};

type queryAllAddressRequestParams = {
  value: QueryAllAddressRequest,
};

type queryGetReactorResponseParams = {
  value: QueryGetReactorResponse,
};

type eventProviderGrantGuildParams = {
  value: EventProviderGrantGuild,
};

type eventGuildBankConfiscateAndBurnParams = {
  value: EventGuildBankConfiscateAndBurn,
};

type queryBlockHeightResponseParams = {
  value: QueryBlockHeightResponse,
};

type queryAllPlanetByPlayerRequestParams = {
  value: QueryAllPlanetByPlayerRequest,
};

type msgGuildMembershipRequestRevokeParams = {
  value: MsgGuildMembershipRequestRevoke,
};

type queryAllStructAttributeRequestParams = {
  value: QueryAllStructAttributeRequest,
};

type reactorParams = {
  value: Reactor,
};

type eventAttackParams = {
  value: EventAttack,
};

type msgSubstationAllocationDisconnectResponseParams = {
  value: MsgSubstationAllocationDisconnectResponse,
};

type msgAgreementCapacityDecreaseParams = {
  value: MsgAgreementCapacityDecrease,
};

type queryAllGuildBankCollateralAddressResponseParams = {
  value: QueryAllGuildBankCollateralAddressResponse,
};

type queryAllSubstationRequestParams = {
  value: QueryAllSubstationRequest,
};

type queryValidateSignatureResponseParams = {
  value: QueryValidateSignatureResponse,
};

type eventFleetParams = {
  value: EventFleet,
};

type providerParams = {
  value: Provider,
};

type queryBlockHeightParams = {
  value: QueryBlockHeight,
};

type queryGetReactorRequestParams = {
  value: QueryGetReactorRequest,
};

type gridRecordParams = {
  value: GridRecord,
};

type msgGuildUpdateJoinInfusionMinimumBypassByInviteParams = {
  value: MsgGuildUpdateJoinInfusionMinimumBypassByInvite,
};

type msgReactorInfuseResponseParams = {
  value: MsgReactorInfuseResponse,
};

type msgStructBuildCancelParams = {
  value: MsgStructBuildCancel,
};

type substationParams = {
  value: Substation,
};

type msgGuildUpdateOwnerIdParams = {
  value: MsgGuildUpdateOwnerId,
};

type msgGuildMembershipInviteDenyParams = {
  value: MsgGuildMembershipInviteDeny,
};

type msgSubstationDeleteResponseParams = {
  value: MsgSubstationDeleteResponse,
};

type fleetParams = {
  value: Fleet,
};

type queryAllPlanetAttributeRequestParams = {
  value: QueryAllPlanetAttributeRequest,
};

type queryAllReactorRequestParams = {
  value: QueryAllReactorRequest,
};

type eventProviderParams = {
  value: EventProvider,
};

type eventGuildBankRedeemDetailParams = {
  value: EventGuildBankRedeemDetail,
};

type msgPlayerResumeParams = {
  value: MsgPlayerResume,
};

type msgProviderWithdrawBalanceParams = {
  value: MsgProviderWithdrawBalance,
};

type msgProviderUpdateDurationMaximumParams = {
  value: MsgProviderUpdateDurationMaximum,
};

type queryAllInfusionRequestParams = {
  value: QueryAllInfusionRequest,
};

type queryGetProviderResponseParams = {
  value: QueryGetProviderResponse,
};

type queryAllProviderCollateralAddressResponseParams = {
  value: QueryAllProviderCollateralAddressResponse,
};

type noDataParams = {
  value: NoData,
};

type msgReactorBeginMigrationParams = {
  value: MsgReactorBeginMigration,
};

type msgReactorBeginMigrationResponseParams = {
  value: MsgReactorBeginMigrationResponse,
};

type msgSubstationPlayerDisconnectParams = {
  value: MsgSubstationPlayerDisconnect,
};

type guildMembershipApplicationParams = {
  value: GuildMembershipApplication,
};

type queryGetAllocationRequestParams = {
  value: QueryGetAllocationRequest,
};

type eventAgreementParams = {
  value: EventAgreement,
};

type msgAllocationDeleteParams = {
  value: MsgAllocationDelete,
};

type msgAgreementOpenParams = {
  value: MsgAgreementOpen,
};

type msgPlayerSendParams = {
  value: MsgPlayerSend,
};

type queryGetGuildRequestParams = {
  value: QueryGetGuildRequest,
};

type planetParams = {
  value: Planet,
};

type msgAllocationTransferResponseParams = {
  value: MsgAllocationTransferResponse,
};

type msgStructDefenseClearParams = {
  value: MsgStructDefenseClear,
};

type queryAllAgreementResponseParams = {
  value: QueryAllAgreementResponse,
};

type queryAllPermissionByObjectRequestParams = {
  value: QueryAllPermissionByObjectRequest,
};

type queryAllStructAttributeResponseParams = {
  value: QueryAllStructAttributeResponse,
};

type eventAlphaDefuseDetailParams = {
  value: EventAlphaDefuseDetail,
};

type msgGuildMembershipJoinProxyParams = {
  value: MsgGuildMembershipJoinProxy,
};

type msgStructBuildInitiateParams = {
  value: MsgStructBuildInitiate,
};

type genesisStateParams = {
  value: GenesisState,
};

type queryGetFleetResponseParams = {
  value: QueryGetFleetResponse,
};

type queryAllGuildRequestParams = {
  value: QueryAllGuildRequest,
};

type queryGetPlanetAttributeResponseParams = {
  value: QueryGetPlanetAttributeResponse,
};

type msgGuildBankMintResponseParams = {
  value: MsgGuildBankMintResponse,
};

type msgGuildBankConfiscateAndBurnParams = {
  value: MsgGuildBankConfiscateAndBurn,
};

type msgSubstationPlayerConnectParams = {
  value: MsgSubstationPlayerConnect,
};

type queryAllGuildMembershipApplicationResponseParams = {
  value: QueryAllGuildMembershipApplicationResponse,
};

type queryAllProviderRequestParams = {
  value: QueryAllProviderRequest,
};

type queryGetProviderByEarningsAddressRequestParams = {
  value: QueryGetProviderByEarningsAddressRequest,
};

type eventPlayerParams = {
  value: EventPlayer,
};

type eventProviderRevokeGuildParams = {
  value: EventProviderRevokeGuild,
};

type msgAddressRegisterResponseParams = {
  value: MsgAddressRegisterResponse,
};

type msgPermissionGrantOnObjectParams = {
  value: MsgPermissionGrantOnObject,
};

type queryGetPlayerRequestParams = {
  value: QueryGetPlayerRequest,
};

type queryAllStructTypeResponseParams = {
  value: QueryAllStructTypeResponse,
};

type msgPlanetRaidCompleteResponseParams = {
  value: MsgPlanetRaidCompleteResponse,
};

type msgReactorDefuseParams = {
  value: MsgReactorDefuse,
};

type msgStructStealthActivateParams = {
  value: MsgStructStealthActivate,
};

type queryGetGuildBankCollateralAddressRequestParams = {
  value: QueryGetGuildBankCollateralAddressRequest,
};

type queryAllGuildMembershipApplicationRequestParams = {
  value: QueryAllGuildMembershipApplicationRequest,
};

type queryAllPermissionRequestParams = {
  value: QueryAllPermissionRequest,
};

type queryAllProviderEarningsAddressResponseParams = {
  value: QueryAllProviderEarningsAddressResponse,
};

type structParams = {
  value: Struct,
};

type eventProviderAddressParams = {
  value: EventProviderAddress,
};

type msgSubstationAllocationDisconnectParams = {
  value: MsgSubstationAllocationDisconnect,
};

type queryGetAddressRequestParams = {
  value: QueryGetAddressRequest,
};

type eventPlayerHaltedParams = {
  value: EventPlayerHalted,
};

type msgUpdateParamsParams = {
  value: MsgUpdateParams,
};

type msgGuildBankMintParams = {
  value: MsgGuildBankMint,
};

type msgGuildUpdateJoinInfusionMinimumParams = {
  value: MsgGuildUpdateJoinInfusionMinimum,
};

type queryAllPermissionResponseParams = {
  value: QueryAllPermissionResponse,
};

type eventAllocationParams = {
  value: EventAllocation,
};

type eventTimeDetailParams = {
  value: EventTimeDetail,
};

type msgPlayerUpdatePrimaryAddressParams = {
  value: MsgPlayerUpdatePrimaryAddress,
};

type queryGetAgreementRequestParams = {
  value: QueryGetAgreementRequest,
};

type msgPermissionGrantOnAddressParams = {
  value: MsgPermissionGrantOnAddress,
};

type msgPermissionSetOnAddressParams = {
  value: MsgPermissionSetOnAddress,
};

type eventAddressActivityParams = {
  value: EventAddressActivity,
};

type eventRaidParams = {
  value: EventRaid,
};

type msgAllocationUpdateResponseParams = {
  value: MsgAllocationUpdateResponse,
};

type msgStructAttackResponseParams = {
  value: MsgStructAttackResponse,
};

type msgSubstationCreateParams = {
  value: MsgSubstationCreate,
};

type queryAllPlanetAttributeResponseParams = {
  value: QueryAllPlanetAttributeResponse,
};

type queryAllProviderEarningsAddressRequestParams = {
  value: QueryAllProviderEarningsAddressRequest,
};

type queryAllPlayerRequestParams = {
  value: QueryAllPlayerRequest,
};

type queryGetStructAttributeRequestParams = {
  value: QueryGetStructAttributeRequest,
};

type eventGuildBankAddressParams = {
  value: EventGuildBankAddress,
};

type msgAllocationCreateResponseParams = {
  value: MsgAllocationCreateResponse,
};

type allocationParams = {
  value: Allocation,
};

type queryAllPermissionByPlayerRequestParams = {
  value: QueryAllPermissionByPlayerRequest,
};

type queryAllProviderCollateralAddressRequestParams = {
  value: QueryAllProviderCollateralAddressRequest,
};

type queryGetProviderEarningsAddressRequestParams = {
  value: QueryGetProviderEarningsAddressRequest,
};

type msgAllocationTransferParams = {
  value: MsgAllocationTransfer,
};

type msgGuildBankConfiscateAndBurnResponseParams = {
  value: MsgGuildBankConfiscateAndBurnResponse,
};

type msgGuildMembershipKickParams = {
  value: MsgGuildMembershipKick,
};

type queryAllGridResponseParams = {
  value: QueryAllGridResponse,
};

type fleetAttributeRecordParams = {
  value: FleetAttributeRecord,
};

type msgSubstationPlayerMigrateParams = {
  value: MsgSubstationPlayerMigrate,
};

type msgProviderUpdateCapacityMaximumParams = {
  value: MsgProviderUpdateCapacityMaximum,
};

type eventDeleteParams = {
  value: EventDelete,
};

type eventGuildBankMintParams = {
  value: EventGuildBankMint,
};

type queryGetGridRequestParams = {
  value: QueryGetGridRequest,
};

type queryGetGuildResponseParams = {
  value: QueryGetGuildResponse,
};

type queryGetProviderCollateralAddressRequestParams = {
  value: QueryGetProviderCollateralAddressRequest,
};

type queryGetStructRequestParams = {
  value: QueryGetStructRequest,
};

type queryGetStructAttributeResponseParams = {
  value: QueryGetStructAttributeResponse,
};

type queryAllStructTypeRequestParams = {
  value: QueryAllStructTypeRequest,
};

type eventAlphaRefineParams = {
  value: EventAlphaRefine,
};

type queryAllInfusionByDestinationRequestParams = {
  value: QueryAllInfusionByDestinationRequest,
};

type queryGetPermissionRequestParams = {
  value: QueryGetPermissionRequest,
};

type queryGetStructResponseParams = {
  value: QueryGetStructResponse,
};

type queryGetSubstationRequestParams = {
  value: QueryGetSubstationRequest,
};

type eventRaidDetailParams = {
  value: EventRaidDetail,
};

type msgGuildMembershipInviteParams = {
  value: MsgGuildMembershipInvite,
};

type msgGuildMembershipInviteApproveParams = {
  value: MsgGuildMembershipInviteApprove,
};

type queryGetAllocationResponseParams = {
  value: QueryGetAllocationResponse,
};

type queryAllGridRequestParams = {
  value: QueryAllGridRequest,
};

type queryAllStructRequestParams = {
  value: QueryAllStructRequest,
};

type structAttributeRecordParams = {
  value: StructAttributeRecord,
};

type eventPlanetAttributeParams = {
  value: EventPlanetAttribute,
};

type eventOreMineParams = {
  value: EventOreMine,
};

type eventAttackShotDetailParams = {
  value: EventAttackShotDetail,
};

type msgStructStealthDeactivateParams = {
  value: MsgStructStealthDeactivate,
};

type structAttributesParams = {
  value: StructAttributes,
};

type eventStructParams = {
  value: EventStruct,
};

type msgGuildUpdateResponseParams = {
  value: MsgGuildUpdateResponse,
};

type msgProviderGuildRevokeParams = {
  value: MsgProviderGuildRevoke,
};

type msgProviderDeleteParams = {
  value: MsgProviderDelete,
};

type agreementParams = {
  value: Agreement,
};

type eventGuildBankConfiscateAndBurnDetailParams = {
  value: EventGuildBankConfiscateAndBurnDetail,
};

type eventGuildMembershipApplicationParams = {
  value: EventGuildMembershipApplication,
};

type msgGuildMembershipJoinParams = {
  value: MsgGuildMembershipJoin,
};

type msgPlanetExploreParams = {
  value: MsgPlanetExplore,
};

type msgStructStorageStashParams = {
  value: MsgStructStorageStash,
};

type msgSubstationAllocationConnectResponseParams = {
  value: MsgSubstationAllocationConnectResponse,
};

type msgPermissionRevokeOnObjectParams = {
  value: MsgPermissionRevokeOnObject,
};

type msgReactorCancelDefusionParams = {
  value: MsgReactorCancelDefusion,
};

type msgSubstationAllocationConnectParams = {
  value: MsgSubstationAllocationConnect,
};

type queryGetPlanetRequestParams = {
  value: QueryGetPlanetRequest,
};

type structTypeParams = {
  value: StructType,
};

type msgGuildMembershipResponseParams = {
  value: MsgGuildMembershipResponse,
};

type msgReactorInfuseParams = {
  value: MsgReactorInfuse,
};

type msgStructBuildCompleteAndStashParams = {
  value: MsgStructBuildCompleteAndStash,
};

type addressAssociationParams = {
  value: AddressAssociation,
};

type eventAddressAssociationParams = {
  value: EventAddressAssociation,
};

type msgReactorCancelDefusionResponseParams = {
  value: MsgReactorCancelDefusionResponse,
};

type addressRecordParams = {
  value: AddressRecord,
};

type structDefendersParams = {
  value: StructDefenders,
};

type eventPlanetParams = {
  value: EventPlanet,
};

type msgGuildUpdateEntrySubstationIdParams = {
  value: MsgGuildUpdateEntrySubstationId,
};

type addressActivityParams = {
  value: AddressActivity,
};

type eventAlphaInfuseParams = {
  value: EventAlphaInfuse,
};

type msgUpdateParamsResponseParams = {
  value: MsgUpdateParamsResponse,
};

type msgStructOreRefineryCompleteParams = {
  value: MsgStructOreRefineryComplete,
};

type queryAllPlayerHaltedRequestParams = {
  value: QueryAllPlayerHaltedRequest,
};

type eventAlphaDefuseParams = {
  value: EventAlphaDefuse,
};

type queryAllAddressResponseParams = {
  value: QueryAllAddressResponse,
};

type queryGetPermissionResponseParams = {
  value: QueryGetPermissionResponse,
};

type queryGetPlanetAttributeRequestParams = {
  value: QueryGetPlanetAttributeRequest,
};

type eventPermissionParams = {
  value: EventPermission,
};

type eventOreTheftDetailParams = {
  value: EventOreTheftDetail,
};

type queryGetPlanetResponseParams = {
  value: QueryGetPlanetResponse,
};

type infusionParams = {
  value: Infusion,
};

type msgGuildCreateParams = {
  value: MsgGuildCreate,
};

type msgGuildMembershipRequestParams = {
  value: MsgGuildMembershipRequest,
};

type msgPlayerUpdatePrimaryAddressResponseParams = {
  value: MsgPlayerUpdatePrimaryAddressResponse,
};

type msgAgreementCloseParams = {
  value: MsgAgreementClose,
};

type queryGetAgreementResponseParams = {
  value: QueryGetAgreementResponse,
};

type eventOreMigrateParams = {
  value: EventOreMigrate,
};

type msgGuildCreateResponseParams = {
  value: MsgGuildCreateResponse,
};

type msgProviderGuildGrantParams = {
  value: MsgProviderGuildGrant,
};

type queryAddressResponseParams = {
  value: QueryAddressResponse,
};

type msgGuildMembershipRequestDenyParams = {
  value: MsgGuildMembershipRequestDeny,
};

type msgStructDeactivateParams = {
  value: MsgStructDeactivate,
};

type msgProviderResponseParams = {
  value: MsgProviderResponse,
};

type queryAllPlanetResponseParams = {
  value: QueryAllPlanetResponse,
};

type queryAllProviderResponseParams = {
  value: QueryAllProviderResponse,
};

type eventAlphaInfuseDetailParams = {
  value: EventAlphaInfuseDetail,
};


export const registry = new Registry(msgTypes);

type Field = {
	name: string;
	type: unknown;
}
function getStructure(template) {
	const structure: {fields: Field[]} = { fields: [] }
	for (let [key, value] of Object.entries(template)) {
		let field = { name: key, type: typeof value }
		structure.fields.push(field)
	}
	return structure
}
const defaultFee = {
  amount: [],
  gas: "200000",
};

interface TxClientOptions {
  addr: string
	prefix: string
	signer?: OfflineSigner
}

export const txClient = ({ signer, prefix, addr }: TxClientOptions = { addr: "http://localhost:26657", prefix: "cosmos" }) => {

  return {
		
		async sendMsgFleetMoveResponse({ value, fee, memo }: sendMsgFleetMoveResponseParams): Promise<DeliverTxResponse> {
			if (!signer) {
					throw new Error('TxClient:sendMsgFleetMoveResponse: Unable to sign Tx. Signer is not present.')
			}
			try {			
				const { address } = (await signer.getAccounts())[0]; 
				const signingClient = await SigningStargateClient.connectWithSigner(addr,signer,{registry});
				let msg = this.msgFleetMoveResponse({ value: MsgFleetMoveResponse.fromPartial(value) })
				return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo)
			} catch (e: any) {
				throw new Error('TxClient:sendMsgFleetMoveResponse: Could not broadcast Tx: '+ e.message)
			}
		},
		
		async sendMsgPermissionSetOnObject({ value, fee, memo }: sendMsgPermissionSetOnObjectParams): Promise<DeliverTxResponse> {
			if (!signer) {
					throw new Error('TxClient:sendMsgPermissionSetOnObject: Unable to sign Tx. Signer is not present.')
			}
			try {			
				const { address } = (await signer.getAccounts())[0]; 
				const signingClient = await SigningStargateClient.connectWithSigner(addr,signer,{registry});
				let msg = this.msgPermissionSetOnObject({ value: MsgPermissionSetOnObject.fromPartial(value) })
				return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo)
			} catch (e: any) {
				throw new Error('TxClient:sendMsgPermissionSetOnObject: Could not broadcast Tx: '+ e.message)
			}
		},
		
		async sendEventGuild({ value, fee, memo }: sendEventGuildParams): Promise<DeliverTxResponse> {
			if (!signer) {
					throw new Error('TxClient:sendEventGuild: Unable to sign Tx. Signer is not present.')
			}
			try {			
				const { address } = (await signer.getAccounts())[0]; 
				const signingClient = await SigningStargateClient.connectWithSigner(addr,signer,{registry});
				let msg = this.eventGuild({ value: EventGuild.fromPartial(value) })
				return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo)
			} catch (e: any) {
				throw new Error('TxClient:sendEventGuild: Could not broadcast Tx: '+ e.message)
			}
		},
		
		async sendEventOreTheft({ value, fee, memo }: sendEventOreTheftParams): Promise<DeliverTxResponse> {
			if (!signer) {
					throw new Error('TxClient:sendEventOreTheft: Unable to sign Tx. Signer is not present.')
			}
			try {			
				const { address } = (await signer.getAccounts())[0]; 
				const signingClient = await SigningStargateClient.connectWithSigner(addr,signer,{registry});
				let msg = this.eventOreTheft({ value: EventOreTheft.fromPartial(value) })
				return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo)
			} catch (e: any) {
				throw new Error('TxClient:sendEventOreTheft: Could not broadcast Tx: '+ e.message)
			}
		},
		
		async sendMsgStructMove({ value, fee, memo }: sendMsgStructMoveParams): Promise<DeliverTxResponse> {
			if (!signer) {
					throw new Error('TxClient:sendMsgStructMove: Unable to sign Tx. Signer is not present.')
			}
			try {			
				const { address } = (await signer.getAccounts())[0]; 
				const signingClient = await SigningStargateClient.connectWithSigner(addr,signer,{registry});
				let msg = this.msgStructMove({ value: MsgStructMove.fromPartial(value) })
				return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo)
			} catch (e: any) {
				throw new Error('TxClient:sendMsgStructMove: Could not broadcast Tx: '+ e.message)
			}
		},
		
		async sendMsgStructOreMinerComplete({ value, fee, memo }: sendMsgStructOreMinerCompleteParams): Promise<DeliverTxResponse> {
			if (!signer) {
					throw new Error('TxClient:sendMsgStructOreMinerComplete: Unable to sign Tx. Signer is not present.')
			}
			try {			
				const { address } = (await signer.getAccounts())[0]; 
				const signingClient = await SigningStargateClient.connectWithSigner(addr,signer,{registry});
				let msg = this.msgStructOreMinerComplete({ value: MsgStructOreMinerComplete.fromPartial(value) })
				return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo)
			} catch (e: any) {
				throw new Error('TxClient:sendMsgStructOreMinerComplete: Could not broadcast Tx: '+ e.message)
			}
		},
		
		async sendQueryAllAddressByPlayerRequest({ value, fee, memo }: sendQueryAllAddressByPlayerRequestParams): Promise<DeliverTxResponse> {
			if (!signer) {
					throw new Error('TxClient:sendQueryAllAddressByPlayerRequest: Unable to sign Tx. Signer is not present.')
			}
			try {			
				const { address } = (await signer.getAccounts())[0]; 
				const signingClient = await SigningStargateClient.connectWithSigner(addr,signer,{registry});
				let msg = this.queryAllAddressByPlayerRequest({ value: QueryAllAddressByPlayerRequest.fromPartial(value) })
				return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo)
			} catch (e: any) {
				throw new Error('TxClient:sendQueryAllAddressByPlayerRequest: Could not broadcast Tx: '+ e.message)
			}
		},
		
		async sendEventOreMigrateDetail({ value, fee, memo }: sendEventOreMigrateDetailParams): Promise<DeliverTxResponse> {
			if (!signer) {
					throw new Error('TxClient:sendEventOreMigrateDetail: Unable to sign Tx. Signer is not present.')
			}
			try {			
				const { address } = (await signer.getAccounts())[0]; 
				const signingClient = await SigningStargateClient.connectWithSigner(addr,signer,{registry});
				let msg = this.eventOreMigrateDetail({ value: EventOreMigrateDetail.fromPartial(value) })
				return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo)
			} catch (e: any) {
				throw new Error('TxClient:sendEventOreMigrateDetail: Could not broadcast Tx: '+ e.message)
			}
		},
		
		async sendMsgGuildBankRedeemResponse({ value, fee, memo }: sendMsgGuildBankRedeemResponseParams): Promise<DeliverTxResponse> {
			if (!signer) {
					throw new Error('TxClient:sendMsgGuildBankRedeemResponse: Unable to sign Tx. Signer is not present.')
			}
			try {			
				const { address } = (await signer.getAccounts())[0]; 
				const signingClient = await SigningStargateClient.connectWithSigner(addr,signer,{registry});
				let msg = this.msgGuildBankRedeemResponse({ value: MsgGuildBankRedeemResponse.fromPartial(value) })
				return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo)
			} catch (e: any) {
				throw new Error('TxClient:sendMsgGuildBankRedeemResponse: Could not broadcast Tx: '+ e.message)
			}
		},
		
		async sendMsgStructBuildComplete({ value, fee, memo }: sendMsgStructBuildCompleteParams): Promise<DeliverTxResponse> {
			if (!signer) {
					throw new Error('TxClient:sendMsgStructBuildComplete: Unable to sign Tx. Signer is not present.')
			}
			try {			
				const { address } = (await signer.getAccounts())[0]; 
				const signingClient = await SigningStargateClient.connectWithSigner(addr,signer,{registry});
				let msg = this.msgStructBuildComplete({ value: MsgStructBuildComplete.fromPartial(value) })
				return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo)
			} catch (e: any) {
				throw new Error('TxClient:sendMsgStructBuildComplete: Could not broadcast Tx: '+ e.message)
			}
		},
		
		async sendMsgStructDefenseSet({ value, fee, memo }: sendMsgStructDefenseSetParams): Promise<DeliverTxResponse> {
			if (!signer) {
					throw new Error('TxClient:sendMsgStructDefenseSet: Unable to sign Tx. Signer is not present.')
			}
			try {			
				const { address } = (await signer.getAccounts())[0]; 
				const signingClient = await SigningStargateClient.connectWithSigner(addr,signer,{registry});
				let msg = this.msgStructDefenseSet({ value: MsgStructDefenseSet.fromPartial(value) })
				return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo)
			} catch (e: any) {
				throw new Error('TxClient:sendMsgStructDefenseSet: Could not broadcast Tx: '+ e.message)
			}
		},
		
		async sendMsgProviderUpdateAccessPolicy({ value, fee, memo }: sendMsgProviderUpdateAccessPolicyParams): Promise<DeliverTxResponse> {
			if (!signer) {
					throw new Error('TxClient:sendMsgProviderUpdateAccessPolicy: Unable to sign Tx. Signer is not present.')
			}
			try {			
				const { address } = (await signer.getAccounts())[0]; 
				const signingClient = await SigningStargateClient.connectWithSigner(addr,signer,{registry});
				let msg = this.msgProviderUpdateAccessPolicy({ value: MsgProviderUpdateAccessPolicy.fromPartial(value) })
				return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo)
			} catch (e: any) {
				throw new Error('TxClient:sendMsgProviderUpdateAccessPolicy: Could not broadcast Tx: '+ e.message)
			}
		},
		
		async sendQueryAllFleetRequest({ value, fee, memo }: sendQueryAllFleetRequestParams): Promise<DeliverTxResponse> {
			if (!signer) {
					throw new Error('TxClient:sendQueryAllFleetRequest: Unable to sign Tx. Signer is not present.')
			}
			try {			
				const { address } = (await signer.getAccounts())[0]; 
				const signingClient = await SigningStargateClient.connectWithSigner(addr,signer,{registry});
				let msg = this.queryAllFleetRequest({ value: QueryAllFleetRequest.fromPartial(value) })
				return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo)
			} catch (e: any) {
				throw new Error('TxClient:sendQueryAllFleetRequest: Could not broadcast Tx: '+ e.message)
			}
		},
		
		async sendMsgAllocationCreate({ value, fee, memo }: sendMsgAllocationCreateParams): Promise<DeliverTxResponse> {
			if (!signer) {
					throw new Error('TxClient:sendMsgAllocationCreate: Unable to sign Tx. Signer is not present.')
			}
			try {			
				const { address } = (await signer.getAccounts())[0]; 
				const signingClient = await SigningStargateClient.connectWithSigner(addr,signer,{registry});
				let msg = this.msgAllocationCreate({ value: MsgAllocationCreate.fromPartial(value) })
				return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo)
			} catch (e: any) {
				throw new Error('TxClient:sendMsgAllocationCreate: Could not broadcast Tx: '+ e.message)
			}
		},
		
		async sendMsgPermissionResponse({ value, fee, memo }: sendMsgPermissionResponseParams): Promise<DeliverTxResponse> {
			if (!signer) {
					throw new Error('TxClient:sendMsgPermissionResponse: Unable to sign Tx. Signer is not present.')
			}
			try {			
				const { address } = (await signer.getAccounts())[0]; 
				const signingClient = await SigningStargateClient.connectWithSigner(addr,signer,{registry});
				let msg = this.msgPermissionResponse({ value: MsgPermissionResponse.fromPartial(value) })
				return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo)
			} catch (e: any) {
				throw new Error('TxClient:sendMsgPermissionResponse: Could not broadcast Tx: '+ e.message)
			}
		},
		
		async sendQueryParamsRequest({ value, fee, memo }: sendQueryParamsRequestParams): Promise<DeliverTxResponse> {
			if (!signer) {
					throw new Error('TxClient:sendQueryParamsRequest: Unable to sign Tx. Signer is not present.')
			}
			try {			
				const { address } = (await signer.getAccounts())[0]; 
				const signingClient = await SigningStargateClient.connectWithSigner(addr,signer,{registry});
				let msg = this.queryParamsRequest({ value: QueryParamsRequest.fromPartial(value) })
				return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo)
			} catch (e: any) {
				throw new Error('TxClient:sendQueryParamsRequest: Could not broadcast Tx: '+ e.message)
			}
		},
		
		async sendQueryAllFleetResponse({ value, fee, memo }: sendQueryAllFleetResponseParams): Promise<DeliverTxResponse> {
			if (!signer) {
					throw new Error('TxClient:sendQueryAllFleetResponse: Unable to sign Tx. Signer is not present.')
			}
			try {			
				const { address } = (await signer.getAccounts())[0]; 
				const signingClient = await SigningStargateClient.connectWithSigner(addr,signer,{registry});
				let msg = this.queryAllFleetResponse({ value: QueryAllFleetResponse.fromPartial(value) })
				return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo)
			} catch (e: any) {
				throw new Error('TxClient:sendQueryAllFleetResponse: Could not broadcast Tx: '+ e.message)
			}
		},
		
		async sendPlayerInventory({ value, fee, memo }: sendPlayerInventoryParams): Promise<DeliverTxResponse> {
			if (!signer) {
					throw new Error('TxClient:sendPlayerInventory: Unable to sign Tx. Signer is not present.')
			}
			try {			
				const { address } = (await signer.getAccounts())[0]; 
				const signingClient = await SigningStargateClient.connectWithSigner(addr,signer,{registry});
				let msg = this.playerInventory({ value: PlayerInventory.fromPartial(value) })
				return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo)
			} catch (e: any) {
				throw new Error('TxClient:sendPlayerInventory: Could not broadcast Tx: '+ e.message)
			}
		},
		
		async sendEventProviderGrantGuildDetail({ value, fee, memo }: sendEventProviderGrantGuildDetailParams): Promise<DeliverTxResponse> {
			if (!signer) {
					throw new Error('TxClient:sendEventProviderGrantGuildDetail: Unable to sign Tx. Signer is not present.')
			}
			try {			
				const { address } = (await signer.getAccounts())[0]; 
				const signingClient = await SigningStargateClient.connectWithSigner(addr,signer,{registry});
				let msg = this.eventProviderGrantGuildDetail({ value: EventProviderGrantGuildDetail.fromPartial(value) })
				return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo)
			} catch (e: any) {
				throw new Error('TxClient:sendEventProviderGrantGuildDetail: Could not broadcast Tx: '+ e.message)
			}
		},
		
		async sendEventGuildBankMintDetail({ value, fee, memo }: sendEventGuildBankMintDetailParams): Promise<DeliverTxResponse> {
			if (!signer) {
					throw new Error('TxClient:sendEventGuildBankMintDetail: Unable to sign Tx. Signer is not present.')
			}
			try {			
				const { address } = (await signer.getAccounts())[0]; 
				const signingClient = await SigningStargateClient.connectWithSigner(addr,signer,{registry});
				let msg = this.eventGuildBankMintDetail({ value: EventGuildBankMintDetail.fromPartial(value) })
				return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo)
			} catch (e: any) {
				throw new Error('TxClient:sendEventGuildBankMintDetail: Could not broadcast Tx: '+ e.message)
			}
		},
		
		async sendMsgSubstationCreateResponse({ value, fee, memo }: sendMsgSubstationCreateResponseParams): Promise<DeliverTxResponse> {
			if (!signer) {
					throw new Error('TxClient:sendMsgSubstationCreateResponse: Unable to sign Tx. Signer is not present.')
			}
			try {			
				const { address } = (await signer.getAccounts())[0]; 
				const signingClient = await SigningStargateClient.connectWithSigner(addr,signer,{registry});
				let msg = this.msgSubstationCreateResponse({ value: MsgSubstationCreateResponse.fromPartial(value) })
				return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo)
			} catch (e: any) {
				throw new Error('TxClient:sendMsgSubstationCreateResponse: Could not broadcast Tx: '+ e.message)
			}
		},
		
		async sendMsgSubstationPlayerMigrateResponse({ value, fee, memo }: sendMsgSubstationPlayerMigrateResponseParams): Promise<DeliverTxResponse> {
			if (!signer) {
					throw new Error('TxClient:sendMsgSubstationPlayerMigrateResponse: Unable to sign Tx. Signer is not present.')
			}
			try {			
				const { address } = (await signer.getAccounts())[0]; 
				const signingClient = await SigningStargateClient.connectWithSigner(addr,signer,{registry});
				let msg = this.msgSubstationPlayerMigrateResponse({ value: MsgSubstationPlayerMigrateResponse.fromPartial(value) })
				return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo)
			} catch (e: any) {
				throw new Error('TxClient:sendMsgSubstationPlayerMigrateResponse: Could not broadcast Tx: '+ e.message)
			}
		},
		
		async sendMsgProviderUpdateCapacityMinimum({ value, fee, memo }: sendMsgProviderUpdateCapacityMinimumParams): Promise<DeliverTxResponse> {
			if (!signer) {
					throw new Error('TxClient:sendMsgProviderUpdateCapacityMinimum: Unable to sign Tx. Signer is not present.')
			}
			try {			
				const { address } = (await signer.getAccounts())[0]; 
				const signingClient = await SigningStargateClient.connectWithSigner(addr,signer,{registry});
				let msg = this.msgProviderUpdateCapacityMinimum({ value: MsgProviderUpdateCapacityMinimum.fromPartial(value) })
				return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo)
			} catch (e: any) {
				throw new Error('TxClient:sendMsgProviderUpdateCapacityMinimum: Could not broadcast Tx: '+ e.message)
			}
		},
		
		async sendQueryGetGuildMembershipApplicationResponse({ value, fee, memo }: sendQueryGetGuildMembershipApplicationResponseParams): Promise<DeliverTxResponse> {
			if (!signer) {
					throw new Error('TxClient:sendQueryGetGuildMembershipApplicationResponse: Unable to sign Tx. Signer is not present.')
			}
			try {			
				const { address } = (await signer.getAccounts())[0]; 
				const signingClient = await SigningStargateClient.connectWithSigner(addr,signer,{registry});
				let msg = this.queryGetGuildMembershipApplicationResponse({ value: QueryGetGuildMembershipApplicationResponse.fromPartial(value) })
				return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo)
			} catch (e: any) {
				throw new Error('TxClient:sendQueryGetGuildMembershipApplicationResponse: Could not broadcast Tx: '+ e.message)
			}
		},
		
		async sendQueryGetPlayerResponse({ value, fee, memo }: sendQueryGetPlayerResponseParams): Promise<DeliverTxResponse> {
			if (!signer) {
					throw new Error('TxClient:sendQueryGetPlayerResponse: Unable to sign Tx. Signer is not present.')
			}
			try {			
				const { address } = (await signer.getAccounts())[0]; 
				const signingClient = await SigningStargateClient.connectWithSigner(addr,signer,{registry});
				let msg = this.queryGetPlayerResponse({ value: QueryGetPlayerResponse.fromPartial(value) })
				return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo)
			} catch (e: any) {
				throw new Error('TxClient:sendQueryGetPlayerResponse: Could not broadcast Tx: '+ e.message)
			}
		},
		
		async sendQueryGetSubstationResponse({ value, fee, memo }: sendQueryGetSubstationResponseParams): Promise<DeliverTxResponse> {
			if (!signer) {
					throw new Error('TxClient:sendQueryGetSubstationResponse: Unable to sign Tx. Signer is not present.')
			}
			try {			
				const { address } = (await signer.getAccounts())[0]; 
				const signingClient = await SigningStargateClient.connectWithSigner(addr,signer,{registry});
				let msg = this.queryGetSubstationResponse({ value: QueryGetSubstationResponse.fromPartial(value) })
				return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo)
			} catch (e: any) {
				throw new Error('TxClient:sendQueryGetSubstationResponse: Could not broadcast Tx: '+ e.message)
			}
		},
		
		async sendStructDefender({ value, fee, memo }: sendStructDefenderParams): Promise<DeliverTxResponse> {
			if (!signer) {
					throw new Error('TxClient:sendStructDefender: Unable to sign Tx. Signer is not present.')
			}
			try {			
				const { address } = (await signer.getAccounts())[0]; 
				const signingClient = await SigningStargateClient.connectWithSigner(addr,signer,{registry});
				let msg = this.structDefender({ value: StructDefender.fromPartial(value) })
				return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo)
			} catch (e: any) {
				throw new Error('TxClient:sendStructDefender: Could not broadcast Tx: '+ e.message)
			}
		},
		
		async sendMsgReactorDefuseResponse({ value, fee, memo }: sendMsgReactorDefuseResponseParams): Promise<DeliverTxResponse> {
			if (!signer) {
					throw new Error('TxClient:sendMsgReactorDefuseResponse: Unable to sign Tx. Signer is not present.')
			}
			try {			
				const { address } = (await signer.getAccounts())[0]; 
				const signingClient = await SigningStargateClient.connectWithSigner(addr,signer,{registry});
				let msg = this.msgReactorDefuseResponse({ value: MsgReactorDefuseResponse.fromPartial(value) })
				return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo)
			} catch (e: any) {
				throw new Error('TxClient:sendMsgReactorDefuseResponse: Could not broadcast Tx: '+ e.message)
			}
		},
		
		async sendMsgStructAttack({ value, fee, memo }: sendMsgStructAttackParams): Promise<DeliverTxResponse> {
			if (!signer) {
					throw new Error('TxClient:sendMsgStructAttack: Unable to sign Tx. Signer is not present.')
			}
			try {			
				const { address } = (await signer.getAccounts())[0]; 
				const signingClient = await SigningStargateClient.connectWithSigner(addr,signer,{registry});
				let msg = this.msgStructAttack({ value: MsgStructAttack.fromPartial(value) })
				return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo)
			} catch (e: any) {
				throw new Error('TxClient:sendMsgStructAttack: Could not broadcast Tx: '+ e.message)
			}
		},
		
		async sendEventTime({ value, fee, memo }: sendEventTimeParams): Promise<DeliverTxResponse> {
			if (!signer) {
					throw new Error('TxClient:sendEventTime: Unable to sign Tx. Signer is not present.')
			}
			try {			
				const { address } = (await signer.getAccounts())[0]; 
				const signingClient = await SigningStargateClient.connectWithSigner(addr,signer,{registry});
				let msg = this.eventTime({ value: EventTime.fromPartial(value) })
				return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo)
			} catch (e: any) {
				throw new Error('TxClient:sendEventTime: Could not broadcast Tx: '+ e.message)
			}
		},
		
		async sendMsgSubstationDelete({ value, fee, memo }: sendMsgSubstationDeleteParams): Promise<DeliverTxResponse> {
			if (!signer) {
					throw new Error('TxClient:sendMsgSubstationDelete: Unable to sign Tx. Signer is not present.')
			}
			try {			
				const { address } = (await signer.getAccounts())[0]; 
				const signingClient = await SigningStargateClient.connectWithSigner(addr,signer,{registry});
				let msg = this.msgSubstationDelete({ value: MsgSubstationDelete.fromPartial(value) })
				return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo)
			} catch (e: any) {
				throw new Error('TxClient:sendMsgSubstationDelete: Could not broadcast Tx: '+ e.message)
			}
		},
		
		async sendGuild({ value, fee, memo }: sendGuildParams): Promise<DeliverTxResponse> {
			if (!signer) {
					throw new Error('TxClient:sendGuild: Unable to sign Tx. Signer is not present.')
			}
			try {			
				const { address } = (await signer.getAccounts())[0]; 
				const signingClient = await SigningStargateClient.connectWithSigner(addr,signer,{registry});
				let msg = this.guild({ value: Guild.fromPartial(value) })
				return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo)
			} catch (e: any) {
				throw new Error('TxClient:sendGuild: Could not broadcast Tx: '+ e.message)
			}
		},
		
		async sendQueryGetProviderRequest({ value, fee, memo }: sendQueryGetProviderRequestParams): Promise<DeliverTxResponse> {
			if (!signer) {
					throw new Error('TxClient:sendQueryGetProviderRequest: Unable to sign Tx. Signer is not present.')
			}
			try {			
				const { address } = (await signer.getAccounts())[0]; 
				const signingClient = await SigningStargateClient.connectWithSigner(addr,signer,{registry});
				let msg = this.queryGetProviderRequest({ value: QueryGetProviderRequest.fromPartial(value) })
				return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo)
			} catch (e: any) {
				throw new Error('TxClient:sendQueryGetProviderRequest: Could not broadcast Tx: '+ e.message)
			}
		},
		
		async sendMsgAllocationUpdate({ value, fee, memo }: sendMsgAllocationUpdateParams): Promise<DeliverTxResponse> {
			if (!signer) {
					throw new Error('TxClient:sendMsgAllocationUpdate: Unable to sign Tx. Signer is not present.')
			}
			try {			
				const { address } = (await signer.getAccounts())[0]; 
				const signingClient = await SigningStargateClient.connectWithSigner(addr,signer,{registry});
				let msg = this.msgAllocationUpdate({ value: MsgAllocationUpdate.fromPartial(value) })
				return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo)
			} catch (e: any) {
				throw new Error('TxClient:sendMsgAllocationUpdate: Could not broadcast Tx: '+ e.message)
			}
		},
		
		async sendMsgSubstationPlayerDisconnectResponse({ value, fee, memo }: sendMsgSubstationPlayerDisconnectResponseParams): Promise<DeliverTxResponse> {
			if (!signer) {
					throw new Error('TxClient:sendMsgSubstationPlayerDisconnectResponse: Unable to sign Tx. Signer is not present.')
			}
			try {			
				const { address } = (await signer.getAccounts())[0]; 
				const signingClient = await SigningStargateClient.connectWithSigner(addr,signer,{registry});
				let msg = this.msgSubstationPlayerDisconnectResponse({ value: MsgSubstationPlayerDisconnectResponse.fromPartial(value) })
				return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo)
			} catch (e: any) {
				throw new Error('TxClient:sendMsgSubstationPlayerDisconnectResponse: Could not broadcast Tx: '+ e.message)
			}
		},
		
		async sendEventAlphaRefineDetail({ value, fee, memo }: sendEventAlphaRefineDetailParams): Promise<DeliverTxResponse> {
			if (!signer) {
					throw new Error('TxClient:sendEventAlphaRefineDetail: Unable to sign Tx. Signer is not present.')
			}
			try {			
				const { address } = (await signer.getAccounts())[0]; 
				const signingClient = await SigningStargateClient.connectWithSigner(addr,signer,{registry});
				let msg = this.eventAlphaRefineDetail({ value: EventAlphaRefineDetail.fromPartial(value) })
				return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo)
			} catch (e: any) {
				throw new Error('TxClient:sendEventAlphaRefineDetail: Could not broadcast Tx: '+ e.message)
			}
		},
		
		async sendMsgAllocationDeleteResponse({ value, fee, memo }: sendMsgAllocationDeleteResponseParams): Promise<DeliverTxResponse> {
			if (!signer) {
					throw new Error('TxClient:sendMsgAllocationDeleteResponse: Unable to sign Tx. Signer is not present.')
			}
			try {			
				const { address } = (await signer.getAccounts())[0]; 
				const signingClient = await SigningStargateClient.connectWithSigner(addr,signer,{registry});
				let msg = this.msgAllocationDeleteResponse({ value: MsgAllocationDeleteResponse.fromPartial(value) })
				return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo)
			} catch (e: any) {
				throw new Error('TxClient:sendMsgAllocationDeleteResponse: Could not broadcast Tx: '+ e.message)
			}
		},
		
		async sendMsgGuildMembershipInviteRevoke({ value, fee, memo }: sendMsgGuildMembershipInviteRevokeParams): Promise<DeliverTxResponse> {
			if (!signer) {
					throw new Error('TxClient:sendMsgGuildMembershipInviteRevoke: Unable to sign Tx. Signer is not present.')
			}
			try {			
				const { address } = (await signer.getAccounts())[0]; 
				const signingClient = await SigningStargateClient.connectWithSigner(addr,signer,{registry});
				let msg = this.msgGuildMembershipInviteRevoke({ value: MsgGuildMembershipInviteRevoke.fromPartial(value) })
				return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo)
			} catch (e: any) {
				throw new Error('TxClient:sendMsgGuildMembershipInviteRevoke: Could not broadcast Tx: '+ e.message)
			}
		},
		
		async sendMsgProviderUpdateDurationMinimum({ value, fee, memo }: sendMsgProviderUpdateDurationMinimumParams): Promise<DeliverTxResponse> {
			if (!signer) {
					throw new Error('TxClient:sendMsgProviderUpdateDurationMinimum: Unable to sign Tx. Signer is not present.')
			}
			try {			
				const { address } = (await signer.getAccounts())[0]; 
				const signingClient = await SigningStargateClient.connectWithSigner(addr,signer,{registry});
				let msg = this.msgProviderUpdateDurationMinimum({ value: MsgProviderUpdateDurationMinimum.fromPartial(value) })
				return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo)
			} catch (e: any) {
				throw new Error('TxClient:sendMsgProviderUpdateDurationMinimum: Could not broadcast Tx: '+ e.message)
			}
		},
		
		async sendInternalAddressAssociation({ value, fee, memo }: sendInternalAddressAssociationParams): Promise<DeliverTxResponse> {
			if (!signer) {
					throw new Error('TxClient:sendInternalAddressAssociation: Unable to sign Tx. Signer is not present.')
			}
			try {			
				const { address } = (await signer.getAccounts())[0]; 
				const signingClient = await SigningStargateClient.connectWithSigner(addr,signer,{registry});
				let msg = this.internalAddressAssociation({ value: InternalAddressAssociation.fromPartial(value) })
				return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo)
			} catch (e: any) {
				throw new Error('TxClient:sendInternalAddressAssociation: Could not broadcast Tx: '+ e.message)
			}
		},
		
		async sendParams({ value, fee, memo }: sendParamsParams): Promise<DeliverTxResponse> {
			if (!signer) {
					throw new Error('TxClient:sendParams: Unable to sign Tx. Signer is not present.')
			}
			try {			
				const { address } = (await signer.getAccounts())[0]; 
				const signingClient = await SigningStargateClient.connectWithSigner(addr,signer,{registry});
				let msg = this.params({ value: Params.fromPartial(value) })
				return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo)
			} catch (e: any) {
				throw new Error('TxClient:sendParams: Could not broadcast Tx: '+ e.message)
			}
		},
		
		async sendPermissionRecord({ value, fee, memo }: sendPermissionRecordParams): Promise<DeliverTxResponse> {
			if (!signer) {
					throw new Error('TxClient:sendPermissionRecord: Unable to sign Tx. Signer is not present.')
			}
			try {			
				const { address } = (await signer.getAccounts())[0]; 
				const signingClient = await SigningStargateClient.connectWithSigner(addr,signer,{registry});
				let msg = this.permissionRecord({ value: PermissionRecord.fromPartial(value) })
				return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo)
			} catch (e: any) {
				throw new Error('TxClient:sendPermissionRecord: Could not broadcast Tx: '+ e.message)
			}
		},
		
		async sendEventReactor({ value, fee, memo }: sendEventReactorParams): Promise<DeliverTxResponse> {
			if (!signer) {
					throw new Error('TxClient:sendEventReactor: Unable to sign Tx. Signer is not present.')
			}
			try {			
				const { address } = (await signer.getAccounts())[0]; 
				const signingClient = await SigningStargateClient.connectWithSigner(addr,signer,{registry});
				let msg = this.eventReactor({ value: EventReactor.fromPartial(value) })
				return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo)
			} catch (e: any) {
				throw new Error('TxClient:sendEventReactor: Could not broadcast Tx: '+ e.message)
			}
		},
		
		async sendEventStructAttribute({ value, fee, memo }: sendEventStructAttributeParams): Promise<DeliverTxResponse> {
			if (!signer) {
					throw new Error('TxClient:sendEventStructAttribute: Unable to sign Tx. Signer is not present.')
			}
			try {			
				const { address } = (await signer.getAccounts())[0]; 
				const signingClient = await SigningStargateClient.connectWithSigner(addr,signer,{registry});
				let msg = this.eventStructAttribute({ value: EventStructAttribute.fromPartial(value) })
				return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo)
			} catch (e: any) {
				throw new Error('TxClient:sendEventStructAttribute: Could not broadcast Tx: '+ e.message)
			}
		},
		
		async sendMsgAddressRevoke({ value, fee, memo }: sendMsgAddressRevokeParams): Promise<DeliverTxResponse> {
			if (!signer) {
					throw new Error('TxClient:sendMsgAddressRevoke: Unable to sign Tx. Signer is not present.')
			}
			try {			
				const { address } = (await signer.getAccounts())[0]; 
				const signingClient = await SigningStargateClient.connectWithSigner(addr,signer,{registry});
				let msg = this.msgAddressRevoke({ value: MsgAddressRevoke.fromPartial(value) })
				return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo)
			} catch (e: any) {
				throw new Error('TxClient:sendMsgAddressRevoke: Could not broadcast Tx: '+ e.message)
			}
		},
		
		async sendMsgSubstationPlayerConnectResponse({ value, fee, memo }: sendMsgSubstationPlayerConnectResponseParams): Promise<DeliverTxResponse> {
			if (!signer) {
					throw new Error('TxClient:sendMsgSubstationPlayerConnectResponse: Unable to sign Tx. Signer is not present.')
			}
			try {			
				const { address } = (await signer.getAccounts())[0]; 
				const signingClient = await SigningStargateClient.connectWithSigner(addr,signer,{registry});
				let msg = this.msgSubstationPlayerConnectResponse({ value: MsgSubstationPlayerConnectResponse.fromPartial(value) })
				return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo)
			} catch (e: any) {
				throw new Error('TxClient:sendMsgSubstationPlayerConnectResponse: Could not broadcast Tx: '+ e.message)
			}
		},
		
		async sendQueryGetFleetRequest({ value, fee, memo }: sendQueryGetFleetRequestParams): Promise<DeliverTxResponse> {
			if (!signer) {
					throw new Error('TxClient:sendQueryGetFleetRequest: Unable to sign Tx. Signer is not present.')
			}
			try {			
				const { address } = (await signer.getAccounts())[0]; 
				const signingClient = await SigningStargateClient.connectWithSigner(addr,signer,{registry});
				let msg = this.queryGetFleetRequest({ value: QueryGetFleetRequest.fromPartial(value) })
				return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo)
			} catch (e: any) {
				throw new Error('TxClient:sendQueryGetFleetRequest: Could not broadcast Tx: '+ e.message)
			}
		},
		
		async sendQueryGetInfusionResponse({ value, fee, memo }: sendQueryGetInfusionResponseParams): Promise<DeliverTxResponse> {
			if (!signer) {
					throw new Error('TxClient:sendQueryGetInfusionResponse: Unable to sign Tx. Signer is not present.')
			}
			try {			
				const { address } = (await signer.getAccounts())[0]; 
				const signingClient = await SigningStargateClient.connectWithSigner(addr,signer,{registry});
				let msg = this.queryGetInfusionResponse({ value: QueryGetInfusionResponse.fromPartial(value) })
				return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo)
			} catch (e: any) {
				throw new Error('TxClient:sendQueryGetInfusionResponse: Could not broadcast Tx: '+ e.message)
			}
		},
		
		async sendQueryGetStructTypeRequest({ value, fee, memo }: sendQueryGetStructTypeRequestParams): Promise<DeliverTxResponse> {
			if (!signer) {
					throw new Error('TxClient:sendQueryGetStructTypeRequest: Unable to sign Tx. Signer is not present.')
			}
			try {			
				const { address } = (await signer.getAccounts())[0]; 
				const signingClient = await SigningStargateClient.connectWithSigner(addr,signer,{registry});
				let msg = this.queryGetStructTypeRequest({ value: QueryGetStructTypeRequest.fromPartial(value) })
				return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo)
			} catch (e: any) {
				throw new Error('TxClient:sendQueryGetStructTypeRequest: Could not broadcast Tx: '+ e.message)
			}
		},
		
		async sendEventAttackDefenderCounterDetail({ value, fee, memo }: sendEventAttackDefenderCounterDetailParams): Promise<DeliverTxResponse> {
			if (!signer) {
					throw new Error('TxClient:sendEventAttackDefenderCounterDetail: Unable to sign Tx. Signer is not present.')
			}
			try {			
				const { address } = (await signer.getAccounts())[0]; 
				const signingClient = await SigningStargateClient.connectWithSigner(addr,signer,{registry});
				let msg = this.eventAttackDefenderCounterDetail({ value: EventAttackDefenderCounterDetail.fromPartial(value) })
				return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo)
			} catch (e: any) {
				throw new Error('TxClient:sendEventAttackDefenderCounterDetail: Could not broadcast Tx: '+ e.message)
			}
		},
		
		async sendMsgStructGeneratorInfuse({ value, fee, memo }: sendMsgStructGeneratorInfuseParams): Promise<DeliverTxResponse> {
			if (!signer) {
					throw new Error('TxClient:sendMsgStructGeneratorInfuse: Unable to sign Tx. Signer is not present.')
			}
			try {			
				const { address } = (await signer.getAccounts())[0]; 
				const signingClient = await SigningStargateClient.connectWithSigner(addr,signer,{registry});
				let msg = this.msgStructGeneratorInfuse({ value: MsgStructGeneratorInfuse.fromPartial(value) })
				return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo)
			} catch (e: any) {
				throw new Error('TxClient:sendMsgStructGeneratorInfuse: Could not broadcast Tx: '+ e.message)
			}
		},
		
		async sendQueryAllPlayerHaltedResponse({ value, fee, memo }: sendQueryAllPlayerHaltedResponseParams): Promise<DeliverTxResponse> {
			if (!signer) {
					throw new Error('TxClient:sendQueryAllPlayerHaltedResponse: Unable to sign Tx. Signer is not present.')
			}
			try {			
				const { address } = (await signer.getAccounts())[0]; 
				const signingClient = await SigningStargateClient.connectWithSigner(addr,signer,{registry});
				let msg = this.queryAllPlayerHaltedResponse({ value: QueryAllPlayerHaltedResponse.fromPartial(value) })
				return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo)
			} catch (e: any) {
				throw new Error('TxClient:sendQueryAllPlayerHaltedResponse: Could not broadcast Tx: '+ e.message)
			}
		},
		
		async sendEventProviderRevokeGuildDetail({ value, fee, memo }: sendEventProviderRevokeGuildDetailParams): Promise<DeliverTxResponse> {
			if (!signer) {
					throw new Error('TxClient:sendEventProviderRevokeGuildDetail: Unable to sign Tx. Signer is not present.')
			}
			try {			
				const { address } = (await signer.getAccounts())[0]; 
				const signingClient = await SigningStargateClient.connectWithSigner(addr,signer,{registry});
				let msg = this.eventProviderRevokeGuildDetail({ value: EventProviderRevokeGuildDetail.fromPartial(value) })
				return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo)
			} catch (e: any) {
				throw new Error('TxClient:sendEventProviderRevokeGuildDetail: Could not broadcast Tx: '+ e.message)
			}
		},
		
		async sendPlanetAttributeRecord({ value, fee, memo }: sendPlanetAttributeRecordParams): Promise<DeliverTxResponse> {
			if (!signer) {
					throw new Error('TxClient:sendPlanetAttributeRecord: Unable to sign Tx. Signer is not present.')
			}
			try {			
				const { address } = (await signer.getAccounts())[0]; 
				const signingClient = await SigningStargateClient.connectWithSigner(addr,signer,{registry});
				let msg = this.planetAttributeRecord({ value: PlanetAttributeRecord.fromPartial(value) })
				return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo)
			} catch (e: any) {
				throw new Error('TxClient:sendPlanetAttributeRecord: Could not broadcast Tx: '+ e.message)
			}
		},
		
		async sendMsgPlanetExploreResponse({ value, fee, memo }: sendMsgPlanetExploreResponseParams): Promise<DeliverTxResponse> {
			if (!signer) {
					throw new Error('TxClient:sendMsgPlanetExploreResponse: Unable to sign Tx. Signer is not present.')
			}
			try {			
				const { address } = (await signer.getAccounts())[0]; 
				const signingClient = await SigningStargateClient.connectWithSigner(addr,signer,{registry});
				let msg = this.msgPlanetExploreResponse({ value: MsgPlanetExploreResponse.fromPartial(value) })
				return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo)
			} catch (e: any) {
				throw new Error('TxClient:sendMsgPlanetExploreResponse: Could not broadcast Tx: '+ e.message)
			}
		},
		
		async sendQueryGetStructTypeResponse({ value, fee, memo }: sendQueryGetStructTypeResponseParams): Promise<DeliverTxResponse> {
			if (!signer) {
					throw new Error('TxClient:sendQueryGetStructTypeResponse: Unable to sign Tx. Signer is not present.')
			}
			try {			
				const { address } = (await signer.getAccounts())[0]; 
				const signingClient = await SigningStargateClient.connectWithSigner(addr,signer,{registry});
				let msg = this.queryGetStructTypeResponse({ value: QueryGetStructTypeResponse.fromPartial(value) })
				return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo)
			} catch (e: any) {
				throw new Error('TxClient:sendQueryGetStructTypeResponse: Could not broadcast Tx: '+ e.message)
			}
		},
		
		async sendEventInfusion({ value, fee, memo }: sendEventInfusionParams): Promise<DeliverTxResponse> {
			if (!signer) {
					throw new Error('TxClient:sendEventInfusion: Unable to sign Tx. Signer is not present.')
			}
			try {			
				const { address } = (await signer.getAccounts())[0]; 
				const signingClient = await SigningStargateClient.connectWithSigner(addr,signer,{registry});
				let msg = this.eventInfusion({ value: EventInfusion.fromPartial(value) })
				return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo)
			} catch (e: any) {
				throw new Error('TxClient:sendEventInfusion: Could not broadcast Tx: '+ e.message)
			}
		},
		
		async sendPlanetAttributes({ value, fee, memo }: sendPlanetAttributesParams): Promise<DeliverTxResponse> {
			if (!signer) {
					throw new Error('TxClient:sendPlanetAttributes: Unable to sign Tx. Signer is not present.')
			}
			try {			
				const { address } = (await signer.getAccounts())[0]; 
				const signingClient = await SigningStargateClient.connectWithSigner(addr,signer,{registry});
				let msg = this.planetAttributes({ value: PlanetAttributes.fromPartial(value) })
				return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo)
			} catch (e: any) {
				throw new Error('TxClient:sendPlanetAttributes: Could not broadcast Tx: '+ e.message)
			}
		},
		
		async sendMsgStructOreRefineryStatusResponse({ value, fee, memo }: sendMsgStructOreRefineryStatusResponseParams): Promise<DeliverTxResponse> {
			if (!signer) {
					throw new Error('TxClient:sendMsgStructOreRefineryStatusResponse: Unable to sign Tx. Signer is not present.')
			}
			try {			
				const { address } = (await signer.getAccounts())[0]; 
				const signingClient = await SigningStargateClient.connectWithSigner(addr,signer,{registry});
				let msg = this.msgStructOreRefineryStatusResponse({ value: MsgStructOreRefineryStatusResponse.fromPartial(value) })
				return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo)
			} catch (e: any) {
				throw new Error('TxClient:sendMsgStructOreRefineryStatusResponse: Could not broadcast Tx: '+ e.message)
			}
		},
		
		async sendQueryAllAgreementByProviderRequest({ value, fee, memo }: sendQueryAllAgreementByProviderRequestParams): Promise<DeliverTxResponse> {
			if (!signer) {
					throw new Error('TxClient:sendQueryAllAgreementByProviderRequest: Unable to sign Tx. Signer is not present.')
			}
			try {			
				const { address } = (await signer.getAccounts())[0]; 
				const signingClient = await SigningStargateClient.connectWithSigner(addr,signer,{registry});
				let msg = this.queryAllAgreementByProviderRequest({ value: QueryAllAgreementByProviderRequest.fromPartial(value) })
				return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo)
			} catch (e: any) {
				throw new Error('TxClient:sendQueryAllAgreementByProviderRequest: Could not broadcast Tx: '+ e.message)
			}
		},
		
		async sendQueryAllGuildResponse({ value, fee, memo }: sendQueryAllGuildResponseParams): Promise<DeliverTxResponse> {
			if (!signer) {
					throw new Error('TxClient:sendQueryAllGuildResponse: Unable to sign Tx. Signer is not present.')
			}
			try {			
				const { address } = (await signer.getAccounts())[0]; 
				const signingClient = await SigningStargateClient.connectWithSigner(addr,signer,{registry});
				let msg = this.queryAllGuildResponse({ value: QueryAllGuildResponse.fromPartial(value) })
				return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo)
			} catch (e: any) {
				throw new Error('TxClient:sendQueryAllGuildResponse: Could not broadcast Tx: '+ e.message)
			}
		},
		
		async sendQueryGetGuildMembershipApplicationRequest({ value, fee, memo }: sendQueryGetGuildMembershipApplicationRequestParams): Promise<DeliverTxResponse> {
			if (!signer) {
					throw new Error('TxClient:sendQueryGetGuildMembershipApplicationRequest: Unable to sign Tx. Signer is not present.')
			}
			try {			
				const { address } = (await signer.getAccounts())[0]; 
				const signingClient = await SigningStargateClient.connectWithSigner(addr,signer,{registry});
				let msg = this.queryGetGuildMembershipApplicationRequest({ value: QueryGetGuildMembershipApplicationRequest.fromPartial(value) })
				return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo)
			} catch (e: any) {
				throw new Error('TxClient:sendQueryGetGuildMembershipApplicationRequest: Could not broadcast Tx: '+ e.message)
			}
		},
		
		async sendQueryGetProviderByCollateralAddressRequest({ value, fee, memo }: sendQueryGetProviderByCollateralAddressRequestParams): Promise<DeliverTxResponse> {
			if (!signer) {
					throw new Error('TxClient:sendQueryGetProviderByCollateralAddressRequest: Unable to sign Tx. Signer is not present.')
			}
			try {			
				const { address } = (await signer.getAccounts())[0]; 
				const signingClient = await SigningStargateClient.connectWithSigner(addr,signer,{registry});
				let msg = this.queryGetProviderByCollateralAddressRequest({ value: QueryGetProviderByCollateralAddressRequest.fromPartial(value) })
				return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo)
			} catch (e: any) {
				throw new Error('TxClient:sendQueryGetProviderByCollateralAddressRequest: Could not broadcast Tx: '+ e.message)
			}
		},
		
		async sendEventGuildBankAddressDetail({ value, fee, memo }: sendEventGuildBankAddressDetailParams): Promise<DeliverTxResponse> {
			if (!signer) {
					throw new Error('TxClient:sendEventGuildBankAddressDetail: Unable to sign Tx. Signer is not present.')
			}
			try {			
				const { address } = (await signer.getAccounts())[0]; 
				const signingClient = await SigningStargateClient.connectWithSigner(addr,signer,{registry});
				let msg = this.eventGuildBankAddressDetail({ value: EventGuildBankAddressDetail.fromPartial(value) })
				return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo)
			} catch (e: any) {
				throw new Error('TxClient:sendEventGuildBankAddressDetail: Could not broadcast Tx: '+ e.message)
			}
		},
		
		async sendMsgGuildUpdateJoinInfusionMinimumBypassByRequest({ value, fee, memo }: sendMsgGuildUpdateJoinInfusionMinimumBypassByRequestParams): Promise<DeliverTxResponse> {
			if (!signer) {
					throw new Error('TxClient:sendMsgGuildUpdateJoinInfusionMinimumBypassByRequest: Unable to sign Tx. Signer is not present.')
			}
			try {			
				const { address } = (await signer.getAccounts())[0]; 
				const signingClient = await SigningStargateClient.connectWithSigner(addr,signer,{registry});
				let msg = this.msgGuildUpdateJoinInfusionMinimumBypassByRequest({ value: MsgGuildUpdateJoinInfusionMinimumBypassByRequest.fromPartial(value) })
				return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo)
			} catch (e: any) {
				throw new Error('TxClient:sendMsgGuildUpdateJoinInfusionMinimumBypassByRequest: Could not broadcast Tx: '+ e.message)
			}
		},
		
		async sendMsgPermissionRevokeOnAddress({ value, fee, memo }: sendMsgPermissionRevokeOnAddressParams): Promise<DeliverTxResponse> {
			if (!signer) {
					throw new Error('TxClient:sendMsgPermissionRevokeOnAddress: Unable to sign Tx. Signer is not present.')
			}
			try {			
				const { address } = (await signer.getAccounts())[0]; 
				const signingClient = await SigningStargateClient.connectWithSigner(addr,signer,{registry});
				let msg = this.msgPermissionRevokeOnAddress({ value: MsgPermissionRevokeOnAddress.fromPartial(value) })
				return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo)
			} catch (e: any) {
				throw new Error('TxClient:sendMsgPermissionRevokeOnAddress: Could not broadcast Tx: '+ e.message)
			}
		},
		
		async sendQueryParamsResponse({ value, fee, memo }: sendQueryParamsResponseParams): Promise<DeliverTxResponse> {
			if (!signer) {
					throw new Error('TxClient:sendQueryParamsResponse: Unable to sign Tx. Signer is not present.')
			}
			try {			
				const { address } = (await signer.getAccounts())[0]; 
				const signingClient = await SigningStargateClient.connectWithSigner(addr,signer,{registry});
				let msg = this.queryParamsResponse({ value: QueryParamsResponse.fromPartial(value) })
				return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo)
			} catch (e: any) {
				throw new Error('TxClient:sendQueryParamsResponse: Could not broadcast Tx: '+ e.message)
			}
		},
		
		async sendQueryAllPlanetRequest({ value, fee, memo }: sendQueryAllPlanetRequestParams): Promise<DeliverTxResponse> {
			if (!signer) {
					throw new Error('TxClient:sendQueryAllPlanetRequest: Unable to sign Tx. Signer is not present.')
			}
			try {			
				const { address } = (await signer.getAccounts())[0]; 
				const signingClient = await SigningStargateClient.connectWithSigner(addr,signer,{registry});
				let msg = this.queryAllPlanetRequest({ value: QueryAllPlanetRequest.fromPartial(value) })
				return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo)
			} catch (e: any) {
				throw new Error('TxClient:sendQueryAllPlanetRequest: Could not broadcast Tx: '+ e.message)
			}
		},
		
		async sendQueryAllPlayerResponse({ value, fee, memo }: sendQueryAllPlayerResponseParams): Promise<DeliverTxResponse> {
			if (!signer) {
					throw new Error('TxClient:sendQueryAllPlayerResponse: Unable to sign Tx. Signer is not present.')
			}
			try {			
				const { address } = (await signer.getAccounts())[0]; 
				const signingClient = await SigningStargateClient.connectWithSigner(addr,signer,{registry});
				let msg = this.queryAllPlayerResponse({ value: QueryAllPlayerResponse.fromPartial(value) })
				return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo)
			} catch (e: any) {
				throw new Error('TxClient:sendQueryAllPlayerResponse: Could not broadcast Tx: '+ e.message)
			}
		},
		
		async sendMsgAddressRevokeResponse({ value, fee, memo }: sendMsgAddressRevokeResponseParams): Promise<DeliverTxResponse> {
			if (!signer) {
					throw new Error('TxClient:sendMsgAddressRevokeResponse: Unable to sign Tx. Signer is not present.')
			}
			try {			
				const { address } = (await signer.getAccounts())[0]; 
				const signingClient = await SigningStargateClient.connectWithSigner(addr,signer,{registry});
				let msg = this.msgAddressRevokeResponse({ value: MsgAddressRevokeResponse.fromPartial(value) })
				return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo)
			} catch (e: any) {
				throw new Error('TxClient:sendMsgAddressRevokeResponse: Could not broadcast Tx: '+ e.message)
			}
		},
		
		async sendMsgStructActivate({ value, fee, memo }: sendMsgStructActivateParams): Promise<DeliverTxResponse> {
			if (!signer) {
					throw new Error('TxClient:sendMsgStructActivate: Unable to sign Tx. Signer is not present.')
			}
			try {			
				const { address } = (await signer.getAccounts())[0]; 
				const signingClient = await SigningStargateClient.connectWithSigner(addr,signer,{registry});
				let msg = this.msgStructActivate({ value: MsgStructActivate.fromPartial(value) })
				return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo)
			} catch (e: any) {
				throw new Error('TxClient:sendMsgStructActivate: Could not broadcast Tx: '+ e.message)
			}
		},
		
		async sendMsgStructGeneratorStatusResponse({ value, fee, memo }: sendMsgStructGeneratorStatusResponseParams): Promise<DeliverTxResponse> {
			if (!signer) {
					throw new Error('TxClient:sendMsgStructGeneratorStatusResponse: Unable to sign Tx. Signer is not present.')
			}
			try {			
				const { address } = (await signer.getAccounts())[0]; 
				const signingClient = await SigningStargateClient.connectWithSigner(addr,signer,{registry});
				let msg = this.msgStructGeneratorStatusResponse({ value: MsgStructGeneratorStatusResponse.fromPartial(value) })
				return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo)
			} catch (e: any) {
				throw new Error('TxClient:sendMsgStructGeneratorStatusResponse: Could not broadcast Tx: '+ e.message)
			}
		},
		
		async sendMsgAgreementCapacityIncrease({ value, fee, memo }: sendMsgAgreementCapacityIncreaseParams): Promise<DeliverTxResponse> {
			if (!signer) {
					throw new Error('TxClient:sendMsgAgreementCapacityIncrease: Unable to sign Tx. Signer is not present.')
			}
			try {			
				const { address } = (await signer.getAccounts())[0]; 
				const signingClient = await SigningStargateClient.connectWithSigner(addr,signer,{registry});
				let msg = this.msgAgreementCapacityIncrease({ value: MsgAgreementCapacityIncrease.fromPartial(value) })
				return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo)
			} catch (e: any) {
				throw new Error('TxClient:sendMsgAgreementCapacityIncrease: Could not broadcast Tx: '+ e.message)
			}
		},
		
		async sendQueryGetGuildByBankCollateralAddressRequest({ value, fee, memo }: sendQueryGetGuildByBankCollateralAddressRequestParams): Promise<DeliverTxResponse> {
			if (!signer) {
					throw new Error('TxClient:sendQueryGetGuildByBankCollateralAddressRequest: Unable to sign Tx. Signer is not present.')
			}
			try {			
				const { address } = (await signer.getAccounts())[0]; 
				const signingClient = await SigningStargateClient.connectWithSigner(addr,signer,{registry});
				let msg = this.queryGetGuildByBankCollateralAddressRequest({ value: QueryGetGuildByBankCollateralAddressRequest.fromPartial(value) })
				return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo)
			} catch (e: any) {
				throw new Error('TxClient:sendQueryGetGuildByBankCollateralAddressRequest: Could not broadcast Tx: '+ e.message)
			}
		},
		
		async sendQueryValidateSignatureRequest({ value, fee, memo }: sendQueryValidateSignatureRequestParams): Promise<DeliverTxResponse> {
			if (!signer) {
					throw new Error('TxClient:sendQueryValidateSignatureRequest: Unable to sign Tx. Signer is not present.')
			}
			try {			
				const { address } = (await signer.getAccounts())[0]; 
				const signingClient = await SigningStargateClient.connectWithSigner(addr,signer,{registry});
				let msg = this.queryValidateSignatureRequest({ value: QueryValidateSignatureRequest.fromPartial(value) })
				return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo)
			} catch (e: any) {
				throw new Error('TxClient:sendQueryValidateSignatureRequest: Could not broadcast Tx: '+ e.message)
			}
		},
		
		async sendMsgPlanetRaidComplete({ value, fee, memo }: sendMsgPlanetRaidCompleteParams): Promise<DeliverTxResponse> {
			if (!signer) {
					throw new Error('TxClient:sendMsgPlanetRaidComplete: Unable to sign Tx. Signer is not present.')
			}
			try {			
				const { address } = (await signer.getAccounts())[0]; 
				const signingClient = await SigningStargateClient.connectWithSigner(addr,signer,{registry});
				let msg = this.msgPlanetRaidComplete({ value: MsgPlanetRaidComplete.fromPartial(value) })
				return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo)
			} catch (e: any) {
				throw new Error('TxClient:sendMsgPlanetRaidComplete: Could not broadcast Tx: '+ e.message)
			}
		},
		
		async sendQueryAllAgreementRequest({ value, fee, memo }: sendQueryAllAgreementRequestParams): Promise<DeliverTxResponse> {
			if (!signer) {
					throw new Error('TxClient:sendQueryAllAgreementRequest: Unable to sign Tx. Signer is not present.')
			}
			try {			
				const { address } = (await signer.getAccounts())[0]; 
				const signingClient = await SigningStargateClient.connectWithSigner(addr,signer,{registry});
				let msg = this.queryAllAgreementRequest({ value: QueryAllAgreementRequest.fromPartial(value) })
				return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo)
			} catch (e: any) {
				throw new Error('TxClient:sendQueryAllAgreementRequest: Could not broadcast Tx: '+ e.message)
			}
		},
		
		async sendQueryAllStructResponse({ value, fee, memo }: sendQueryAllStructResponseParams): Promise<DeliverTxResponse> {
			if (!signer) {
					throw new Error('TxClient:sendQueryAllStructResponse: Unable to sign Tx. Signer is not present.')
			}
			try {			
				const { address } = (await signer.getAccounts())[0]; 
				const signingClient = await SigningStargateClient.connectWithSigner(addr,signer,{registry});
				let msg = this.queryAllStructResponse({ value: QueryAllStructResponse.fromPartial(value) })
				return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo)
			} catch (e: any) {
				throw new Error('TxClient:sendQueryAllStructResponse: Could not broadcast Tx: '+ e.message)
			}
		},
		
		async sendQueryAllSubstationResponse({ value, fee, memo }: sendQueryAllSubstationResponseParams): Promise<DeliverTxResponse> {
			if (!signer) {
					throw new Error('TxClient:sendQueryAllSubstationResponse: Unable to sign Tx. Signer is not present.')
			}
			try {			
				const { address } = (await signer.getAccounts())[0]; 
				const signingClient = await SigningStargateClient.connectWithSigner(addr,signer,{registry});
				let msg = this.queryAllSubstationResponse({ value: QueryAllSubstationResponse.fromPartial(value) })
				return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo)
			} catch (e: any) {
				throw new Error('TxClient:sendQueryAllSubstationResponse: Could not broadcast Tx: '+ e.message)
			}
		},
		
		async sendEventPlayerResumed({ value, fee, memo }: sendEventPlayerResumedParams): Promise<DeliverTxResponse> {
			if (!signer) {
					throw new Error('TxClient:sendEventPlayerResumed: Unable to sign Tx. Signer is not present.')
			}
			try {			
				const { address } = (await signer.getAccounts())[0]; 
				const signingClient = await SigningStargateClient.connectWithSigner(addr,signer,{registry});
				let msg = this.eventPlayerResumed({ value: EventPlayerResumed.fromPartial(value) })
				return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo)
			} catch (e: any) {
				throw new Error('TxClient:sendEventPlayerResumed: Could not broadcast Tx: '+ e.message)
			}
		},
		
		async sendQueryAllGuildBankCollateralAddressRequest({ value, fee, memo }: sendQueryAllGuildBankCollateralAddressRequestParams): Promise<DeliverTxResponse> {
			if (!signer) {
					throw new Error('TxClient:sendQueryAllGuildBankCollateralAddressRequest: Unable to sign Tx. Signer is not present.')
			}
			try {			
				const { address } = (await signer.getAccounts())[0]; 
				const signingClient = await SigningStargateClient.connectWithSigner(addr,signer,{registry});
				let msg = this.queryAllGuildBankCollateralAddressRequest({ value: QueryAllGuildBankCollateralAddressRequest.fromPartial(value) })
				return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo)
			} catch (e: any) {
				throw new Error('TxClient:sendQueryAllGuildBankCollateralAddressRequest: Could not broadcast Tx: '+ e.message)
			}
		},
		
		async sendEventStructDefender({ value, fee, memo }: sendEventStructDefenderParams): Promise<DeliverTxResponse> {
			if (!signer) {
					throw new Error('TxClient:sendEventStructDefender: Unable to sign Tx. Signer is not present.')
			}
			try {			
				const { address } = (await signer.getAccounts())[0]; 
				const signingClient = await SigningStargateClient.connectWithSigner(addr,signer,{registry});
				let msg = this.eventStructDefender({ value: EventStructDefender.fromPartial(value) })
				return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo)
			} catch (e: any) {
				throw new Error('TxClient:sendEventStructDefender: Could not broadcast Tx: '+ e.message)
			}
		},
		
		async sendEventAttackDetail({ value, fee, memo }: sendEventAttackDetailParams): Promise<DeliverTxResponse> {
			if (!signer) {
					throw new Error('TxClient:sendEventAttackDetail: Unable to sign Tx. Signer is not present.')
			}
			try {			
				const { address } = (await signer.getAccounts())[0]; 
				const signingClient = await SigningStargateClient.connectWithSigner(addr,signer,{registry});
				let msg = this.eventAttackDetail({ value: EventAttackDetail.fromPartial(value) })
				return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo)
			} catch (e: any) {
				throw new Error('TxClient:sendEventAttackDetail: Could not broadcast Tx: '+ e.message)
			}
		},
		
		async sendMsgAddressRegister({ value, fee, memo }: sendMsgAddressRegisterParams): Promise<DeliverTxResponse> {
			if (!signer) {
					throw new Error('TxClient:sendMsgAddressRegister: Unable to sign Tx. Signer is not present.')
			}
			try {			
				const { address } = (await signer.getAccounts())[0]; 
				const signingClient = await SigningStargateClient.connectWithSigner(addr,signer,{registry});
				let msg = this.msgAddressRegister({ value: MsgAddressRegister.fromPartial(value) })
				return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo)
			} catch (e: any) {
				throw new Error('TxClient:sendMsgAddressRegister: Could not broadcast Tx: '+ e.message)
			}
		},
		
		async sendMsgGuildMembershipRequestApprove({ value, fee, memo }: sendMsgGuildMembershipRequestApproveParams): Promise<DeliverTxResponse> {
			if (!signer) {
					throw new Error('TxClient:sendMsgGuildMembershipRequestApprove: Unable to sign Tx. Signer is not present.')
			}
			try {			
				const { address } = (await signer.getAccounts())[0]; 
				const signingClient = await SigningStargateClient.connectWithSigner(addr,signer,{registry});
				let msg = this.msgGuildMembershipRequestApprove({ value: MsgGuildMembershipRequestApprove.fromPartial(value) })
				return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo)
			} catch (e: any) {
				throw new Error('TxClient:sendMsgGuildMembershipRequestApprove: Could not broadcast Tx: '+ e.message)
			}
		},
		
		async sendMsgStructOreMinerStatusResponse({ value, fee, memo }: sendMsgStructOreMinerStatusResponseParams): Promise<DeliverTxResponse> {
			if (!signer) {
					throw new Error('TxClient:sendMsgStructOreMinerStatusResponse: Unable to sign Tx. Signer is not present.')
			}
			try {			
				const { address } = (await signer.getAccounts())[0]; 
				const signingClient = await SigningStargateClient.connectWithSigner(addr,signer,{registry});
				let msg = this.msgStructOreMinerStatusResponse({ value: MsgStructOreMinerStatusResponse.fromPartial(value) })
				return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo)
			} catch (e: any) {
				throw new Error('TxClient:sendMsgStructOreMinerStatusResponse: Could not broadcast Tx: '+ e.message)
			}
		},
		
		async sendQueryAllAllocationRequest({ value, fee, memo }: sendQueryAllAllocationRequestParams): Promise<DeliverTxResponse> {
			if (!signer) {
					throw new Error('TxClient:sendQueryAllAllocationRequest: Unable to sign Tx. Signer is not present.')
			}
			try {			
				const { address } = (await signer.getAccounts())[0]; 
				const signingClient = await SigningStargateClient.connectWithSigner(addr,signer,{registry});
				let msg = this.queryAllAllocationRequest({ value: QueryAllAllocationRequest.fromPartial(value) })
				return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo)
			} catch (e: any) {
				throw new Error('TxClient:sendQueryAllAllocationRequest: Could not broadcast Tx: '+ e.message)
			}
		},
		
		async sendQueryAllAllocationBySourceRequest({ value, fee, memo }: sendQueryAllAllocationBySourceRequestParams): Promise<DeliverTxResponse> {
			if (!signer) {
					throw new Error('TxClient:sendQueryAllAllocationBySourceRequest: Unable to sign Tx. Signer is not present.')
			}
			try {			
				const { address } = (await signer.getAccounts())[0]; 
				const signingClient = await SigningStargateClient.connectWithSigner(addr,signer,{registry});
				let msg = this.queryAllAllocationBySourceRequest({ value: QueryAllAllocationBySourceRequest.fromPartial(value) })
				return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo)
			} catch (e: any) {
				throw new Error('TxClient:sendQueryAllAllocationBySourceRequest: Could not broadcast Tx: '+ e.message)
			}
		},
		
		async sendGridAttributes({ value, fee, memo }: sendGridAttributesParams): Promise<DeliverTxResponse> {
			if (!signer) {
					throw new Error('TxClient:sendGridAttributes: Unable to sign Tx. Signer is not present.')
			}
			try {			
				const { address } = (await signer.getAccounts())[0]; 
				const signingClient = await SigningStargateClient.connectWithSigner(addr,signer,{registry});
				let msg = this.gridAttributes({ value: GridAttributes.fromPartial(value) })
				return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo)
			} catch (e: any) {
				throw new Error('TxClient:sendGridAttributes: Could not broadcast Tx: '+ e.message)
			}
		},
		
		async sendStructsPacketData({ value, fee, memo }: sendStructsPacketDataParams): Promise<DeliverTxResponse> {
			if (!signer) {
					throw new Error('TxClient:sendStructsPacketData: Unable to sign Tx. Signer is not present.')
			}
			try {			
				const { address } = (await signer.getAccounts())[0]; 
				const signingClient = await SigningStargateClient.connectWithSigner(addr,signer,{registry});
				let msg = this.structsPacketData({ value: StructsPacketData.fromPartial(value) })
				return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo)
			} catch (e: any) {
				throw new Error('TxClient:sendStructsPacketData: Could not broadcast Tx: '+ e.message)
			}
		},
		
		async sendEventSubstation({ value, fee, memo }: sendEventSubstationParams): Promise<DeliverTxResponse> {
			if (!signer) {
					throw new Error('TxClient:sendEventSubstation: Unable to sign Tx. Signer is not present.')
			}
			try {			
				const { address } = (await signer.getAccounts())[0]; 
				const signingClient = await SigningStargateClient.connectWithSigner(addr,signer,{registry});
				let msg = this.eventSubstation({ value: EventSubstation.fromPartial(value) })
				return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo)
			} catch (e: any) {
				throw new Error('TxClient:sendEventSubstation: Could not broadcast Tx: '+ e.message)
			}
		},
		
		async sendMsgFleetMove({ value, fee, memo }: sendMsgFleetMoveParams): Promise<DeliverTxResponse> {
			if (!signer) {
					throw new Error('TxClient:sendMsgFleetMove: Unable to sign Tx. Signer is not present.')
			}
			try {			
				const { address } = (await signer.getAccounts())[0]; 
				const signingClient = await SigningStargateClient.connectWithSigner(addr,signer,{registry});
				let msg = this.msgFleetMove({ value: MsgFleetMove.fromPartial(value) })
				return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo)
			} catch (e: any) {
				throw new Error('TxClient:sendMsgFleetMove: Could not broadcast Tx: '+ e.message)
			}
		},
		
		async sendMsgGuildBankRedeem({ value, fee, memo }: sendMsgGuildBankRedeemParams): Promise<DeliverTxResponse> {
			if (!signer) {
					throw new Error('TxClient:sendMsgGuildBankRedeem: Unable to sign Tx. Signer is not present.')
			}
			try {			
				const { address } = (await signer.getAccounts())[0]; 
				const signingClient = await SigningStargateClient.connectWithSigner(addr,signer,{registry});
				let msg = this.msgGuildBankRedeem({ value: MsgGuildBankRedeem.fromPartial(value) })
				return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo)
			} catch (e: any) {
				throw new Error('TxClient:sendMsgGuildBankRedeem: Could not broadcast Tx: '+ e.message)
			}
		},
		
		async sendQueryGetFleetByIndexRequest({ value, fee, memo }: sendQueryGetFleetByIndexRequestParams): Promise<DeliverTxResponse> {
			if (!signer) {
					throw new Error('TxClient:sendQueryGetFleetByIndexRequest: Unable to sign Tx. Signer is not present.')
			}
			try {			
				const { address } = (await signer.getAccounts())[0]; 
				const signingClient = await SigningStargateClient.connectWithSigner(addr,signer,{registry});
				let msg = this.queryGetFleetByIndexRequest({ value: QueryGetFleetByIndexRequest.fromPartial(value) })
				return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo)
			} catch (e: any) {
				throw new Error('TxClient:sendQueryGetFleetByIndexRequest: Could not broadcast Tx: '+ e.message)
			}
		},
		
		async sendQueryGetGridResponse({ value, fee, memo }: sendQueryGetGridResponseParams): Promise<DeliverTxResponse> {
			if (!signer) {
					throw new Error('TxClient:sendQueryGetGridResponse: Unable to sign Tx. Signer is not present.')
			}
			try {			
				const { address } = (await signer.getAccounts())[0]; 
				const signingClient = await SigningStargateClient.connectWithSigner(addr,signer,{registry});
				let msg = this.queryGetGridResponse({ value: QueryGetGridResponse.fromPartial(value) })
				return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo)
			} catch (e: any) {
				throw new Error('TxClient:sendQueryGetGridResponse: Could not broadcast Tx: '+ e.message)
			}
		},
		
		async sendQueryGetInfusionRequest({ value, fee, memo }: sendQueryGetInfusionRequestParams): Promise<DeliverTxResponse> {
			if (!signer) {
					throw new Error('TxClient:sendQueryGetInfusionRequest: Unable to sign Tx. Signer is not present.')
			}
			try {			
				const { address } = (await signer.getAccounts())[0]; 
				const signingClient = await SigningStargateClient.connectWithSigner(addr,signer,{registry});
				let msg = this.queryGetInfusionRequest({ value: QueryGetInfusionRequest.fromPartial(value) })
				return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo)
			} catch (e: any) {
				throw new Error('TxClient:sendQueryGetInfusionRequest: Could not broadcast Tx: '+ e.message)
			}
		},
		
		async sendQueryAllInfusionResponse({ value, fee, memo }: sendQueryAllInfusionResponseParams): Promise<DeliverTxResponse> {
			if (!signer) {
					throw new Error('TxClient:sendQueryAllInfusionResponse: Unable to sign Tx. Signer is not present.')
			}
			try {			
				const { address } = (await signer.getAccounts())[0]; 
				const signingClient = await SigningStargateClient.connectWithSigner(addr,signer,{registry});
				let msg = this.queryAllInfusionResponse({ value: QueryAllInfusionResponse.fromPartial(value) })
				return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo)
			} catch (e: any) {
				throw new Error('TxClient:sendQueryAllInfusionResponse: Could not broadcast Tx: '+ e.message)
			}
		},
		
		async sendEventProviderAddressDetail({ value, fee, memo }: sendEventProviderAddressDetailParams): Promise<DeliverTxResponse> {
			if (!signer) {
					throw new Error('TxClient:sendEventProviderAddressDetail: Unable to sign Tx. Signer is not present.')
			}
			try {			
				const { address } = (await signer.getAccounts())[0]; 
				const signingClient = await SigningStargateClient.connectWithSigner(addr,signer,{registry});
				let msg = this.eventProviderAddressDetail({ value: EventProviderAddressDetail.fromPartial(value) })
				return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo)
			} catch (e: any) {
				throw new Error('TxClient:sendEventProviderAddressDetail: Could not broadcast Tx: '+ e.message)
			}
		},
		
		async sendMsgGuildUpdateEndpoint({ value, fee, memo }: sendMsgGuildUpdateEndpointParams): Promise<DeliverTxResponse> {
			if (!signer) {
					throw new Error('TxClient:sendMsgGuildUpdateEndpoint: Unable to sign Tx. Signer is not present.')
			}
			try {			
				const { address } = (await signer.getAccounts())[0]; 
				const signingClient = await SigningStargateClient.connectWithSigner(addr,signer,{registry});
				let msg = this.msgGuildUpdateEndpoint({ value: MsgGuildUpdateEndpoint.fromPartial(value) })
				return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo)
			} catch (e: any) {
				throw new Error('TxClient:sendMsgGuildUpdateEndpoint: Could not broadcast Tx: '+ e.message)
			}
		},
		
		async sendMsgAgreementDurationIncrease({ value, fee, memo }: sendMsgAgreementDurationIncreaseParams): Promise<DeliverTxResponse> {
			if (!signer) {
					throw new Error('TxClient:sendMsgAgreementDurationIncrease: Unable to sign Tx. Signer is not present.')
			}
			try {			
				const { address } = (await signer.getAccounts())[0]; 
				const signingClient = await SigningStargateClient.connectWithSigner(addr,signer,{registry});
				let msg = this.msgAgreementDurationIncrease({ value: MsgAgreementDurationIncrease.fromPartial(value) })
				return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo)
			} catch (e: any) {
				throw new Error('TxClient:sendMsgAgreementDurationIncrease: Could not broadcast Tx: '+ e.message)
			}
		},
		
		async sendQueryAllAllocationResponse({ value, fee, memo }: sendQueryAllAllocationResponseParams): Promise<DeliverTxResponse> {
			if (!signer) {
					throw new Error('TxClient:sendQueryAllAllocationResponse: Unable to sign Tx. Signer is not present.')
			}
			try {			
				const { address } = (await signer.getAccounts())[0]; 
				const signingClient = await SigningStargateClient.connectWithSigner(addr,signer,{registry});
				let msg = this.queryAllAllocationResponse({ value: QueryAllAllocationResponse.fromPartial(value) })
				return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo)
			} catch (e: any) {
				throw new Error('TxClient:sendQueryAllAllocationResponse: Could not broadcast Tx: '+ e.message)
			}
		},
		
		async sendQueryAllReactorResponse({ value, fee, memo }: sendQueryAllReactorResponseParams): Promise<DeliverTxResponse> {
			if (!signer) {
					throw new Error('TxClient:sendQueryAllReactorResponse: Unable to sign Tx. Signer is not present.')
			}
			try {			
				const { address } = (await signer.getAccounts())[0]; 
				const signingClient = await SigningStargateClient.connectWithSigner(addr,signer,{registry});
				let msg = this.queryAllReactorResponse({ value: QueryAllReactorResponse.fromPartial(value) })
				return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo)
			} catch (e: any) {
				throw new Error('TxClient:sendQueryAllReactorResponse: Could not broadcast Tx: '+ e.message)
			}
		},
		
		async sendEventStructType({ value, fee, memo }: sendEventStructTypeParams): Promise<DeliverTxResponse> {
			if (!signer) {
					throw new Error('TxClient:sendEventStructType: Unable to sign Tx. Signer is not present.')
			}
			try {			
				const { address } = (await signer.getAccounts())[0]; 
				const signingClient = await SigningStargateClient.connectWithSigner(addr,signer,{registry});
				let msg = this.eventStructType({ value: EventStructType.fromPartial(value) })
				return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo)
			} catch (e: any) {
				throw new Error('TxClient:sendEventStructType: Could not broadcast Tx: '+ e.message)
			}
		},
		
		async sendEventGrid({ value, fee, memo }: sendEventGridParams): Promise<DeliverTxResponse> {
			if (!signer) {
					throw new Error('TxClient:sendEventGrid: Unable to sign Tx. Signer is not present.')
			}
			try {			
				const { address } = (await signer.getAccounts())[0]; 
				const signingClient = await SigningStargateClient.connectWithSigner(addr,signer,{registry});
				let msg = this.eventGrid({ value: EventGrid.fromPartial(value) })
				return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo)
			} catch (e: any) {
				throw new Error('TxClient:sendEventGrid: Could not broadcast Tx: '+ e.message)
			}
		},
		
		async sendEventGuildBankRedeem({ value, fee, memo }: sendEventGuildBankRedeemParams): Promise<DeliverTxResponse> {
			if (!signer) {
					throw new Error('TxClient:sendEventGuildBankRedeem: Unable to sign Tx. Signer is not present.')
			}
			try {			
				const { address } = (await signer.getAccounts())[0]; 
				const signingClient = await SigningStargateClient.connectWithSigner(addr,signer,{registry});
				let msg = this.eventGuildBankRedeem({ value: EventGuildBankRedeem.fromPartial(value) })
				return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo)
			} catch (e: any) {
				throw new Error('TxClient:sendEventGuildBankRedeem: Could not broadcast Tx: '+ e.message)
			}
		},
		
		async sendEventOreMineDetail({ value, fee, memo }: sendEventOreMineDetailParams): Promise<DeliverTxResponse> {
			if (!signer) {
					throw new Error('TxClient:sendEventOreMineDetail: Unable to sign Tx. Signer is not present.')
			}
			try {			
				const { address } = (await signer.getAccounts())[0]; 
				const signingClient = await SigningStargateClient.connectWithSigner(addr,signer,{registry});
				let msg = this.eventOreMineDetail({ value: EventOreMineDetail.fromPartial(value) })
				return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo)
			} catch (e: any) {
				throw new Error('TxClient:sendEventOreMineDetail: Could not broadcast Tx: '+ e.message)
			}
		},
		
		async sendQueryAllAllocationByDestinationRequest({ value, fee, memo }: sendQueryAllAllocationByDestinationRequestParams): Promise<DeliverTxResponse> {
			if (!signer) {
					throw new Error('TxClient:sendQueryAllAllocationByDestinationRequest: Unable to sign Tx. Signer is not present.')
			}
			try {			
				const { address } = (await signer.getAccounts())[0]; 
				const signingClient = await SigningStargateClient.connectWithSigner(addr,signer,{registry});
				let msg = this.queryAllAllocationByDestinationRequest({ value: QueryAllAllocationByDestinationRequest.fromPartial(value) })
				return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo)
			} catch (e: any) {
				throw new Error('TxClient:sendQueryAllAllocationByDestinationRequest: Could not broadcast Tx: '+ e.message)
			}
		},
		
		async sendPlayer({ value, fee, memo }: sendPlayerParams): Promise<DeliverTxResponse> {
			if (!signer) {
					throw new Error('TxClient:sendPlayer: Unable to sign Tx. Signer is not present.')
			}
			try {			
				const { address } = (await signer.getAccounts())[0]; 
				const signingClient = await SigningStargateClient.connectWithSigner(addr,signer,{registry});
				let msg = this.player({ value: Player.fromPartial(value) })
				return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo)
			} catch (e: any) {
				throw new Error('TxClient:sendPlayer: Could not broadcast Tx: '+ e.message)
			}
		},
		
		async sendMsgPlayerResumeResponse({ value, fee, memo }: sendMsgPlayerResumeResponseParams): Promise<DeliverTxResponse> {
			if (!signer) {
					throw new Error('TxClient:sendMsgPlayerResumeResponse: Unable to sign Tx. Signer is not present.')
			}
			try {			
				const { address } = (await signer.getAccounts())[0]; 
				const signingClient = await SigningStargateClient.connectWithSigner(addr,signer,{registry});
				let msg = this.msgPlayerResumeResponse({ value: MsgPlayerResumeResponse.fromPartial(value) })
				return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo)
			} catch (e: any) {
				throw new Error('TxClient:sendMsgPlayerResumeResponse: Could not broadcast Tx: '+ e.message)
			}
		},
		
		async sendMsgStructStatusResponse({ value, fee, memo }: sendMsgStructStatusResponseParams): Promise<DeliverTxResponse> {
			if (!signer) {
					throw new Error('TxClient:sendMsgStructStatusResponse: Unable to sign Tx. Signer is not present.')
			}
			try {			
				const { address } = (await signer.getAccounts())[0]; 
				const signingClient = await SigningStargateClient.connectWithSigner(addr,signer,{registry});
				let msg = this.msgStructStatusResponse({ value: MsgStructStatusResponse.fromPartial(value) })
				return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo)
			} catch (e: any) {
				throw new Error('TxClient:sendMsgStructStatusResponse: Could not broadcast Tx: '+ e.message)
			}
		},
		
		async sendMsgStructStorageRecall({ value, fee, memo }: sendMsgStructStorageRecallParams): Promise<DeliverTxResponse> {
			if (!signer) {
					throw new Error('TxClient:sendMsgStructStorageRecall: Unable to sign Tx. Signer is not present.')
			}
			try {			
				const { address } = (await signer.getAccounts())[0]; 
				const signingClient = await SigningStargateClient.connectWithSigner(addr,signer,{registry});
				let msg = this.msgStructStorageRecall({ value: MsgStructStorageRecall.fromPartial(value) })
				return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo)
			} catch (e: any) {
				throw new Error('TxClient:sendMsgStructStorageRecall: Could not broadcast Tx: '+ e.message)
			}
		},
		
		async sendMsgAgreementResponse({ value, fee, memo }: sendMsgAgreementResponseParams): Promise<DeliverTxResponse> {
			if (!signer) {
					throw new Error('TxClient:sendMsgAgreementResponse: Unable to sign Tx. Signer is not present.')
			}
			try {			
				const { address } = (await signer.getAccounts())[0]; 
				const signingClient = await SigningStargateClient.connectWithSigner(addr,signer,{registry});
				let msg = this.msgAgreementResponse({ value: MsgAgreementResponse.fromPartial(value) })
				return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo)
			} catch (e: any) {
				throw new Error('TxClient:sendMsgAgreementResponse: Could not broadcast Tx: '+ e.message)
			}
		},
		
		async sendMsgProviderCreate({ value, fee, memo }: sendMsgProviderCreateParams): Promise<DeliverTxResponse> {
			if (!signer) {
					throw new Error('TxClient:sendMsgProviderCreate: Unable to sign Tx. Signer is not present.')
			}
			try {			
				const { address } = (await signer.getAccounts())[0]; 
				const signingClient = await SigningStargateClient.connectWithSigner(addr,signer,{registry});
				let msg = this.msgProviderCreate({ value: MsgProviderCreate.fromPartial(value) })
				return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo)
			} catch (e: any) {
				throw new Error('TxClient:sendMsgProviderCreate: Could not broadcast Tx: '+ e.message)
			}
		},
		
		async sendMsgPlayerSendResponse({ value, fee, memo }: sendMsgPlayerSendResponseParams): Promise<DeliverTxResponse> {
			if (!signer) {
					throw new Error('TxClient:sendMsgPlayerSendResponse: Unable to sign Tx. Signer is not present.')
			}
			try {			
				const { address } = (await signer.getAccounts())[0]; 
				const signingClient = await SigningStargateClient.connectWithSigner(addr,signer,{registry});
				let msg = this.msgPlayerSendResponse({ value: MsgPlayerSendResponse.fromPartial(value) })
				return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo)
			} catch (e: any) {
				throw new Error('TxClient:sendMsgPlayerSendResponse: Could not broadcast Tx: '+ e.message)
			}
		},
		
		async sendQueryAllAddressRequest({ value, fee, memo }: sendQueryAllAddressRequestParams): Promise<DeliverTxResponse> {
			if (!signer) {
					throw new Error('TxClient:sendQueryAllAddressRequest: Unable to sign Tx. Signer is not present.')
			}
			try {			
				const { address } = (await signer.getAccounts())[0]; 
				const signingClient = await SigningStargateClient.connectWithSigner(addr,signer,{registry});
				let msg = this.queryAllAddressRequest({ value: QueryAllAddressRequest.fromPartial(value) })
				return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo)
			} catch (e: any) {
				throw new Error('TxClient:sendQueryAllAddressRequest: Could not broadcast Tx: '+ e.message)
			}
		},
		
		async sendQueryGetReactorResponse({ value, fee, memo }: sendQueryGetReactorResponseParams): Promise<DeliverTxResponse> {
			if (!signer) {
					throw new Error('TxClient:sendQueryGetReactorResponse: Unable to sign Tx. Signer is not present.')
			}
			try {			
				const { address } = (await signer.getAccounts())[0]; 
				const signingClient = await SigningStargateClient.connectWithSigner(addr,signer,{registry});
				let msg = this.queryGetReactorResponse({ value: QueryGetReactorResponse.fromPartial(value) })
				return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo)
			} catch (e: any) {
				throw new Error('TxClient:sendQueryGetReactorResponse: Could not broadcast Tx: '+ e.message)
			}
		},
		
		async sendEventProviderGrantGuild({ value, fee, memo }: sendEventProviderGrantGuildParams): Promise<DeliverTxResponse> {
			if (!signer) {
					throw new Error('TxClient:sendEventProviderGrantGuild: Unable to sign Tx. Signer is not present.')
			}
			try {			
				const { address } = (await signer.getAccounts())[0]; 
				const signingClient = await SigningStargateClient.connectWithSigner(addr,signer,{registry});
				let msg = this.eventProviderGrantGuild({ value: EventProviderGrantGuild.fromPartial(value) })
				return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo)
			} catch (e: any) {
				throw new Error('TxClient:sendEventProviderGrantGuild: Could not broadcast Tx: '+ e.message)
			}
		},
		
		async sendEventGuildBankConfiscateAndBurn({ value, fee, memo }: sendEventGuildBankConfiscateAndBurnParams): Promise<DeliverTxResponse> {
			if (!signer) {
					throw new Error('TxClient:sendEventGuildBankConfiscateAndBurn: Unable to sign Tx. Signer is not present.')
			}
			try {			
				const { address } = (await signer.getAccounts())[0]; 
				const signingClient = await SigningStargateClient.connectWithSigner(addr,signer,{registry});
				let msg = this.eventGuildBankConfiscateAndBurn({ value: EventGuildBankConfiscateAndBurn.fromPartial(value) })
				return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo)
			} catch (e: any) {
				throw new Error('TxClient:sendEventGuildBankConfiscateAndBurn: Could not broadcast Tx: '+ e.message)
			}
		},
		
		async sendQueryBlockHeightResponse({ value, fee, memo }: sendQueryBlockHeightResponseParams): Promise<DeliverTxResponse> {
			if (!signer) {
					throw new Error('TxClient:sendQueryBlockHeightResponse: Unable to sign Tx. Signer is not present.')
			}
			try {			
				const { address } = (await signer.getAccounts())[0]; 
				const signingClient = await SigningStargateClient.connectWithSigner(addr,signer,{registry});
				let msg = this.queryBlockHeightResponse({ value: QueryBlockHeightResponse.fromPartial(value) })
				return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo)
			} catch (e: any) {
				throw new Error('TxClient:sendQueryBlockHeightResponse: Could not broadcast Tx: '+ e.message)
			}
		},
		
		async sendQueryAllPlanetByPlayerRequest({ value, fee, memo }: sendQueryAllPlanetByPlayerRequestParams): Promise<DeliverTxResponse> {
			if (!signer) {
					throw new Error('TxClient:sendQueryAllPlanetByPlayerRequest: Unable to sign Tx. Signer is not present.')
			}
			try {			
				const { address } = (await signer.getAccounts())[0]; 
				const signingClient = await SigningStargateClient.connectWithSigner(addr,signer,{registry});
				let msg = this.queryAllPlanetByPlayerRequest({ value: QueryAllPlanetByPlayerRequest.fromPartial(value) })
				return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo)
			} catch (e: any) {
				throw new Error('TxClient:sendQueryAllPlanetByPlayerRequest: Could not broadcast Tx: '+ e.message)
			}
		},
		
		async sendMsgGuildMembershipRequestRevoke({ value, fee, memo }: sendMsgGuildMembershipRequestRevokeParams): Promise<DeliverTxResponse> {
			if (!signer) {
					throw new Error('TxClient:sendMsgGuildMembershipRequestRevoke: Unable to sign Tx. Signer is not present.')
			}
			try {			
				const { address } = (await signer.getAccounts())[0]; 
				const signingClient = await SigningStargateClient.connectWithSigner(addr,signer,{registry});
				let msg = this.msgGuildMembershipRequestRevoke({ value: MsgGuildMembershipRequestRevoke.fromPartial(value) })
				return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo)
			} catch (e: any) {
				throw new Error('TxClient:sendMsgGuildMembershipRequestRevoke: Could not broadcast Tx: '+ e.message)
			}
		},
		
		async sendQueryAllStructAttributeRequest({ value, fee, memo }: sendQueryAllStructAttributeRequestParams): Promise<DeliverTxResponse> {
			if (!signer) {
					throw new Error('TxClient:sendQueryAllStructAttributeRequest: Unable to sign Tx. Signer is not present.')
			}
			try {			
				const { address } = (await signer.getAccounts())[0]; 
				const signingClient = await SigningStargateClient.connectWithSigner(addr,signer,{registry});
				let msg = this.queryAllStructAttributeRequest({ value: QueryAllStructAttributeRequest.fromPartial(value) })
				return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo)
			} catch (e: any) {
				throw new Error('TxClient:sendQueryAllStructAttributeRequest: Could not broadcast Tx: '+ e.message)
			}
		},
		
		async sendReactor({ value, fee, memo }: sendReactorParams): Promise<DeliverTxResponse> {
			if (!signer) {
					throw new Error('TxClient:sendReactor: Unable to sign Tx. Signer is not present.')
			}
			try {			
				const { address } = (await signer.getAccounts())[0]; 
				const signingClient = await SigningStargateClient.connectWithSigner(addr,signer,{registry});
				let msg = this.reactor({ value: Reactor.fromPartial(value) })
				return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo)
			} catch (e: any) {
				throw new Error('TxClient:sendReactor: Could not broadcast Tx: '+ e.message)
			}
		},
		
		async sendEventAttack({ value, fee, memo }: sendEventAttackParams): Promise<DeliverTxResponse> {
			if (!signer) {
					throw new Error('TxClient:sendEventAttack: Unable to sign Tx. Signer is not present.')
			}
			try {			
				const { address } = (await signer.getAccounts())[0]; 
				const signingClient = await SigningStargateClient.connectWithSigner(addr,signer,{registry});
				let msg = this.eventAttack({ value: EventAttack.fromPartial(value) })
				return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo)
			} catch (e: any) {
				throw new Error('TxClient:sendEventAttack: Could not broadcast Tx: '+ e.message)
			}
		},
		
		async sendMsgSubstationAllocationDisconnectResponse({ value, fee, memo }: sendMsgSubstationAllocationDisconnectResponseParams): Promise<DeliverTxResponse> {
			if (!signer) {
					throw new Error('TxClient:sendMsgSubstationAllocationDisconnectResponse: Unable to sign Tx. Signer is not present.')
			}
			try {			
				const { address } = (await signer.getAccounts())[0]; 
				const signingClient = await SigningStargateClient.connectWithSigner(addr,signer,{registry});
				let msg = this.msgSubstationAllocationDisconnectResponse({ value: MsgSubstationAllocationDisconnectResponse.fromPartial(value) })
				return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo)
			} catch (e: any) {
				throw new Error('TxClient:sendMsgSubstationAllocationDisconnectResponse: Could not broadcast Tx: '+ e.message)
			}
		},
		
		async sendMsgAgreementCapacityDecrease({ value, fee, memo }: sendMsgAgreementCapacityDecreaseParams): Promise<DeliverTxResponse> {
			if (!signer) {
					throw new Error('TxClient:sendMsgAgreementCapacityDecrease: Unable to sign Tx. Signer is not present.')
			}
			try {			
				const { address } = (await signer.getAccounts())[0]; 
				const signingClient = await SigningStargateClient.connectWithSigner(addr,signer,{registry});
				let msg = this.msgAgreementCapacityDecrease({ value: MsgAgreementCapacityDecrease.fromPartial(value) })
				return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo)
			} catch (e: any) {
				throw new Error('TxClient:sendMsgAgreementCapacityDecrease: Could not broadcast Tx: '+ e.message)
			}
		},
		
		async sendQueryAllGuildBankCollateralAddressResponse({ value, fee, memo }: sendQueryAllGuildBankCollateralAddressResponseParams): Promise<DeliverTxResponse> {
			if (!signer) {
					throw new Error('TxClient:sendQueryAllGuildBankCollateralAddressResponse: Unable to sign Tx. Signer is not present.')
			}
			try {			
				const { address } = (await signer.getAccounts())[0]; 
				const signingClient = await SigningStargateClient.connectWithSigner(addr,signer,{registry});
				let msg = this.queryAllGuildBankCollateralAddressResponse({ value: QueryAllGuildBankCollateralAddressResponse.fromPartial(value) })
				return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo)
			} catch (e: any) {
				throw new Error('TxClient:sendQueryAllGuildBankCollateralAddressResponse: Could not broadcast Tx: '+ e.message)
			}
		},
		
		async sendQueryAllSubstationRequest({ value, fee, memo }: sendQueryAllSubstationRequestParams): Promise<DeliverTxResponse> {
			if (!signer) {
					throw new Error('TxClient:sendQueryAllSubstationRequest: Unable to sign Tx. Signer is not present.')
			}
			try {			
				const { address } = (await signer.getAccounts())[0]; 
				const signingClient = await SigningStargateClient.connectWithSigner(addr,signer,{registry});
				let msg = this.queryAllSubstationRequest({ value: QueryAllSubstationRequest.fromPartial(value) })
				return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo)
			} catch (e: any) {
				throw new Error('TxClient:sendQueryAllSubstationRequest: Could not broadcast Tx: '+ e.message)
			}
		},
		
		async sendQueryValidateSignatureResponse({ value, fee, memo }: sendQueryValidateSignatureResponseParams): Promise<DeliverTxResponse> {
			if (!signer) {
					throw new Error('TxClient:sendQueryValidateSignatureResponse: Unable to sign Tx. Signer is not present.')
			}
			try {			
				const { address } = (await signer.getAccounts())[0]; 
				const signingClient = await SigningStargateClient.connectWithSigner(addr,signer,{registry});
				let msg = this.queryValidateSignatureResponse({ value: QueryValidateSignatureResponse.fromPartial(value) })
				return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo)
			} catch (e: any) {
				throw new Error('TxClient:sendQueryValidateSignatureResponse: Could not broadcast Tx: '+ e.message)
			}
		},
		
		async sendEventFleet({ value, fee, memo }: sendEventFleetParams): Promise<DeliverTxResponse> {
			if (!signer) {
					throw new Error('TxClient:sendEventFleet: Unable to sign Tx. Signer is not present.')
			}
			try {			
				const { address } = (await signer.getAccounts())[0]; 
				const signingClient = await SigningStargateClient.connectWithSigner(addr,signer,{registry});
				let msg = this.eventFleet({ value: EventFleet.fromPartial(value) })
				return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo)
			} catch (e: any) {
				throw new Error('TxClient:sendEventFleet: Could not broadcast Tx: '+ e.message)
			}
		},
		
		async sendProvider({ value, fee, memo }: sendProviderParams): Promise<DeliverTxResponse> {
			if (!signer) {
					throw new Error('TxClient:sendProvider: Unable to sign Tx. Signer is not present.')
			}
			try {			
				const { address } = (await signer.getAccounts())[0]; 
				const signingClient = await SigningStargateClient.connectWithSigner(addr,signer,{registry});
				let msg = this.provider({ value: Provider.fromPartial(value) })
				return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo)
			} catch (e: any) {
				throw new Error('TxClient:sendProvider: Could not broadcast Tx: '+ e.message)
			}
		},
		
		async sendQueryBlockHeight({ value, fee, memo }: sendQueryBlockHeightParams): Promise<DeliverTxResponse> {
			if (!signer) {
					throw new Error('TxClient:sendQueryBlockHeight: Unable to sign Tx. Signer is not present.')
			}
			try {			
				const { address } = (await signer.getAccounts())[0]; 
				const signingClient = await SigningStargateClient.connectWithSigner(addr,signer,{registry});
				let msg = this.queryBlockHeight({ value: QueryBlockHeight.fromPartial(value) })
				return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo)
			} catch (e: any) {
				throw new Error('TxClient:sendQueryBlockHeight: Could not broadcast Tx: '+ e.message)
			}
		},
		
		async sendQueryGetReactorRequest({ value, fee, memo }: sendQueryGetReactorRequestParams): Promise<DeliverTxResponse> {
			if (!signer) {
					throw new Error('TxClient:sendQueryGetReactorRequest: Unable to sign Tx. Signer is not present.')
			}
			try {			
				const { address } = (await signer.getAccounts())[0]; 
				const signingClient = await SigningStargateClient.connectWithSigner(addr,signer,{registry});
				let msg = this.queryGetReactorRequest({ value: QueryGetReactorRequest.fromPartial(value) })
				return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo)
			} catch (e: any) {
				throw new Error('TxClient:sendQueryGetReactorRequest: Could not broadcast Tx: '+ e.message)
			}
		},
		
		async sendGridRecord({ value, fee, memo }: sendGridRecordParams): Promise<DeliverTxResponse> {
			if (!signer) {
					throw new Error('TxClient:sendGridRecord: Unable to sign Tx. Signer is not present.')
			}
			try {			
				const { address } = (await signer.getAccounts())[0]; 
				const signingClient = await SigningStargateClient.connectWithSigner(addr,signer,{registry});
				let msg = this.gridRecord({ value: GridRecord.fromPartial(value) })
				return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo)
			} catch (e: any) {
				throw new Error('TxClient:sendGridRecord: Could not broadcast Tx: '+ e.message)
			}
		},
		
		async sendMsgGuildUpdateJoinInfusionMinimumBypassByInvite({ value, fee, memo }: sendMsgGuildUpdateJoinInfusionMinimumBypassByInviteParams): Promise<DeliverTxResponse> {
			if (!signer) {
					throw new Error('TxClient:sendMsgGuildUpdateJoinInfusionMinimumBypassByInvite: Unable to sign Tx. Signer is not present.')
			}
			try {			
				const { address } = (await signer.getAccounts())[0]; 
				const signingClient = await SigningStargateClient.connectWithSigner(addr,signer,{registry});
				let msg = this.msgGuildUpdateJoinInfusionMinimumBypassByInvite({ value: MsgGuildUpdateJoinInfusionMinimumBypassByInvite.fromPartial(value) })
				return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo)
			} catch (e: any) {
				throw new Error('TxClient:sendMsgGuildUpdateJoinInfusionMinimumBypassByInvite: Could not broadcast Tx: '+ e.message)
			}
		},
		
		async sendMsgReactorInfuseResponse({ value, fee, memo }: sendMsgReactorInfuseResponseParams): Promise<DeliverTxResponse> {
			if (!signer) {
					throw new Error('TxClient:sendMsgReactorInfuseResponse: Unable to sign Tx. Signer is not present.')
			}
			try {			
				const { address } = (await signer.getAccounts())[0]; 
				const signingClient = await SigningStargateClient.connectWithSigner(addr,signer,{registry});
				let msg = this.msgReactorInfuseResponse({ value: MsgReactorInfuseResponse.fromPartial(value) })
				return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo)
			} catch (e: any) {
				throw new Error('TxClient:sendMsgReactorInfuseResponse: Could not broadcast Tx: '+ e.message)
			}
		},
		
		async sendMsgStructBuildCancel({ value, fee, memo }: sendMsgStructBuildCancelParams): Promise<DeliverTxResponse> {
			if (!signer) {
					throw new Error('TxClient:sendMsgStructBuildCancel: Unable to sign Tx. Signer is not present.')
			}
			try {			
				const { address } = (await signer.getAccounts())[0]; 
				const signingClient = await SigningStargateClient.connectWithSigner(addr,signer,{registry});
				let msg = this.msgStructBuildCancel({ value: MsgStructBuildCancel.fromPartial(value) })
				return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo)
			} catch (e: any) {
				throw new Error('TxClient:sendMsgStructBuildCancel: Could not broadcast Tx: '+ e.message)
			}
		},
		
		async sendSubstation({ value, fee, memo }: sendSubstationParams): Promise<DeliverTxResponse> {
			if (!signer) {
					throw new Error('TxClient:sendSubstation: Unable to sign Tx. Signer is not present.')
			}
			try {			
				const { address } = (await signer.getAccounts())[0]; 
				const signingClient = await SigningStargateClient.connectWithSigner(addr,signer,{registry});
				let msg = this.substation({ value: Substation.fromPartial(value) })
				return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo)
			} catch (e: any) {
				throw new Error('TxClient:sendSubstation: Could not broadcast Tx: '+ e.message)
			}
		},
		
		async sendMsgGuildUpdateOwnerId({ value, fee, memo }: sendMsgGuildUpdateOwnerIdParams): Promise<DeliverTxResponse> {
			if (!signer) {
					throw new Error('TxClient:sendMsgGuildUpdateOwnerId: Unable to sign Tx. Signer is not present.')
			}
			try {			
				const { address } = (await signer.getAccounts())[0]; 
				const signingClient = await SigningStargateClient.connectWithSigner(addr,signer,{registry});
				let msg = this.msgGuildUpdateOwnerId({ value: MsgGuildUpdateOwnerId.fromPartial(value) })
				return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo)
			} catch (e: any) {
				throw new Error('TxClient:sendMsgGuildUpdateOwnerId: Could not broadcast Tx: '+ e.message)
			}
		},
		
		async sendMsgGuildMembershipInviteDeny({ value, fee, memo }: sendMsgGuildMembershipInviteDenyParams): Promise<DeliverTxResponse> {
			if (!signer) {
					throw new Error('TxClient:sendMsgGuildMembershipInviteDeny: Unable to sign Tx. Signer is not present.')
			}
			try {			
				const { address } = (await signer.getAccounts())[0]; 
				const signingClient = await SigningStargateClient.connectWithSigner(addr,signer,{registry});
				let msg = this.msgGuildMembershipInviteDeny({ value: MsgGuildMembershipInviteDeny.fromPartial(value) })
				return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo)
			} catch (e: any) {
				throw new Error('TxClient:sendMsgGuildMembershipInviteDeny: Could not broadcast Tx: '+ e.message)
			}
		},
		
		async sendMsgSubstationDeleteResponse({ value, fee, memo }: sendMsgSubstationDeleteResponseParams): Promise<DeliverTxResponse> {
			if (!signer) {
					throw new Error('TxClient:sendMsgSubstationDeleteResponse: Unable to sign Tx. Signer is not present.')
			}
			try {			
				const { address } = (await signer.getAccounts())[0]; 
				const signingClient = await SigningStargateClient.connectWithSigner(addr,signer,{registry});
				let msg = this.msgSubstationDeleteResponse({ value: MsgSubstationDeleteResponse.fromPartial(value) })
				return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo)
			} catch (e: any) {
				throw new Error('TxClient:sendMsgSubstationDeleteResponse: Could not broadcast Tx: '+ e.message)
			}
		},
		
		async sendFleet({ value, fee, memo }: sendFleetParams): Promise<DeliverTxResponse> {
			if (!signer) {
					throw new Error('TxClient:sendFleet: Unable to sign Tx. Signer is not present.')
			}
			try {			
				const { address } = (await signer.getAccounts())[0]; 
				const signingClient = await SigningStargateClient.connectWithSigner(addr,signer,{registry});
				let msg = this.fleet({ value: Fleet.fromPartial(value) })
				return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo)
			} catch (e: any) {
				throw new Error('TxClient:sendFleet: Could not broadcast Tx: '+ e.message)
			}
		},
		
		async sendQueryAllPlanetAttributeRequest({ value, fee, memo }: sendQueryAllPlanetAttributeRequestParams): Promise<DeliverTxResponse> {
			if (!signer) {
					throw new Error('TxClient:sendQueryAllPlanetAttributeRequest: Unable to sign Tx. Signer is not present.')
			}
			try {			
				const { address } = (await signer.getAccounts())[0]; 
				const signingClient = await SigningStargateClient.connectWithSigner(addr,signer,{registry});
				let msg = this.queryAllPlanetAttributeRequest({ value: QueryAllPlanetAttributeRequest.fromPartial(value) })
				return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo)
			} catch (e: any) {
				throw new Error('TxClient:sendQueryAllPlanetAttributeRequest: Could not broadcast Tx: '+ e.message)
			}
		},
		
		async sendQueryAllReactorRequest({ value, fee, memo }: sendQueryAllReactorRequestParams): Promise<DeliverTxResponse> {
			if (!signer) {
					throw new Error('TxClient:sendQueryAllReactorRequest: Unable to sign Tx. Signer is not present.')
			}
			try {			
				const { address } = (await signer.getAccounts())[0]; 
				const signingClient = await SigningStargateClient.connectWithSigner(addr,signer,{registry});
				let msg = this.queryAllReactorRequest({ value: QueryAllReactorRequest.fromPartial(value) })
				return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo)
			} catch (e: any) {
				throw new Error('TxClient:sendQueryAllReactorRequest: Could not broadcast Tx: '+ e.message)
			}
		},
		
		async sendEventProvider({ value, fee, memo }: sendEventProviderParams): Promise<DeliverTxResponse> {
			if (!signer) {
					throw new Error('TxClient:sendEventProvider: Unable to sign Tx. Signer is not present.')
			}
			try {			
				const { address } = (await signer.getAccounts())[0]; 
				const signingClient = await SigningStargateClient.connectWithSigner(addr,signer,{registry});
				let msg = this.eventProvider({ value: EventProvider.fromPartial(value) })
				return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo)
			} catch (e: any) {
				throw new Error('TxClient:sendEventProvider: Could not broadcast Tx: '+ e.message)
			}
		},
		
		async sendEventGuildBankRedeemDetail({ value, fee, memo }: sendEventGuildBankRedeemDetailParams): Promise<DeliverTxResponse> {
			if (!signer) {
					throw new Error('TxClient:sendEventGuildBankRedeemDetail: Unable to sign Tx. Signer is not present.')
			}
			try {			
				const { address } = (await signer.getAccounts())[0]; 
				const signingClient = await SigningStargateClient.connectWithSigner(addr,signer,{registry});
				let msg = this.eventGuildBankRedeemDetail({ value: EventGuildBankRedeemDetail.fromPartial(value) })
				return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo)
			} catch (e: any) {
				throw new Error('TxClient:sendEventGuildBankRedeemDetail: Could not broadcast Tx: '+ e.message)
			}
		},
		
		async sendMsgPlayerResume({ value, fee, memo }: sendMsgPlayerResumeParams): Promise<DeliverTxResponse> {
			if (!signer) {
					throw new Error('TxClient:sendMsgPlayerResume: Unable to sign Tx. Signer is not present.')
			}
			try {			
				const { address } = (await signer.getAccounts())[0]; 
				const signingClient = await SigningStargateClient.connectWithSigner(addr,signer,{registry});
				let msg = this.msgPlayerResume({ value: MsgPlayerResume.fromPartial(value) })
				return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo)
			} catch (e: any) {
				throw new Error('TxClient:sendMsgPlayerResume: Could not broadcast Tx: '+ e.message)
			}
		},
		
		async sendMsgProviderWithdrawBalance({ value, fee, memo }: sendMsgProviderWithdrawBalanceParams): Promise<DeliverTxResponse> {
			if (!signer) {
					throw new Error('TxClient:sendMsgProviderWithdrawBalance: Unable to sign Tx. Signer is not present.')
			}
			try {			
				const { address } = (await signer.getAccounts())[0]; 
				const signingClient = await SigningStargateClient.connectWithSigner(addr,signer,{registry});
				let msg = this.msgProviderWithdrawBalance({ value: MsgProviderWithdrawBalance.fromPartial(value) })
				return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo)
			} catch (e: any) {
				throw new Error('TxClient:sendMsgProviderWithdrawBalance: Could not broadcast Tx: '+ e.message)
			}
		},
		
		async sendMsgProviderUpdateDurationMaximum({ value, fee, memo }: sendMsgProviderUpdateDurationMaximumParams): Promise<DeliverTxResponse> {
			if (!signer) {
					throw new Error('TxClient:sendMsgProviderUpdateDurationMaximum: Unable to sign Tx. Signer is not present.')
			}
			try {			
				const { address } = (await signer.getAccounts())[0]; 
				const signingClient = await SigningStargateClient.connectWithSigner(addr,signer,{registry});
				let msg = this.msgProviderUpdateDurationMaximum({ value: MsgProviderUpdateDurationMaximum.fromPartial(value) })
				return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo)
			} catch (e: any) {
				throw new Error('TxClient:sendMsgProviderUpdateDurationMaximum: Could not broadcast Tx: '+ e.message)
			}
		},
		
		async sendQueryAllInfusionRequest({ value, fee, memo }: sendQueryAllInfusionRequestParams): Promise<DeliverTxResponse> {
			if (!signer) {
					throw new Error('TxClient:sendQueryAllInfusionRequest: Unable to sign Tx. Signer is not present.')
			}
			try {			
				const { address } = (await signer.getAccounts())[0]; 
				const signingClient = await SigningStargateClient.connectWithSigner(addr,signer,{registry});
				let msg = this.queryAllInfusionRequest({ value: QueryAllInfusionRequest.fromPartial(value) })
				return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo)
			} catch (e: any) {
				throw new Error('TxClient:sendQueryAllInfusionRequest: Could not broadcast Tx: '+ e.message)
			}
		},
		
		async sendQueryGetProviderResponse({ value, fee, memo }: sendQueryGetProviderResponseParams): Promise<DeliverTxResponse> {
			if (!signer) {
					throw new Error('TxClient:sendQueryGetProviderResponse: Unable to sign Tx. Signer is not present.')
			}
			try {			
				const { address } = (await signer.getAccounts())[0]; 
				const signingClient = await SigningStargateClient.connectWithSigner(addr,signer,{registry});
				let msg = this.queryGetProviderResponse({ value: QueryGetProviderResponse.fromPartial(value) })
				return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo)
			} catch (e: any) {
				throw new Error('TxClient:sendQueryGetProviderResponse: Could not broadcast Tx: '+ e.message)
			}
		},
		
		async sendQueryAllProviderCollateralAddressResponse({ value, fee, memo }: sendQueryAllProviderCollateralAddressResponseParams): Promise<DeliverTxResponse> {
			if (!signer) {
					throw new Error('TxClient:sendQueryAllProviderCollateralAddressResponse: Unable to sign Tx. Signer is not present.')
			}
			try {			
				const { address } = (await signer.getAccounts())[0]; 
				const signingClient = await SigningStargateClient.connectWithSigner(addr,signer,{registry});
				let msg = this.queryAllProviderCollateralAddressResponse({ value: QueryAllProviderCollateralAddressResponse.fromPartial(value) })
				return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo)
			} catch (e: any) {
				throw new Error('TxClient:sendQueryAllProviderCollateralAddressResponse: Could not broadcast Tx: '+ e.message)
			}
		},
		
		async sendNoData({ value, fee, memo }: sendNoDataParams): Promise<DeliverTxResponse> {
			if (!signer) {
					throw new Error('TxClient:sendNoData: Unable to sign Tx. Signer is not present.')
			}
			try {			
				const { address } = (await signer.getAccounts())[0]; 
				const signingClient = await SigningStargateClient.connectWithSigner(addr,signer,{registry});
				let msg = this.noData({ value: NoData.fromPartial(value) })
				return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo)
			} catch (e: any) {
				throw new Error('TxClient:sendNoData: Could not broadcast Tx: '+ e.message)
			}
		},
		
		async sendMsgReactorBeginMigration({ value, fee, memo }: sendMsgReactorBeginMigrationParams): Promise<DeliverTxResponse> {
			if (!signer) {
					throw new Error('TxClient:sendMsgReactorBeginMigration: Unable to sign Tx. Signer is not present.')
			}
			try {			
				const { address } = (await signer.getAccounts())[0]; 
				const signingClient = await SigningStargateClient.connectWithSigner(addr,signer,{registry});
				let msg = this.msgReactorBeginMigration({ value: MsgReactorBeginMigration.fromPartial(value) })
				return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo)
			} catch (e: any) {
				throw new Error('TxClient:sendMsgReactorBeginMigration: Could not broadcast Tx: '+ e.message)
			}
		},
		
		async sendMsgReactorBeginMigrationResponse({ value, fee, memo }: sendMsgReactorBeginMigrationResponseParams): Promise<DeliverTxResponse> {
			if (!signer) {
					throw new Error('TxClient:sendMsgReactorBeginMigrationResponse: Unable to sign Tx. Signer is not present.')
			}
			try {			
				const { address } = (await signer.getAccounts())[0]; 
				const signingClient = await SigningStargateClient.connectWithSigner(addr,signer,{registry});
				let msg = this.msgReactorBeginMigrationResponse({ value: MsgReactorBeginMigrationResponse.fromPartial(value) })
				return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo)
			} catch (e: any) {
				throw new Error('TxClient:sendMsgReactorBeginMigrationResponse: Could not broadcast Tx: '+ e.message)
			}
		},
		
		async sendMsgSubstationPlayerDisconnect({ value, fee, memo }: sendMsgSubstationPlayerDisconnectParams): Promise<DeliverTxResponse> {
			if (!signer) {
					throw new Error('TxClient:sendMsgSubstationPlayerDisconnect: Unable to sign Tx. Signer is not present.')
			}
			try {			
				const { address } = (await signer.getAccounts())[0]; 
				const signingClient = await SigningStargateClient.connectWithSigner(addr,signer,{registry});
				let msg = this.msgSubstationPlayerDisconnect({ value: MsgSubstationPlayerDisconnect.fromPartial(value) })
				return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo)
			} catch (e: any) {
				throw new Error('TxClient:sendMsgSubstationPlayerDisconnect: Could not broadcast Tx: '+ e.message)
			}
		},
		
		async sendGuildMembershipApplication({ value, fee, memo }: sendGuildMembershipApplicationParams): Promise<DeliverTxResponse> {
			if (!signer) {
					throw new Error('TxClient:sendGuildMembershipApplication: Unable to sign Tx. Signer is not present.')
			}
			try {			
				const { address } = (await signer.getAccounts())[0]; 
				const signingClient = await SigningStargateClient.connectWithSigner(addr,signer,{registry});
				let msg = this.guildMembershipApplication({ value: GuildMembershipApplication.fromPartial(value) })
				return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo)
			} catch (e: any) {
				throw new Error('TxClient:sendGuildMembershipApplication: Could not broadcast Tx: '+ e.message)
			}
		},
		
		async sendQueryGetAllocationRequest({ value, fee, memo }: sendQueryGetAllocationRequestParams): Promise<DeliverTxResponse> {
			if (!signer) {
					throw new Error('TxClient:sendQueryGetAllocationRequest: Unable to sign Tx. Signer is not present.')
			}
			try {			
				const { address } = (await signer.getAccounts())[0]; 
				const signingClient = await SigningStargateClient.connectWithSigner(addr,signer,{registry});
				let msg = this.queryGetAllocationRequest({ value: QueryGetAllocationRequest.fromPartial(value) })
				return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo)
			} catch (e: any) {
				throw new Error('TxClient:sendQueryGetAllocationRequest: Could not broadcast Tx: '+ e.message)
			}
		},
		
		async sendEventAgreement({ value, fee, memo }: sendEventAgreementParams): Promise<DeliverTxResponse> {
			if (!signer) {
					throw new Error('TxClient:sendEventAgreement: Unable to sign Tx. Signer is not present.')
			}
			try {			
				const { address } = (await signer.getAccounts())[0]; 
				const signingClient = await SigningStargateClient.connectWithSigner(addr,signer,{registry});
				let msg = this.eventAgreement({ value: EventAgreement.fromPartial(value) })
				return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo)
			} catch (e: any) {
				throw new Error('TxClient:sendEventAgreement: Could not broadcast Tx: '+ e.message)
			}
		},
		
		async sendMsgAllocationDelete({ value, fee, memo }: sendMsgAllocationDeleteParams): Promise<DeliverTxResponse> {
			if (!signer) {
					throw new Error('TxClient:sendMsgAllocationDelete: Unable to sign Tx. Signer is not present.')
			}
			try {			
				const { address } = (await signer.getAccounts())[0]; 
				const signingClient = await SigningStargateClient.connectWithSigner(addr,signer,{registry});
				let msg = this.msgAllocationDelete({ value: MsgAllocationDelete.fromPartial(value) })
				return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo)
			} catch (e: any) {
				throw new Error('TxClient:sendMsgAllocationDelete: Could not broadcast Tx: '+ e.message)
			}
		},
		
		async sendMsgAgreementOpen({ value, fee, memo }: sendMsgAgreementOpenParams): Promise<DeliverTxResponse> {
			if (!signer) {
					throw new Error('TxClient:sendMsgAgreementOpen: Unable to sign Tx. Signer is not present.')
			}
			try {			
				const { address } = (await signer.getAccounts())[0]; 
				const signingClient = await SigningStargateClient.connectWithSigner(addr,signer,{registry});
				let msg = this.msgAgreementOpen({ value: MsgAgreementOpen.fromPartial(value) })
				return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo)
			} catch (e: any) {
				throw new Error('TxClient:sendMsgAgreementOpen: Could not broadcast Tx: '+ e.message)
			}
		},
		
		async sendMsgPlayerSend({ value, fee, memo }: sendMsgPlayerSendParams): Promise<DeliverTxResponse> {
			if (!signer) {
					throw new Error('TxClient:sendMsgPlayerSend: Unable to sign Tx. Signer is not present.')
			}
			try {			
				const { address } = (await signer.getAccounts())[0]; 
				const signingClient = await SigningStargateClient.connectWithSigner(addr,signer,{registry});
				let msg = this.msgPlayerSend({ value: MsgPlayerSend.fromPartial(value) })
				return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo)
			} catch (e: any) {
				throw new Error('TxClient:sendMsgPlayerSend: Could not broadcast Tx: '+ e.message)
			}
		},
		
		async sendQueryGetGuildRequest({ value, fee, memo }: sendQueryGetGuildRequestParams): Promise<DeliverTxResponse> {
			if (!signer) {
					throw new Error('TxClient:sendQueryGetGuildRequest: Unable to sign Tx. Signer is not present.')
			}
			try {			
				const { address } = (await signer.getAccounts())[0]; 
				const signingClient = await SigningStargateClient.connectWithSigner(addr,signer,{registry});
				let msg = this.queryGetGuildRequest({ value: QueryGetGuildRequest.fromPartial(value) })
				return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo)
			} catch (e: any) {
				throw new Error('TxClient:sendQueryGetGuildRequest: Could not broadcast Tx: '+ e.message)
			}
		},
		
		async sendPlanet({ value, fee, memo }: sendPlanetParams): Promise<DeliverTxResponse> {
			if (!signer) {
					throw new Error('TxClient:sendPlanet: Unable to sign Tx. Signer is not present.')
			}
			try {			
				const { address } = (await signer.getAccounts())[0]; 
				const signingClient = await SigningStargateClient.connectWithSigner(addr,signer,{registry});
				let msg = this.planet({ value: Planet.fromPartial(value) })
				return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo)
			} catch (e: any) {
				throw new Error('TxClient:sendPlanet: Could not broadcast Tx: '+ e.message)
			}
		},
		
		async sendMsgAllocationTransferResponse({ value, fee, memo }: sendMsgAllocationTransferResponseParams): Promise<DeliverTxResponse> {
			if (!signer) {
					throw new Error('TxClient:sendMsgAllocationTransferResponse: Unable to sign Tx. Signer is not present.')
			}
			try {			
				const { address } = (await signer.getAccounts())[0]; 
				const signingClient = await SigningStargateClient.connectWithSigner(addr,signer,{registry});
				let msg = this.msgAllocationTransferResponse({ value: MsgAllocationTransferResponse.fromPartial(value) })
				return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo)
			} catch (e: any) {
				throw new Error('TxClient:sendMsgAllocationTransferResponse: Could not broadcast Tx: '+ e.message)
			}
		},
		
		async sendMsgStructDefenseClear({ value, fee, memo }: sendMsgStructDefenseClearParams): Promise<DeliverTxResponse> {
			if (!signer) {
					throw new Error('TxClient:sendMsgStructDefenseClear: Unable to sign Tx. Signer is not present.')
			}
			try {			
				const { address } = (await signer.getAccounts())[0]; 
				const signingClient = await SigningStargateClient.connectWithSigner(addr,signer,{registry});
				let msg = this.msgStructDefenseClear({ value: MsgStructDefenseClear.fromPartial(value) })
				return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo)
			} catch (e: any) {
				throw new Error('TxClient:sendMsgStructDefenseClear: Could not broadcast Tx: '+ e.message)
			}
		},
		
		async sendQueryAllAgreementResponse({ value, fee, memo }: sendQueryAllAgreementResponseParams): Promise<DeliverTxResponse> {
			if (!signer) {
					throw new Error('TxClient:sendQueryAllAgreementResponse: Unable to sign Tx. Signer is not present.')
			}
			try {			
				const { address } = (await signer.getAccounts())[0]; 
				const signingClient = await SigningStargateClient.connectWithSigner(addr,signer,{registry});
				let msg = this.queryAllAgreementResponse({ value: QueryAllAgreementResponse.fromPartial(value) })
				return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo)
			} catch (e: any) {
				throw new Error('TxClient:sendQueryAllAgreementResponse: Could not broadcast Tx: '+ e.message)
			}
		},
		
		async sendQueryAllPermissionByObjectRequest({ value, fee, memo }: sendQueryAllPermissionByObjectRequestParams): Promise<DeliverTxResponse> {
			if (!signer) {
					throw new Error('TxClient:sendQueryAllPermissionByObjectRequest: Unable to sign Tx. Signer is not present.')
			}
			try {			
				const { address } = (await signer.getAccounts())[0]; 
				const signingClient = await SigningStargateClient.connectWithSigner(addr,signer,{registry});
				let msg = this.queryAllPermissionByObjectRequest({ value: QueryAllPermissionByObjectRequest.fromPartial(value) })
				return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo)
			} catch (e: any) {
				throw new Error('TxClient:sendQueryAllPermissionByObjectRequest: Could not broadcast Tx: '+ e.message)
			}
		},
		
		async sendQueryAllStructAttributeResponse({ value, fee, memo }: sendQueryAllStructAttributeResponseParams): Promise<DeliverTxResponse> {
			if (!signer) {
					throw new Error('TxClient:sendQueryAllStructAttributeResponse: Unable to sign Tx. Signer is not present.')
			}
			try {			
				const { address } = (await signer.getAccounts())[0]; 
				const signingClient = await SigningStargateClient.connectWithSigner(addr,signer,{registry});
				let msg = this.queryAllStructAttributeResponse({ value: QueryAllStructAttributeResponse.fromPartial(value) })
				return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo)
			} catch (e: any) {
				throw new Error('TxClient:sendQueryAllStructAttributeResponse: Could not broadcast Tx: '+ e.message)
			}
		},
		
		async sendEventAlphaDefuseDetail({ value, fee, memo }: sendEventAlphaDefuseDetailParams): Promise<DeliverTxResponse> {
			if (!signer) {
					throw new Error('TxClient:sendEventAlphaDefuseDetail: Unable to sign Tx. Signer is not present.')
			}
			try {			
				const { address } = (await signer.getAccounts())[0]; 
				const signingClient = await SigningStargateClient.connectWithSigner(addr,signer,{registry});
				let msg = this.eventAlphaDefuseDetail({ value: EventAlphaDefuseDetail.fromPartial(value) })
				return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo)
			} catch (e: any) {
				throw new Error('TxClient:sendEventAlphaDefuseDetail: Could not broadcast Tx: '+ e.message)
			}
		},
		
		async sendMsgGuildMembershipJoinProxy({ value, fee, memo }: sendMsgGuildMembershipJoinProxyParams): Promise<DeliverTxResponse> {
			if (!signer) {
					throw new Error('TxClient:sendMsgGuildMembershipJoinProxy: Unable to sign Tx. Signer is not present.')
			}
			try {			
				const { address } = (await signer.getAccounts())[0]; 
				const signingClient = await SigningStargateClient.connectWithSigner(addr,signer,{registry});
				let msg = this.msgGuildMembershipJoinProxy({ value: MsgGuildMembershipJoinProxy.fromPartial(value) })
				return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo)
			} catch (e: any) {
				throw new Error('TxClient:sendMsgGuildMembershipJoinProxy: Could not broadcast Tx: '+ e.message)
			}
		},
		
		async sendMsgStructBuildInitiate({ value, fee, memo }: sendMsgStructBuildInitiateParams): Promise<DeliverTxResponse> {
			if (!signer) {
					throw new Error('TxClient:sendMsgStructBuildInitiate: Unable to sign Tx. Signer is not present.')
			}
			try {			
				const { address } = (await signer.getAccounts())[0]; 
				const signingClient = await SigningStargateClient.connectWithSigner(addr,signer,{registry});
				let msg = this.msgStructBuildInitiate({ value: MsgStructBuildInitiate.fromPartial(value) })
				return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo)
			} catch (e: any) {
				throw new Error('TxClient:sendMsgStructBuildInitiate: Could not broadcast Tx: '+ e.message)
			}
		},
		
		async sendGenesisState({ value, fee, memo }: sendGenesisStateParams): Promise<DeliverTxResponse> {
			if (!signer) {
					throw new Error('TxClient:sendGenesisState: Unable to sign Tx. Signer is not present.')
			}
			try {			
				const { address } = (await signer.getAccounts())[0]; 
				const signingClient = await SigningStargateClient.connectWithSigner(addr,signer,{registry});
				let msg = this.genesisState({ value: GenesisState.fromPartial(value) })
				return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo)
			} catch (e: any) {
				throw new Error('TxClient:sendGenesisState: Could not broadcast Tx: '+ e.message)
			}
		},
		
		async sendQueryGetFleetResponse({ value, fee, memo }: sendQueryGetFleetResponseParams): Promise<DeliverTxResponse> {
			if (!signer) {
					throw new Error('TxClient:sendQueryGetFleetResponse: Unable to sign Tx. Signer is not present.')
			}
			try {			
				const { address } = (await signer.getAccounts())[0]; 
				const signingClient = await SigningStargateClient.connectWithSigner(addr,signer,{registry});
				let msg = this.queryGetFleetResponse({ value: QueryGetFleetResponse.fromPartial(value) })
				return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo)
			} catch (e: any) {
				throw new Error('TxClient:sendQueryGetFleetResponse: Could not broadcast Tx: '+ e.message)
			}
		},
		
		async sendQueryAllGuildRequest({ value, fee, memo }: sendQueryAllGuildRequestParams): Promise<DeliverTxResponse> {
			if (!signer) {
					throw new Error('TxClient:sendQueryAllGuildRequest: Unable to sign Tx. Signer is not present.')
			}
			try {			
				const { address } = (await signer.getAccounts())[0]; 
				const signingClient = await SigningStargateClient.connectWithSigner(addr,signer,{registry});
				let msg = this.queryAllGuildRequest({ value: QueryAllGuildRequest.fromPartial(value) })
				return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo)
			} catch (e: any) {
				throw new Error('TxClient:sendQueryAllGuildRequest: Could not broadcast Tx: '+ e.message)
			}
		},
		
		async sendQueryGetPlanetAttributeResponse({ value, fee, memo }: sendQueryGetPlanetAttributeResponseParams): Promise<DeliverTxResponse> {
			if (!signer) {
					throw new Error('TxClient:sendQueryGetPlanetAttributeResponse: Unable to sign Tx. Signer is not present.')
			}
			try {			
				const { address } = (await signer.getAccounts())[0]; 
				const signingClient = await SigningStargateClient.connectWithSigner(addr,signer,{registry});
				let msg = this.queryGetPlanetAttributeResponse({ value: QueryGetPlanetAttributeResponse.fromPartial(value) })
				return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo)
			} catch (e: any) {
				throw new Error('TxClient:sendQueryGetPlanetAttributeResponse: Could not broadcast Tx: '+ e.message)
			}
		},
		
		async sendMsgGuildBankMintResponse({ value, fee, memo }: sendMsgGuildBankMintResponseParams): Promise<DeliverTxResponse> {
			if (!signer) {
					throw new Error('TxClient:sendMsgGuildBankMintResponse: Unable to sign Tx. Signer is not present.')
			}
			try {			
				const { address } = (await signer.getAccounts())[0]; 
				const signingClient = await SigningStargateClient.connectWithSigner(addr,signer,{registry});
				let msg = this.msgGuildBankMintResponse({ value: MsgGuildBankMintResponse.fromPartial(value) })
				return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo)
			} catch (e: any) {
				throw new Error('TxClient:sendMsgGuildBankMintResponse: Could not broadcast Tx: '+ e.message)
			}
		},
		
		async sendMsgGuildBankConfiscateAndBurn({ value, fee, memo }: sendMsgGuildBankConfiscateAndBurnParams): Promise<DeliverTxResponse> {
			if (!signer) {
					throw new Error('TxClient:sendMsgGuildBankConfiscateAndBurn: Unable to sign Tx. Signer is not present.')
			}
			try {			
				const { address } = (await signer.getAccounts())[0]; 
				const signingClient = await SigningStargateClient.connectWithSigner(addr,signer,{registry});
				let msg = this.msgGuildBankConfiscateAndBurn({ value: MsgGuildBankConfiscateAndBurn.fromPartial(value) })
				return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo)
			} catch (e: any) {
				throw new Error('TxClient:sendMsgGuildBankConfiscateAndBurn: Could not broadcast Tx: '+ e.message)
			}
		},
		
		async sendMsgSubstationPlayerConnect({ value, fee, memo }: sendMsgSubstationPlayerConnectParams): Promise<DeliverTxResponse> {
			if (!signer) {
					throw new Error('TxClient:sendMsgSubstationPlayerConnect: Unable to sign Tx. Signer is not present.')
			}
			try {			
				const { address } = (await signer.getAccounts())[0]; 
				const signingClient = await SigningStargateClient.connectWithSigner(addr,signer,{registry});
				let msg = this.msgSubstationPlayerConnect({ value: MsgSubstationPlayerConnect.fromPartial(value) })
				return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo)
			} catch (e: any) {
				throw new Error('TxClient:sendMsgSubstationPlayerConnect: Could not broadcast Tx: '+ e.message)
			}
		},
		
		async sendQueryAllGuildMembershipApplicationResponse({ value, fee, memo }: sendQueryAllGuildMembershipApplicationResponseParams): Promise<DeliverTxResponse> {
			if (!signer) {
					throw new Error('TxClient:sendQueryAllGuildMembershipApplicationResponse: Unable to sign Tx. Signer is not present.')
			}
			try {			
				const { address } = (await signer.getAccounts())[0]; 
				const signingClient = await SigningStargateClient.connectWithSigner(addr,signer,{registry});
				let msg = this.queryAllGuildMembershipApplicationResponse({ value: QueryAllGuildMembershipApplicationResponse.fromPartial(value) })
				return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo)
			} catch (e: any) {
				throw new Error('TxClient:sendQueryAllGuildMembershipApplicationResponse: Could not broadcast Tx: '+ e.message)
			}
		},
		
		async sendQueryAllProviderRequest({ value, fee, memo }: sendQueryAllProviderRequestParams): Promise<DeliverTxResponse> {
			if (!signer) {
					throw new Error('TxClient:sendQueryAllProviderRequest: Unable to sign Tx. Signer is not present.')
			}
			try {			
				const { address } = (await signer.getAccounts())[0]; 
				const signingClient = await SigningStargateClient.connectWithSigner(addr,signer,{registry});
				let msg = this.queryAllProviderRequest({ value: QueryAllProviderRequest.fromPartial(value) })
				return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo)
			} catch (e: any) {
				throw new Error('TxClient:sendQueryAllProviderRequest: Could not broadcast Tx: '+ e.message)
			}
		},
		
		async sendQueryGetProviderByEarningsAddressRequest({ value, fee, memo }: sendQueryGetProviderByEarningsAddressRequestParams): Promise<DeliverTxResponse> {
			if (!signer) {
					throw new Error('TxClient:sendQueryGetProviderByEarningsAddressRequest: Unable to sign Tx. Signer is not present.')
			}
			try {			
				const { address } = (await signer.getAccounts())[0]; 
				const signingClient = await SigningStargateClient.connectWithSigner(addr,signer,{registry});
				let msg = this.queryGetProviderByEarningsAddressRequest({ value: QueryGetProviderByEarningsAddressRequest.fromPartial(value) })
				return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo)
			} catch (e: any) {
				throw new Error('TxClient:sendQueryGetProviderByEarningsAddressRequest: Could not broadcast Tx: '+ e.message)
			}
		},
		
		async sendEventPlayer({ value, fee, memo }: sendEventPlayerParams): Promise<DeliverTxResponse> {
			if (!signer) {
					throw new Error('TxClient:sendEventPlayer: Unable to sign Tx. Signer is not present.')
			}
			try {			
				const { address } = (await signer.getAccounts())[0]; 
				const signingClient = await SigningStargateClient.connectWithSigner(addr,signer,{registry});
				let msg = this.eventPlayer({ value: EventPlayer.fromPartial(value) })
				return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo)
			} catch (e: any) {
				throw new Error('TxClient:sendEventPlayer: Could not broadcast Tx: '+ e.message)
			}
		},
		
		async sendEventProviderRevokeGuild({ value, fee, memo }: sendEventProviderRevokeGuildParams): Promise<DeliverTxResponse> {
			if (!signer) {
					throw new Error('TxClient:sendEventProviderRevokeGuild: Unable to sign Tx. Signer is not present.')
			}
			try {			
				const { address } = (await signer.getAccounts())[0]; 
				const signingClient = await SigningStargateClient.connectWithSigner(addr,signer,{registry});
				let msg = this.eventProviderRevokeGuild({ value: EventProviderRevokeGuild.fromPartial(value) })
				return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo)
			} catch (e: any) {
				throw new Error('TxClient:sendEventProviderRevokeGuild: Could not broadcast Tx: '+ e.message)
			}
		},
		
		async sendMsgAddressRegisterResponse({ value, fee, memo }: sendMsgAddressRegisterResponseParams): Promise<DeliverTxResponse> {
			if (!signer) {
					throw new Error('TxClient:sendMsgAddressRegisterResponse: Unable to sign Tx. Signer is not present.')
			}
			try {			
				const { address } = (await signer.getAccounts())[0]; 
				const signingClient = await SigningStargateClient.connectWithSigner(addr,signer,{registry});
				let msg = this.msgAddressRegisterResponse({ value: MsgAddressRegisterResponse.fromPartial(value) })
				return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo)
			} catch (e: any) {
				throw new Error('TxClient:sendMsgAddressRegisterResponse: Could not broadcast Tx: '+ e.message)
			}
		},
		
		async sendMsgPermissionGrantOnObject({ value, fee, memo }: sendMsgPermissionGrantOnObjectParams): Promise<DeliverTxResponse> {
			if (!signer) {
					throw new Error('TxClient:sendMsgPermissionGrantOnObject: Unable to sign Tx. Signer is not present.')
			}
			try {			
				const { address } = (await signer.getAccounts())[0]; 
				const signingClient = await SigningStargateClient.connectWithSigner(addr,signer,{registry});
				let msg = this.msgPermissionGrantOnObject({ value: MsgPermissionGrantOnObject.fromPartial(value) })
				return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo)
			} catch (e: any) {
				throw new Error('TxClient:sendMsgPermissionGrantOnObject: Could not broadcast Tx: '+ e.message)
			}
		},
		
		async sendQueryGetPlayerRequest({ value, fee, memo }: sendQueryGetPlayerRequestParams): Promise<DeliverTxResponse> {
			if (!signer) {
					throw new Error('TxClient:sendQueryGetPlayerRequest: Unable to sign Tx. Signer is not present.')
			}
			try {			
				const { address } = (await signer.getAccounts())[0]; 
				const signingClient = await SigningStargateClient.connectWithSigner(addr,signer,{registry});
				let msg = this.queryGetPlayerRequest({ value: QueryGetPlayerRequest.fromPartial(value) })
				return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo)
			} catch (e: any) {
				throw new Error('TxClient:sendQueryGetPlayerRequest: Could not broadcast Tx: '+ e.message)
			}
		},
		
		async sendQueryAllStructTypeResponse({ value, fee, memo }: sendQueryAllStructTypeResponseParams): Promise<DeliverTxResponse> {
			if (!signer) {
					throw new Error('TxClient:sendQueryAllStructTypeResponse: Unable to sign Tx. Signer is not present.')
			}
			try {			
				const { address } = (await signer.getAccounts())[0]; 
				const signingClient = await SigningStargateClient.connectWithSigner(addr,signer,{registry});
				let msg = this.queryAllStructTypeResponse({ value: QueryAllStructTypeResponse.fromPartial(value) })
				return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo)
			} catch (e: any) {
				throw new Error('TxClient:sendQueryAllStructTypeResponse: Could not broadcast Tx: '+ e.message)
			}
		},
		
		async sendMsgPlanetRaidCompleteResponse({ value, fee, memo }: sendMsgPlanetRaidCompleteResponseParams): Promise<DeliverTxResponse> {
			if (!signer) {
					throw new Error('TxClient:sendMsgPlanetRaidCompleteResponse: Unable to sign Tx. Signer is not present.')
			}
			try {			
				const { address } = (await signer.getAccounts())[0]; 
				const signingClient = await SigningStargateClient.connectWithSigner(addr,signer,{registry});
				let msg = this.msgPlanetRaidCompleteResponse({ value: MsgPlanetRaidCompleteResponse.fromPartial(value) })
				return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo)
			} catch (e: any) {
				throw new Error('TxClient:sendMsgPlanetRaidCompleteResponse: Could not broadcast Tx: '+ e.message)
			}
		},
		
		async sendMsgReactorDefuse({ value, fee, memo }: sendMsgReactorDefuseParams): Promise<DeliverTxResponse> {
			if (!signer) {
					throw new Error('TxClient:sendMsgReactorDefuse: Unable to sign Tx. Signer is not present.')
			}
			try {			
				const { address } = (await signer.getAccounts())[0]; 
				const signingClient = await SigningStargateClient.connectWithSigner(addr,signer,{registry});
				let msg = this.msgReactorDefuse({ value: MsgReactorDefuse.fromPartial(value) })
				return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo)
			} catch (e: any) {
				throw new Error('TxClient:sendMsgReactorDefuse: Could not broadcast Tx: '+ e.message)
			}
		},
		
		async sendMsgStructStealthActivate({ value, fee, memo }: sendMsgStructStealthActivateParams): Promise<DeliverTxResponse> {
			if (!signer) {
					throw new Error('TxClient:sendMsgStructStealthActivate: Unable to sign Tx. Signer is not present.')
			}
			try {			
				const { address } = (await signer.getAccounts())[0]; 
				const signingClient = await SigningStargateClient.connectWithSigner(addr,signer,{registry});
				let msg = this.msgStructStealthActivate({ value: MsgStructStealthActivate.fromPartial(value) })
				return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo)
			} catch (e: any) {
				throw new Error('TxClient:sendMsgStructStealthActivate: Could not broadcast Tx: '+ e.message)
			}
		},
		
		async sendQueryGetGuildBankCollateralAddressRequest({ value, fee, memo }: sendQueryGetGuildBankCollateralAddressRequestParams): Promise<DeliverTxResponse> {
			if (!signer) {
					throw new Error('TxClient:sendQueryGetGuildBankCollateralAddressRequest: Unable to sign Tx. Signer is not present.')
			}
			try {			
				const { address } = (await signer.getAccounts())[0]; 
				const signingClient = await SigningStargateClient.connectWithSigner(addr,signer,{registry});
				let msg = this.queryGetGuildBankCollateralAddressRequest({ value: QueryGetGuildBankCollateralAddressRequest.fromPartial(value) })
				return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo)
			} catch (e: any) {
				throw new Error('TxClient:sendQueryGetGuildBankCollateralAddressRequest: Could not broadcast Tx: '+ e.message)
			}
		},
		
		async sendQueryAllGuildMembershipApplicationRequest({ value, fee, memo }: sendQueryAllGuildMembershipApplicationRequestParams): Promise<DeliverTxResponse> {
			if (!signer) {
					throw new Error('TxClient:sendQueryAllGuildMembershipApplicationRequest: Unable to sign Tx. Signer is not present.')
			}
			try {			
				const { address } = (await signer.getAccounts())[0]; 
				const signingClient = await SigningStargateClient.connectWithSigner(addr,signer,{registry});
				let msg = this.queryAllGuildMembershipApplicationRequest({ value: QueryAllGuildMembershipApplicationRequest.fromPartial(value) })
				return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo)
			} catch (e: any) {
				throw new Error('TxClient:sendQueryAllGuildMembershipApplicationRequest: Could not broadcast Tx: '+ e.message)
			}
		},
		
		async sendQueryAllPermissionRequest({ value, fee, memo }: sendQueryAllPermissionRequestParams): Promise<DeliverTxResponse> {
			if (!signer) {
					throw new Error('TxClient:sendQueryAllPermissionRequest: Unable to sign Tx. Signer is not present.')
			}
			try {			
				const { address } = (await signer.getAccounts())[0]; 
				const signingClient = await SigningStargateClient.connectWithSigner(addr,signer,{registry});
				let msg = this.queryAllPermissionRequest({ value: QueryAllPermissionRequest.fromPartial(value) })
				return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo)
			} catch (e: any) {
				throw new Error('TxClient:sendQueryAllPermissionRequest: Could not broadcast Tx: '+ e.message)
			}
		},
		
		async sendQueryAllProviderEarningsAddressResponse({ value, fee, memo }: sendQueryAllProviderEarningsAddressResponseParams): Promise<DeliverTxResponse> {
			if (!signer) {
					throw new Error('TxClient:sendQueryAllProviderEarningsAddressResponse: Unable to sign Tx. Signer is not present.')
			}
			try {			
				const { address } = (await signer.getAccounts())[0]; 
				const signingClient = await SigningStargateClient.connectWithSigner(addr,signer,{registry});
				let msg = this.queryAllProviderEarningsAddressResponse({ value: QueryAllProviderEarningsAddressResponse.fromPartial(value) })
				return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo)
			} catch (e: any) {
				throw new Error('TxClient:sendQueryAllProviderEarningsAddressResponse: Could not broadcast Tx: '+ e.message)
			}
		},
		
		async sendStruct({ value, fee, memo }: sendStructParams): Promise<DeliverTxResponse> {
			if (!signer) {
					throw new Error('TxClient:sendStruct: Unable to sign Tx. Signer is not present.')
			}
			try {			
				const { address } = (await signer.getAccounts())[0]; 
				const signingClient = await SigningStargateClient.connectWithSigner(addr,signer,{registry});
				let msg = this.struct({ value: Struct.fromPartial(value) })
				return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo)
			} catch (e: any) {
				throw new Error('TxClient:sendStruct: Could not broadcast Tx: '+ e.message)
			}
		},
		
		async sendEventProviderAddress({ value, fee, memo }: sendEventProviderAddressParams): Promise<DeliverTxResponse> {
			if (!signer) {
					throw new Error('TxClient:sendEventProviderAddress: Unable to sign Tx. Signer is not present.')
			}
			try {			
				const { address } = (await signer.getAccounts())[0]; 
				const signingClient = await SigningStargateClient.connectWithSigner(addr,signer,{registry});
				let msg = this.eventProviderAddress({ value: EventProviderAddress.fromPartial(value) })
				return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo)
			} catch (e: any) {
				throw new Error('TxClient:sendEventProviderAddress: Could not broadcast Tx: '+ e.message)
			}
		},
		
		async sendMsgSubstationAllocationDisconnect({ value, fee, memo }: sendMsgSubstationAllocationDisconnectParams): Promise<DeliverTxResponse> {
			if (!signer) {
					throw new Error('TxClient:sendMsgSubstationAllocationDisconnect: Unable to sign Tx. Signer is not present.')
			}
			try {			
				const { address } = (await signer.getAccounts())[0]; 
				const signingClient = await SigningStargateClient.connectWithSigner(addr,signer,{registry});
				let msg = this.msgSubstationAllocationDisconnect({ value: MsgSubstationAllocationDisconnect.fromPartial(value) })
				return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo)
			} catch (e: any) {
				throw new Error('TxClient:sendMsgSubstationAllocationDisconnect: Could not broadcast Tx: '+ e.message)
			}
		},
		
		async sendQueryGetAddressRequest({ value, fee, memo }: sendQueryGetAddressRequestParams): Promise<DeliverTxResponse> {
			if (!signer) {
					throw new Error('TxClient:sendQueryGetAddressRequest: Unable to sign Tx. Signer is not present.')
			}
			try {			
				const { address } = (await signer.getAccounts())[0]; 
				const signingClient = await SigningStargateClient.connectWithSigner(addr,signer,{registry});
				let msg = this.queryGetAddressRequest({ value: QueryGetAddressRequest.fromPartial(value) })
				return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo)
			} catch (e: any) {
				throw new Error('TxClient:sendQueryGetAddressRequest: Could not broadcast Tx: '+ e.message)
			}
		},
		
		async sendEventPlayerHalted({ value, fee, memo }: sendEventPlayerHaltedParams): Promise<DeliverTxResponse> {
			if (!signer) {
					throw new Error('TxClient:sendEventPlayerHalted: Unable to sign Tx. Signer is not present.')
			}
			try {			
				const { address } = (await signer.getAccounts())[0]; 
				const signingClient = await SigningStargateClient.connectWithSigner(addr,signer,{registry});
				let msg = this.eventPlayerHalted({ value: EventPlayerHalted.fromPartial(value) })
				return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo)
			} catch (e: any) {
				throw new Error('TxClient:sendEventPlayerHalted: Could not broadcast Tx: '+ e.message)
			}
		},
		
		async sendMsgUpdateParams({ value, fee, memo }: sendMsgUpdateParamsParams): Promise<DeliverTxResponse> {
			if (!signer) {
					throw new Error('TxClient:sendMsgUpdateParams: Unable to sign Tx. Signer is not present.')
			}
			try {			
				const { address } = (await signer.getAccounts())[0]; 
				const signingClient = await SigningStargateClient.connectWithSigner(addr,signer,{registry});
				let msg = this.msgUpdateParams({ value: MsgUpdateParams.fromPartial(value) })
				return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo)
			} catch (e: any) {
				throw new Error('TxClient:sendMsgUpdateParams: Could not broadcast Tx: '+ e.message)
			}
		},
		
		async sendMsgGuildBankMint({ value, fee, memo }: sendMsgGuildBankMintParams): Promise<DeliverTxResponse> {
			if (!signer) {
					throw new Error('TxClient:sendMsgGuildBankMint: Unable to sign Tx. Signer is not present.')
			}
			try {			
				const { address } = (await signer.getAccounts())[0]; 
				const signingClient = await SigningStargateClient.connectWithSigner(addr,signer,{registry});
				let msg = this.msgGuildBankMint({ value: MsgGuildBankMint.fromPartial(value) })
				return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo)
			} catch (e: any) {
				throw new Error('TxClient:sendMsgGuildBankMint: Could not broadcast Tx: '+ e.message)
			}
		},
		
		async sendMsgGuildUpdateJoinInfusionMinimum({ value, fee, memo }: sendMsgGuildUpdateJoinInfusionMinimumParams): Promise<DeliverTxResponse> {
			if (!signer) {
					throw new Error('TxClient:sendMsgGuildUpdateJoinInfusionMinimum: Unable to sign Tx. Signer is not present.')
			}
			try {			
				const { address } = (await signer.getAccounts())[0]; 
				const signingClient = await SigningStargateClient.connectWithSigner(addr,signer,{registry});
				let msg = this.msgGuildUpdateJoinInfusionMinimum({ value: MsgGuildUpdateJoinInfusionMinimum.fromPartial(value) })
				return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo)
			} catch (e: any) {
				throw new Error('TxClient:sendMsgGuildUpdateJoinInfusionMinimum: Could not broadcast Tx: '+ e.message)
			}
		},
		
		async sendQueryAllPermissionResponse({ value, fee, memo }: sendQueryAllPermissionResponseParams): Promise<DeliverTxResponse> {
			if (!signer) {
					throw new Error('TxClient:sendQueryAllPermissionResponse: Unable to sign Tx. Signer is not present.')
			}
			try {			
				const { address } = (await signer.getAccounts())[0]; 
				const signingClient = await SigningStargateClient.connectWithSigner(addr,signer,{registry});
				let msg = this.queryAllPermissionResponse({ value: QueryAllPermissionResponse.fromPartial(value) })
				return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo)
			} catch (e: any) {
				throw new Error('TxClient:sendQueryAllPermissionResponse: Could not broadcast Tx: '+ e.message)
			}
		},
		
		async sendEventAllocation({ value, fee, memo }: sendEventAllocationParams): Promise<DeliverTxResponse> {
			if (!signer) {
					throw new Error('TxClient:sendEventAllocation: Unable to sign Tx. Signer is not present.')
			}
			try {			
				const { address } = (await signer.getAccounts())[0]; 
				const signingClient = await SigningStargateClient.connectWithSigner(addr,signer,{registry});
				let msg = this.eventAllocation({ value: EventAllocation.fromPartial(value) })
				return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo)
			} catch (e: any) {
				throw new Error('TxClient:sendEventAllocation: Could not broadcast Tx: '+ e.message)
			}
		},
		
		async sendEventTimeDetail({ value, fee, memo }: sendEventTimeDetailParams): Promise<DeliverTxResponse> {
			if (!signer) {
					throw new Error('TxClient:sendEventTimeDetail: Unable to sign Tx. Signer is not present.')
			}
			try {			
				const { address } = (await signer.getAccounts())[0]; 
				const signingClient = await SigningStargateClient.connectWithSigner(addr,signer,{registry});
				let msg = this.eventTimeDetail({ value: EventTimeDetail.fromPartial(value) })
				return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo)
			} catch (e: any) {
				throw new Error('TxClient:sendEventTimeDetail: Could not broadcast Tx: '+ e.message)
			}
		},
		
		async sendMsgPlayerUpdatePrimaryAddress({ value, fee, memo }: sendMsgPlayerUpdatePrimaryAddressParams): Promise<DeliverTxResponse> {
			if (!signer) {
					throw new Error('TxClient:sendMsgPlayerUpdatePrimaryAddress: Unable to sign Tx. Signer is not present.')
			}
			try {			
				const { address } = (await signer.getAccounts())[0]; 
				const signingClient = await SigningStargateClient.connectWithSigner(addr,signer,{registry});
				let msg = this.msgPlayerUpdatePrimaryAddress({ value: MsgPlayerUpdatePrimaryAddress.fromPartial(value) })
				return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo)
			} catch (e: any) {
				throw new Error('TxClient:sendMsgPlayerUpdatePrimaryAddress: Could not broadcast Tx: '+ e.message)
			}
		},
		
		async sendQueryGetAgreementRequest({ value, fee, memo }: sendQueryGetAgreementRequestParams): Promise<DeliverTxResponse> {
			if (!signer) {
					throw new Error('TxClient:sendQueryGetAgreementRequest: Unable to sign Tx. Signer is not present.')
			}
			try {			
				const { address } = (await signer.getAccounts())[0]; 
				const signingClient = await SigningStargateClient.connectWithSigner(addr,signer,{registry});
				let msg = this.queryGetAgreementRequest({ value: QueryGetAgreementRequest.fromPartial(value) })
				return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo)
			} catch (e: any) {
				throw new Error('TxClient:sendQueryGetAgreementRequest: Could not broadcast Tx: '+ e.message)
			}
		},
		
		async sendMsgPermissionGrantOnAddress({ value, fee, memo }: sendMsgPermissionGrantOnAddressParams): Promise<DeliverTxResponse> {
			if (!signer) {
					throw new Error('TxClient:sendMsgPermissionGrantOnAddress: Unable to sign Tx. Signer is not present.')
			}
			try {			
				const { address } = (await signer.getAccounts())[0]; 
				const signingClient = await SigningStargateClient.connectWithSigner(addr,signer,{registry});
				let msg = this.msgPermissionGrantOnAddress({ value: MsgPermissionGrantOnAddress.fromPartial(value) })
				return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo)
			} catch (e: any) {
				throw new Error('TxClient:sendMsgPermissionGrantOnAddress: Could not broadcast Tx: '+ e.message)
			}
		},
		
		async sendMsgPermissionSetOnAddress({ value, fee, memo }: sendMsgPermissionSetOnAddressParams): Promise<DeliverTxResponse> {
			if (!signer) {
					throw new Error('TxClient:sendMsgPermissionSetOnAddress: Unable to sign Tx. Signer is not present.')
			}
			try {			
				const { address } = (await signer.getAccounts())[0]; 
				const signingClient = await SigningStargateClient.connectWithSigner(addr,signer,{registry});
				let msg = this.msgPermissionSetOnAddress({ value: MsgPermissionSetOnAddress.fromPartial(value) })
				return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo)
			} catch (e: any) {
				throw new Error('TxClient:sendMsgPermissionSetOnAddress: Could not broadcast Tx: '+ e.message)
			}
		},
		
		async sendEventAddressActivity({ value, fee, memo }: sendEventAddressActivityParams): Promise<DeliverTxResponse> {
			if (!signer) {
					throw new Error('TxClient:sendEventAddressActivity: Unable to sign Tx. Signer is not present.')
			}
			try {			
				const { address } = (await signer.getAccounts())[0]; 
				const signingClient = await SigningStargateClient.connectWithSigner(addr,signer,{registry});
				let msg = this.eventAddressActivity({ value: EventAddressActivity.fromPartial(value) })
				return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo)
			} catch (e: any) {
				throw new Error('TxClient:sendEventAddressActivity: Could not broadcast Tx: '+ e.message)
			}
		},
		
		async sendEventRaid({ value, fee, memo }: sendEventRaidParams): Promise<DeliverTxResponse> {
			if (!signer) {
					throw new Error('TxClient:sendEventRaid: Unable to sign Tx. Signer is not present.')
			}
			try {			
				const { address } = (await signer.getAccounts())[0]; 
				const signingClient = await SigningStargateClient.connectWithSigner(addr,signer,{registry});
				let msg = this.eventRaid({ value: EventRaid.fromPartial(value) })
				return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo)
			} catch (e: any) {
				throw new Error('TxClient:sendEventRaid: Could not broadcast Tx: '+ e.message)
			}
		},
		
		async sendMsgAllocationUpdateResponse({ value, fee, memo }: sendMsgAllocationUpdateResponseParams): Promise<DeliverTxResponse> {
			if (!signer) {
					throw new Error('TxClient:sendMsgAllocationUpdateResponse: Unable to sign Tx. Signer is not present.')
			}
			try {			
				const { address } = (await signer.getAccounts())[0]; 
				const signingClient = await SigningStargateClient.connectWithSigner(addr,signer,{registry});
				let msg = this.msgAllocationUpdateResponse({ value: MsgAllocationUpdateResponse.fromPartial(value) })
				return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo)
			} catch (e: any) {
				throw new Error('TxClient:sendMsgAllocationUpdateResponse: Could not broadcast Tx: '+ e.message)
			}
		},
		
		async sendMsgStructAttackResponse({ value, fee, memo }: sendMsgStructAttackResponseParams): Promise<DeliverTxResponse> {
			if (!signer) {
					throw new Error('TxClient:sendMsgStructAttackResponse: Unable to sign Tx. Signer is not present.')
			}
			try {			
				const { address } = (await signer.getAccounts())[0]; 
				const signingClient = await SigningStargateClient.connectWithSigner(addr,signer,{registry});
				let msg = this.msgStructAttackResponse({ value: MsgStructAttackResponse.fromPartial(value) })
				return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo)
			} catch (e: any) {
				throw new Error('TxClient:sendMsgStructAttackResponse: Could not broadcast Tx: '+ e.message)
			}
		},
		
		async sendMsgSubstationCreate({ value, fee, memo }: sendMsgSubstationCreateParams): Promise<DeliverTxResponse> {
			if (!signer) {
					throw new Error('TxClient:sendMsgSubstationCreate: Unable to sign Tx. Signer is not present.')
			}
			try {			
				const { address } = (await signer.getAccounts())[0]; 
				const signingClient = await SigningStargateClient.connectWithSigner(addr,signer,{registry});
				let msg = this.msgSubstationCreate({ value: MsgSubstationCreate.fromPartial(value) })
				return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo)
			} catch (e: any) {
				throw new Error('TxClient:sendMsgSubstationCreate: Could not broadcast Tx: '+ e.message)
			}
		},
		
		async sendQueryAllPlanetAttributeResponse({ value, fee, memo }: sendQueryAllPlanetAttributeResponseParams): Promise<DeliverTxResponse> {
			if (!signer) {
					throw new Error('TxClient:sendQueryAllPlanetAttributeResponse: Unable to sign Tx. Signer is not present.')
			}
			try {			
				const { address } = (await signer.getAccounts())[0]; 
				const signingClient = await SigningStargateClient.connectWithSigner(addr,signer,{registry});
				let msg = this.queryAllPlanetAttributeResponse({ value: QueryAllPlanetAttributeResponse.fromPartial(value) })
				return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo)
			} catch (e: any) {
				throw new Error('TxClient:sendQueryAllPlanetAttributeResponse: Could not broadcast Tx: '+ e.message)
			}
		},
		
		async sendQueryAllProviderEarningsAddressRequest({ value, fee, memo }: sendQueryAllProviderEarningsAddressRequestParams): Promise<DeliverTxResponse> {
			if (!signer) {
					throw new Error('TxClient:sendQueryAllProviderEarningsAddressRequest: Unable to sign Tx. Signer is not present.')
			}
			try {			
				const { address } = (await signer.getAccounts())[0]; 
				const signingClient = await SigningStargateClient.connectWithSigner(addr,signer,{registry});
				let msg = this.queryAllProviderEarningsAddressRequest({ value: QueryAllProviderEarningsAddressRequest.fromPartial(value) })
				return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo)
			} catch (e: any) {
				throw new Error('TxClient:sendQueryAllProviderEarningsAddressRequest: Could not broadcast Tx: '+ e.message)
			}
		},
		
		async sendQueryAllPlayerRequest({ value, fee, memo }: sendQueryAllPlayerRequestParams): Promise<DeliverTxResponse> {
			if (!signer) {
					throw new Error('TxClient:sendQueryAllPlayerRequest: Unable to sign Tx. Signer is not present.')
			}
			try {			
				const { address } = (await signer.getAccounts())[0]; 
				const signingClient = await SigningStargateClient.connectWithSigner(addr,signer,{registry});
				let msg = this.queryAllPlayerRequest({ value: QueryAllPlayerRequest.fromPartial(value) })
				return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo)
			} catch (e: any) {
				throw new Error('TxClient:sendQueryAllPlayerRequest: Could not broadcast Tx: '+ e.message)
			}
		},
		
		async sendQueryGetStructAttributeRequest({ value, fee, memo }: sendQueryGetStructAttributeRequestParams): Promise<DeliverTxResponse> {
			if (!signer) {
					throw new Error('TxClient:sendQueryGetStructAttributeRequest: Unable to sign Tx. Signer is not present.')
			}
			try {			
				const { address } = (await signer.getAccounts())[0]; 
				const signingClient = await SigningStargateClient.connectWithSigner(addr,signer,{registry});
				let msg = this.queryGetStructAttributeRequest({ value: QueryGetStructAttributeRequest.fromPartial(value) })
				return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo)
			} catch (e: any) {
				throw new Error('TxClient:sendQueryGetStructAttributeRequest: Could not broadcast Tx: '+ e.message)
			}
		},
		
		async sendEventGuildBankAddress({ value, fee, memo }: sendEventGuildBankAddressParams): Promise<DeliverTxResponse> {
			if (!signer) {
					throw new Error('TxClient:sendEventGuildBankAddress: Unable to sign Tx. Signer is not present.')
			}
			try {			
				const { address } = (await signer.getAccounts())[0]; 
				const signingClient = await SigningStargateClient.connectWithSigner(addr,signer,{registry});
				let msg = this.eventGuildBankAddress({ value: EventGuildBankAddress.fromPartial(value) })
				return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo)
			} catch (e: any) {
				throw new Error('TxClient:sendEventGuildBankAddress: Could not broadcast Tx: '+ e.message)
			}
		},
		
		async sendMsgAllocationCreateResponse({ value, fee, memo }: sendMsgAllocationCreateResponseParams): Promise<DeliverTxResponse> {
			if (!signer) {
					throw new Error('TxClient:sendMsgAllocationCreateResponse: Unable to sign Tx. Signer is not present.')
			}
			try {			
				const { address } = (await signer.getAccounts())[0]; 
				const signingClient = await SigningStargateClient.connectWithSigner(addr,signer,{registry});
				let msg = this.msgAllocationCreateResponse({ value: MsgAllocationCreateResponse.fromPartial(value) })
				return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo)
			} catch (e: any) {
				throw new Error('TxClient:sendMsgAllocationCreateResponse: Could not broadcast Tx: '+ e.message)
			}
		},
		
		async sendAllocation({ value, fee, memo }: sendAllocationParams): Promise<DeliverTxResponse> {
			if (!signer) {
					throw new Error('TxClient:sendAllocation: Unable to sign Tx. Signer is not present.')
			}
			try {			
				const { address } = (await signer.getAccounts())[0]; 
				const signingClient = await SigningStargateClient.connectWithSigner(addr,signer,{registry});
				let msg = this.allocation({ value: Allocation.fromPartial(value) })
				return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo)
			} catch (e: any) {
				throw new Error('TxClient:sendAllocation: Could not broadcast Tx: '+ e.message)
			}
		},
		
		async sendQueryAllPermissionByPlayerRequest({ value, fee, memo }: sendQueryAllPermissionByPlayerRequestParams): Promise<DeliverTxResponse> {
			if (!signer) {
					throw new Error('TxClient:sendQueryAllPermissionByPlayerRequest: Unable to sign Tx. Signer is not present.')
			}
			try {			
				const { address } = (await signer.getAccounts())[0]; 
				const signingClient = await SigningStargateClient.connectWithSigner(addr,signer,{registry});
				let msg = this.queryAllPermissionByPlayerRequest({ value: QueryAllPermissionByPlayerRequest.fromPartial(value) })
				return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo)
			} catch (e: any) {
				throw new Error('TxClient:sendQueryAllPermissionByPlayerRequest: Could not broadcast Tx: '+ e.message)
			}
		},
		
		async sendQueryAllProviderCollateralAddressRequest({ value, fee, memo }: sendQueryAllProviderCollateralAddressRequestParams): Promise<DeliverTxResponse> {
			if (!signer) {
					throw new Error('TxClient:sendQueryAllProviderCollateralAddressRequest: Unable to sign Tx. Signer is not present.')
			}
			try {			
				const { address } = (await signer.getAccounts())[0]; 
				const signingClient = await SigningStargateClient.connectWithSigner(addr,signer,{registry});
				let msg = this.queryAllProviderCollateralAddressRequest({ value: QueryAllProviderCollateralAddressRequest.fromPartial(value) })
				return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo)
			} catch (e: any) {
				throw new Error('TxClient:sendQueryAllProviderCollateralAddressRequest: Could not broadcast Tx: '+ e.message)
			}
		},
		
		async sendQueryGetProviderEarningsAddressRequest({ value, fee, memo }: sendQueryGetProviderEarningsAddressRequestParams): Promise<DeliverTxResponse> {
			if (!signer) {
					throw new Error('TxClient:sendQueryGetProviderEarningsAddressRequest: Unable to sign Tx. Signer is not present.')
			}
			try {			
				const { address } = (await signer.getAccounts())[0]; 
				const signingClient = await SigningStargateClient.connectWithSigner(addr,signer,{registry});
				let msg = this.queryGetProviderEarningsAddressRequest({ value: QueryGetProviderEarningsAddressRequest.fromPartial(value) })
				return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo)
			} catch (e: any) {
				throw new Error('TxClient:sendQueryGetProviderEarningsAddressRequest: Could not broadcast Tx: '+ e.message)
			}
		},
		
		async sendMsgAllocationTransfer({ value, fee, memo }: sendMsgAllocationTransferParams): Promise<DeliverTxResponse> {
			if (!signer) {
					throw new Error('TxClient:sendMsgAllocationTransfer: Unable to sign Tx. Signer is not present.')
			}
			try {			
				const { address } = (await signer.getAccounts())[0]; 
				const signingClient = await SigningStargateClient.connectWithSigner(addr,signer,{registry});
				let msg = this.msgAllocationTransfer({ value: MsgAllocationTransfer.fromPartial(value) })
				return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo)
			} catch (e: any) {
				throw new Error('TxClient:sendMsgAllocationTransfer: Could not broadcast Tx: '+ e.message)
			}
		},
		
		async sendMsgGuildBankConfiscateAndBurnResponse({ value, fee, memo }: sendMsgGuildBankConfiscateAndBurnResponseParams): Promise<DeliverTxResponse> {
			if (!signer) {
					throw new Error('TxClient:sendMsgGuildBankConfiscateAndBurnResponse: Unable to sign Tx. Signer is not present.')
			}
			try {			
				const { address } = (await signer.getAccounts())[0]; 
				const signingClient = await SigningStargateClient.connectWithSigner(addr,signer,{registry});
				let msg = this.msgGuildBankConfiscateAndBurnResponse({ value: MsgGuildBankConfiscateAndBurnResponse.fromPartial(value) })
				return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo)
			} catch (e: any) {
				throw new Error('TxClient:sendMsgGuildBankConfiscateAndBurnResponse: Could not broadcast Tx: '+ e.message)
			}
		},
		
		async sendMsgGuildMembershipKick({ value, fee, memo }: sendMsgGuildMembershipKickParams): Promise<DeliverTxResponse> {
			if (!signer) {
					throw new Error('TxClient:sendMsgGuildMembershipKick: Unable to sign Tx. Signer is not present.')
			}
			try {			
				const { address } = (await signer.getAccounts())[0]; 
				const signingClient = await SigningStargateClient.connectWithSigner(addr,signer,{registry});
				let msg = this.msgGuildMembershipKick({ value: MsgGuildMembershipKick.fromPartial(value) })
				return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo)
			} catch (e: any) {
				throw new Error('TxClient:sendMsgGuildMembershipKick: Could not broadcast Tx: '+ e.message)
			}
		},
		
		async sendQueryAllGridResponse({ value, fee, memo }: sendQueryAllGridResponseParams): Promise<DeliverTxResponse> {
			if (!signer) {
					throw new Error('TxClient:sendQueryAllGridResponse: Unable to sign Tx. Signer is not present.')
			}
			try {			
				const { address } = (await signer.getAccounts())[0]; 
				const signingClient = await SigningStargateClient.connectWithSigner(addr,signer,{registry});
				let msg = this.queryAllGridResponse({ value: QueryAllGridResponse.fromPartial(value) })
				return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo)
			} catch (e: any) {
				throw new Error('TxClient:sendQueryAllGridResponse: Could not broadcast Tx: '+ e.message)
			}
		},
		
		async sendFleetAttributeRecord({ value, fee, memo }: sendFleetAttributeRecordParams): Promise<DeliverTxResponse> {
			if (!signer) {
					throw new Error('TxClient:sendFleetAttributeRecord: Unable to sign Tx. Signer is not present.')
			}
			try {			
				const { address } = (await signer.getAccounts())[0]; 
				const signingClient = await SigningStargateClient.connectWithSigner(addr,signer,{registry});
				let msg = this.fleetAttributeRecord({ value: FleetAttributeRecord.fromPartial(value) })
				return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo)
			} catch (e: any) {
				throw new Error('TxClient:sendFleetAttributeRecord: Could not broadcast Tx: '+ e.message)
			}
		},
		
		async sendMsgSubstationPlayerMigrate({ value, fee, memo }: sendMsgSubstationPlayerMigrateParams): Promise<DeliverTxResponse> {
			if (!signer) {
					throw new Error('TxClient:sendMsgSubstationPlayerMigrate: Unable to sign Tx. Signer is not present.')
			}
			try {			
				const { address } = (await signer.getAccounts())[0]; 
				const signingClient = await SigningStargateClient.connectWithSigner(addr,signer,{registry});
				let msg = this.msgSubstationPlayerMigrate({ value: MsgSubstationPlayerMigrate.fromPartial(value) })
				return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo)
			} catch (e: any) {
				throw new Error('TxClient:sendMsgSubstationPlayerMigrate: Could not broadcast Tx: '+ e.message)
			}
		},
		
		async sendMsgProviderUpdateCapacityMaximum({ value, fee, memo }: sendMsgProviderUpdateCapacityMaximumParams): Promise<DeliverTxResponse> {
			if (!signer) {
					throw new Error('TxClient:sendMsgProviderUpdateCapacityMaximum: Unable to sign Tx. Signer is not present.')
			}
			try {			
				const { address } = (await signer.getAccounts())[0]; 
				const signingClient = await SigningStargateClient.connectWithSigner(addr,signer,{registry});
				let msg = this.msgProviderUpdateCapacityMaximum({ value: MsgProviderUpdateCapacityMaximum.fromPartial(value) })
				return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo)
			} catch (e: any) {
				throw new Error('TxClient:sendMsgProviderUpdateCapacityMaximum: Could not broadcast Tx: '+ e.message)
			}
		},
		
		async sendEventDelete({ value, fee, memo }: sendEventDeleteParams): Promise<DeliverTxResponse> {
			if (!signer) {
					throw new Error('TxClient:sendEventDelete: Unable to sign Tx. Signer is not present.')
			}
			try {			
				const { address } = (await signer.getAccounts())[0]; 
				const signingClient = await SigningStargateClient.connectWithSigner(addr,signer,{registry});
				let msg = this.eventDelete({ value: EventDelete.fromPartial(value) })
				return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo)
			} catch (e: any) {
				throw new Error('TxClient:sendEventDelete: Could not broadcast Tx: '+ e.message)
			}
		},
		
		async sendEventGuildBankMint({ value, fee, memo }: sendEventGuildBankMintParams): Promise<DeliverTxResponse> {
			if (!signer) {
					throw new Error('TxClient:sendEventGuildBankMint: Unable to sign Tx. Signer is not present.')
			}
			try {			
				const { address } = (await signer.getAccounts())[0]; 
				const signingClient = await SigningStargateClient.connectWithSigner(addr,signer,{registry});
				let msg = this.eventGuildBankMint({ value: EventGuildBankMint.fromPartial(value) })
				return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo)
			} catch (e: any) {
				throw new Error('TxClient:sendEventGuildBankMint: Could not broadcast Tx: '+ e.message)
			}
		},
		
		async sendQueryGetGridRequest({ value, fee, memo }: sendQueryGetGridRequestParams): Promise<DeliverTxResponse> {
			if (!signer) {
					throw new Error('TxClient:sendQueryGetGridRequest: Unable to sign Tx. Signer is not present.')
			}
			try {			
				const { address } = (await signer.getAccounts())[0]; 
				const signingClient = await SigningStargateClient.connectWithSigner(addr,signer,{registry});
				let msg = this.queryGetGridRequest({ value: QueryGetGridRequest.fromPartial(value) })
				return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo)
			} catch (e: any) {
				throw new Error('TxClient:sendQueryGetGridRequest: Could not broadcast Tx: '+ e.message)
			}
		},
		
		async sendQueryGetGuildResponse({ value, fee, memo }: sendQueryGetGuildResponseParams): Promise<DeliverTxResponse> {
			if (!signer) {
					throw new Error('TxClient:sendQueryGetGuildResponse: Unable to sign Tx. Signer is not present.')
			}
			try {			
				const { address } = (await signer.getAccounts())[0]; 
				const signingClient = await SigningStargateClient.connectWithSigner(addr,signer,{registry});
				let msg = this.queryGetGuildResponse({ value: QueryGetGuildResponse.fromPartial(value) })
				return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo)
			} catch (e: any) {
				throw new Error('TxClient:sendQueryGetGuildResponse: Could not broadcast Tx: '+ e.message)
			}
		},
		
		async sendQueryGetProviderCollateralAddressRequest({ value, fee, memo }: sendQueryGetProviderCollateralAddressRequestParams): Promise<DeliverTxResponse> {
			if (!signer) {
					throw new Error('TxClient:sendQueryGetProviderCollateralAddressRequest: Unable to sign Tx. Signer is not present.')
			}
			try {			
				const { address } = (await signer.getAccounts())[0]; 
				const signingClient = await SigningStargateClient.connectWithSigner(addr,signer,{registry});
				let msg = this.queryGetProviderCollateralAddressRequest({ value: QueryGetProviderCollateralAddressRequest.fromPartial(value) })
				return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo)
			} catch (e: any) {
				throw new Error('TxClient:sendQueryGetProviderCollateralAddressRequest: Could not broadcast Tx: '+ e.message)
			}
		},
		
		async sendQueryGetStructRequest({ value, fee, memo }: sendQueryGetStructRequestParams): Promise<DeliverTxResponse> {
			if (!signer) {
					throw new Error('TxClient:sendQueryGetStructRequest: Unable to sign Tx. Signer is not present.')
			}
			try {			
				const { address } = (await signer.getAccounts())[0]; 
				const signingClient = await SigningStargateClient.connectWithSigner(addr,signer,{registry});
				let msg = this.queryGetStructRequest({ value: QueryGetStructRequest.fromPartial(value) })
				return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo)
			} catch (e: any) {
				throw new Error('TxClient:sendQueryGetStructRequest: Could not broadcast Tx: '+ e.message)
			}
		},
		
		async sendQueryGetStructAttributeResponse({ value, fee, memo }: sendQueryGetStructAttributeResponseParams): Promise<DeliverTxResponse> {
			if (!signer) {
					throw new Error('TxClient:sendQueryGetStructAttributeResponse: Unable to sign Tx. Signer is not present.')
			}
			try {			
				const { address } = (await signer.getAccounts())[0]; 
				const signingClient = await SigningStargateClient.connectWithSigner(addr,signer,{registry});
				let msg = this.queryGetStructAttributeResponse({ value: QueryGetStructAttributeResponse.fromPartial(value) })
				return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo)
			} catch (e: any) {
				throw new Error('TxClient:sendQueryGetStructAttributeResponse: Could not broadcast Tx: '+ e.message)
			}
		},
		
		async sendQueryAllStructTypeRequest({ value, fee, memo }: sendQueryAllStructTypeRequestParams): Promise<DeliverTxResponse> {
			if (!signer) {
					throw new Error('TxClient:sendQueryAllStructTypeRequest: Unable to sign Tx. Signer is not present.')
			}
			try {			
				const { address } = (await signer.getAccounts())[0]; 
				const signingClient = await SigningStargateClient.connectWithSigner(addr,signer,{registry});
				let msg = this.queryAllStructTypeRequest({ value: QueryAllStructTypeRequest.fromPartial(value) })
				return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo)
			} catch (e: any) {
				throw new Error('TxClient:sendQueryAllStructTypeRequest: Could not broadcast Tx: '+ e.message)
			}
		},
		
		async sendEventAlphaRefine({ value, fee, memo }: sendEventAlphaRefineParams): Promise<DeliverTxResponse> {
			if (!signer) {
					throw new Error('TxClient:sendEventAlphaRefine: Unable to sign Tx. Signer is not present.')
			}
			try {			
				const { address } = (await signer.getAccounts())[0]; 
				const signingClient = await SigningStargateClient.connectWithSigner(addr,signer,{registry});
				let msg = this.eventAlphaRefine({ value: EventAlphaRefine.fromPartial(value) })
				return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo)
			} catch (e: any) {
				throw new Error('TxClient:sendEventAlphaRefine: Could not broadcast Tx: '+ e.message)
			}
		},
		
		async sendQueryAllInfusionByDestinationRequest({ value, fee, memo }: sendQueryAllInfusionByDestinationRequestParams): Promise<DeliverTxResponse> {
			if (!signer) {
					throw new Error('TxClient:sendQueryAllInfusionByDestinationRequest: Unable to sign Tx. Signer is not present.')
			}
			try {			
				const { address } = (await signer.getAccounts())[0]; 
				const signingClient = await SigningStargateClient.connectWithSigner(addr,signer,{registry});
				let msg = this.queryAllInfusionByDestinationRequest({ value: QueryAllInfusionByDestinationRequest.fromPartial(value) })
				return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo)
			} catch (e: any) {
				throw new Error('TxClient:sendQueryAllInfusionByDestinationRequest: Could not broadcast Tx: '+ e.message)
			}
		},
		
		async sendQueryGetPermissionRequest({ value, fee, memo }: sendQueryGetPermissionRequestParams): Promise<DeliverTxResponse> {
			if (!signer) {
					throw new Error('TxClient:sendQueryGetPermissionRequest: Unable to sign Tx. Signer is not present.')
			}
			try {			
				const { address } = (await signer.getAccounts())[0]; 
				const signingClient = await SigningStargateClient.connectWithSigner(addr,signer,{registry});
				let msg = this.queryGetPermissionRequest({ value: QueryGetPermissionRequest.fromPartial(value) })
				return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo)
			} catch (e: any) {
				throw new Error('TxClient:sendQueryGetPermissionRequest: Could not broadcast Tx: '+ e.message)
			}
		},
		
		async sendQueryGetStructResponse({ value, fee, memo }: sendQueryGetStructResponseParams): Promise<DeliverTxResponse> {
			if (!signer) {
					throw new Error('TxClient:sendQueryGetStructResponse: Unable to sign Tx. Signer is not present.')
			}
			try {			
				const { address } = (await signer.getAccounts())[0]; 
				const signingClient = await SigningStargateClient.connectWithSigner(addr,signer,{registry});
				let msg = this.queryGetStructResponse({ value: QueryGetStructResponse.fromPartial(value) })
				return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo)
			} catch (e: any) {
				throw new Error('TxClient:sendQueryGetStructResponse: Could not broadcast Tx: '+ e.message)
			}
		},
		
		async sendQueryGetSubstationRequest({ value, fee, memo }: sendQueryGetSubstationRequestParams): Promise<DeliverTxResponse> {
			if (!signer) {
					throw new Error('TxClient:sendQueryGetSubstationRequest: Unable to sign Tx. Signer is not present.')
			}
			try {			
				const { address } = (await signer.getAccounts())[0]; 
				const signingClient = await SigningStargateClient.connectWithSigner(addr,signer,{registry});
				let msg = this.queryGetSubstationRequest({ value: QueryGetSubstationRequest.fromPartial(value) })
				return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo)
			} catch (e: any) {
				throw new Error('TxClient:sendQueryGetSubstationRequest: Could not broadcast Tx: '+ e.message)
			}
		},
		
		async sendEventRaidDetail({ value, fee, memo }: sendEventRaidDetailParams): Promise<DeliverTxResponse> {
			if (!signer) {
					throw new Error('TxClient:sendEventRaidDetail: Unable to sign Tx. Signer is not present.')
			}
			try {			
				const { address } = (await signer.getAccounts())[0]; 
				const signingClient = await SigningStargateClient.connectWithSigner(addr,signer,{registry});
				let msg = this.eventRaidDetail({ value: EventRaidDetail.fromPartial(value) })
				return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo)
			} catch (e: any) {
				throw new Error('TxClient:sendEventRaidDetail: Could not broadcast Tx: '+ e.message)
			}
		},
		
		async sendMsgGuildMembershipInvite({ value, fee, memo }: sendMsgGuildMembershipInviteParams): Promise<DeliverTxResponse> {
			if (!signer) {
					throw new Error('TxClient:sendMsgGuildMembershipInvite: Unable to sign Tx. Signer is not present.')
			}
			try {			
				const { address } = (await signer.getAccounts())[0]; 
				const signingClient = await SigningStargateClient.connectWithSigner(addr,signer,{registry});
				let msg = this.msgGuildMembershipInvite({ value: MsgGuildMembershipInvite.fromPartial(value) })
				return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo)
			} catch (e: any) {
				throw new Error('TxClient:sendMsgGuildMembershipInvite: Could not broadcast Tx: '+ e.message)
			}
		},
		
		async sendMsgGuildMembershipInviteApprove({ value, fee, memo }: sendMsgGuildMembershipInviteApproveParams): Promise<DeliverTxResponse> {
			if (!signer) {
					throw new Error('TxClient:sendMsgGuildMembershipInviteApprove: Unable to sign Tx. Signer is not present.')
			}
			try {			
				const { address } = (await signer.getAccounts())[0]; 
				const signingClient = await SigningStargateClient.connectWithSigner(addr,signer,{registry});
				let msg = this.msgGuildMembershipInviteApprove({ value: MsgGuildMembershipInviteApprove.fromPartial(value) })
				return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo)
			} catch (e: any) {
				throw new Error('TxClient:sendMsgGuildMembershipInviteApprove: Could not broadcast Tx: '+ e.message)
			}
		},
		
		async sendQueryGetAllocationResponse({ value, fee, memo }: sendQueryGetAllocationResponseParams): Promise<DeliverTxResponse> {
			if (!signer) {
					throw new Error('TxClient:sendQueryGetAllocationResponse: Unable to sign Tx. Signer is not present.')
			}
			try {			
				const { address } = (await signer.getAccounts())[0]; 
				const signingClient = await SigningStargateClient.connectWithSigner(addr,signer,{registry});
				let msg = this.queryGetAllocationResponse({ value: QueryGetAllocationResponse.fromPartial(value) })
				return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo)
			} catch (e: any) {
				throw new Error('TxClient:sendQueryGetAllocationResponse: Could not broadcast Tx: '+ e.message)
			}
		},
		
		async sendQueryAllGridRequest({ value, fee, memo }: sendQueryAllGridRequestParams): Promise<DeliverTxResponse> {
			if (!signer) {
					throw new Error('TxClient:sendQueryAllGridRequest: Unable to sign Tx. Signer is not present.')
			}
			try {			
				const { address } = (await signer.getAccounts())[0]; 
				const signingClient = await SigningStargateClient.connectWithSigner(addr,signer,{registry});
				let msg = this.queryAllGridRequest({ value: QueryAllGridRequest.fromPartial(value) })
				return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo)
			} catch (e: any) {
				throw new Error('TxClient:sendQueryAllGridRequest: Could not broadcast Tx: '+ e.message)
			}
		},
		
		async sendQueryAllStructRequest({ value, fee, memo }: sendQueryAllStructRequestParams): Promise<DeliverTxResponse> {
			if (!signer) {
					throw new Error('TxClient:sendQueryAllStructRequest: Unable to sign Tx. Signer is not present.')
			}
			try {			
				const { address } = (await signer.getAccounts())[0]; 
				const signingClient = await SigningStargateClient.connectWithSigner(addr,signer,{registry});
				let msg = this.queryAllStructRequest({ value: QueryAllStructRequest.fromPartial(value) })
				return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo)
			} catch (e: any) {
				throw new Error('TxClient:sendQueryAllStructRequest: Could not broadcast Tx: '+ e.message)
			}
		},
		
		async sendStructAttributeRecord({ value, fee, memo }: sendStructAttributeRecordParams): Promise<DeliverTxResponse> {
			if (!signer) {
					throw new Error('TxClient:sendStructAttributeRecord: Unable to sign Tx. Signer is not present.')
			}
			try {			
				const { address } = (await signer.getAccounts())[0]; 
				const signingClient = await SigningStargateClient.connectWithSigner(addr,signer,{registry});
				let msg = this.structAttributeRecord({ value: StructAttributeRecord.fromPartial(value) })
				return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo)
			} catch (e: any) {
				throw new Error('TxClient:sendStructAttributeRecord: Could not broadcast Tx: '+ e.message)
			}
		},
		
		async sendEventPlanetAttribute({ value, fee, memo }: sendEventPlanetAttributeParams): Promise<DeliverTxResponse> {
			if (!signer) {
					throw new Error('TxClient:sendEventPlanetAttribute: Unable to sign Tx. Signer is not present.')
			}
			try {			
				const { address } = (await signer.getAccounts())[0]; 
				const signingClient = await SigningStargateClient.connectWithSigner(addr,signer,{registry});
				let msg = this.eventPlanetAttribute({ value: EventPlanetAttribute.fromPartial(value) })
				return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo)
			} catch (e: any) {
				throw new Error('TxClient:sendEventPlanetAttribute: Could not broadcast Tx: '+ e.message)
			}
		},
		
		async sendEventOreMine({ value, fee, memo }: sendEventOreMineParams): Promise<DeliverTxResponse> {
			if (!signer) {
					throw new Error('TxClient:sendEventOreMine: Unable to sign Tx. Signer is not present.')
			}
			try {			
				const { address } = (await signer.getAccounts())[0]; 
				const signingClient = await SigningStargateClient.connectWithSigner(addr,signer,{registry});
				let msg = this.eventOreMine({ value: EventOreMine.fromPartial(value) })
				return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo)
			} catch (e: any) {
				throw new Error('TxClient:sendEventOreMine: Could not broadcast Tx: '+ e.message)
			}
		},
		
		async sendEventAttackShotDetail({ value, fee, memo }: sendEventAttackShotDetailParams): Promise<DeliverTxResponse> {
			if (!signer) {
					throw new Error('TxClient:sendEventAttackShotDetail: Unable to sign Tx. Signer is not present.')
			}
			try {			
				const { address } = (await signer.getAccounts())[0]; 
				const signingClient = await SigningStargateClient.connectWithSigner(addr,signer,{registry});
				let msg = this.eventAttackShotDetail({ value: EventAttackShotDetail.fromPartial(value) })
				return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo)
			} catch (e: any) {
				throw new Error('TxClient:sendEventAttackShotDetail: Could not broadcast Tx: '+ e.message)
			}
		},
		
		async sendMsgStructStealthDeactivate({ value, fee, memo }: sendMsgStructStealthDeactivateParams): Promise<DeliverTxResponse> {
			if (!signer) {
					throw new Error('TxClient:sendMsgStructStealthDeactivate: Unable to sign Tx. Signer is not present.')
			}
			try {			
				const { address } = (await signer.getAccounts())[0]; 
				const signingClient = await SigningStargateClient.connectWithSigner(addr,signer,{registry});
				let msg = this.msgStructStealthDeactivate({ value: MsgStructStealthDeactivate.fromPartial(value) })
				return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo)
			} catch (e: any) {
				throw new Error('TxClient:sendMsgStructStealthDeactivate: Could not broadcast Tx: '+ e.message)
			}
		},
		
		async sendStructAttributes({ value, fee, memo }: sendStructAttributesParams): Promise<DeliverTxResponse> {
			if (!signer) {
					throw new Error('TxClient:sendStructAttributes: Unable to sign Tx. Signer is not present.')
			}
			try {			
				const { address } = (await signer.getAccounts())[0]; 
				const signingClient = await SigningStargateClient.connectWithSigner(addr,signer,{registry});
				let msg = this.structAttributes({ value: StructAttributes.fromPartial(value) })
				return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo)
			} catch (e: any) {
				throw new Error('TxClient:sendStructAttributes: Could not broadcast Tx: '+ e.message)
			}
		},
		
		async sendEventStruct({ value, fee, memo }: sendEventStructParams): Promise<DeliverTxResponse> {
			if (!signer) {
					throw new Error('TxClient:sendEventStruct: Unable to sign Tx. Signer is not present.')
			}
			try {			
				const { address } = (await signer.getAccounts())[0]; 
				const signingClient = await SigningStargateClient.connectWithSigner(addr,signer,{registry});
				let msg = this.eventStruct({ value: EventStruct.fromPartial(value) })
				return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo)
			} catch (e: any) {
				throw new Error('TxClient:sendEventStruct: Could not broadcast Tx: '+ e.message)
			}
		},
		
		async sendMsgGuildUpdateResponse({ value, fee, memo }: sendMsgGuildUpdateResponseParams): Promise<DeliverTxResponse> {
			if (!signer) {
					throw new Error('TxClient:sendMsgGuildUpdateResponse: Unable to sign Tx. Signer is not present.')
			}
			try {			
				const { address } = (await signer.getAccounts())[0]; 
				const signingClient = await SigningStargateClient.connectWithSigner(addr,signer,{registry});
				let msg = this.msgGuildUpdateResponse({ value: MsgGuildUpdateResponse.fromPartial(value) })
				return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo)
			} catch (e: any) {
				throw new Error('TxClient:sendMsgGuildUpdateResponse: Could not broadcast Tx: '+ e.message)
			}
		},
		
		async sendMsgProviderGuildRevoke({ value, fee, memo }: sendMsgProviderGuildRevokeParams): Promise<DeliverTxResponse> {
			if (!signer) {
					throw new Error('TxClient:sendMsgProviderGuildRevoke: Unable to sign Tx. Signer is not present.')
			}
			try {			
				const { address } = (await signer.getAccounts())[0]; 
				const signingClient = await SigningStargateClient.connectWithSigner(addr,signer,{registry});
				let msg = this.msgProviderGuildRevoke({ value: MsgProviderGuildRevoke.fromPartial(value) })
				return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo)
			} catch (e: any) {
				throw new Error('TxClient:sendMsgProviderGuildRevoke: Could not broadcast Tx: '+ e.message)
			}
		},
		
		async sendMsgProviderDelete({ value, fee, memo }: sendMsgProviderDeleteParams): Promise<DeliverTxResponse> {
			if (!signer) {
					throw new Error('TxClient:sendMsgProviderDelete: Unable to sign Tx. Signer is not present.')
			}
			try {			
				const { address } = (await signer.getAccounts())[0]; 
				const signingClient = await SigningStargateClient.connectWithSigner(addr,signer,{registry});
				let msg = this.msgProviderDelete({ value: MsgProviderDelete.fromPartial(value) })
				return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo)
			} catch (e: any) {
				throw new Error('TxClient:sendMsgProviderDelete: Could not broadcast Tx: '+ e.message)
			}
		},
		
		async sendAgreement({ value, fee, memo }: sendAgreementParams): Promise<DeliverTxResponse> {
			if (!signer) {
					throw new Error('TxClient:sendAgreement: Unable to sign Tx. Signer is not present.')
			}
			try {			
				const { address } = (await signer.getAccounts())[0]; 
				const signingClient = await SigningStargateClient.connectWithSigner(addr,signer,{registry});
				let msg = this.agreement({ value: Agreement.fromPartial(value) })
				return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo)
			} catch (e: any) {
				throw new Error('TxClient:sendAgreement: Could not broadcast Tx: '+ e.message)
			}
		},
		
		async sendEventGuildBankConfiscateAndBurnDetail({ value, fee, memo }: sendEventGuildBankConfiscateAndBurnDetailParams): Promise<DeliverTxResponse> {
			if (!signer) {
					throw new Error('TxClient:sendEventGuildBankConfiscateAndBurnDetail: Unable to sign Tx. Signer is not present.')
			}
			try {			
				const { address } = (await signer.getAccounts())[0]; 
				const signingClient = await SigningStargateClient.connectWithSigner(addr,signer,{registry});
				let msg = this.eventGuildBankConfiscateAndBurnDetail({ value: EventGuildBankConfiscateAndBurnDetail.fromPartial(value) })
				return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo)
			} catch (e: any) {
				throw new Error('TxClient:sendEventGuildBankConfiscateAndBurnDetail: Could not broadcast Tx: '+ e.message)
			}
		},
		
		async sendEventGuildMembershipApplication({ value, fee, memo }: sendEventGuildMembershipApplicationParams): Promise<DeliverTxResponse> {
			if (!signer) {
					throw new Error('TxClient:sendEventGuildMembershipApplication: Unable to sign Tx. Signer is not present.')
			}
			try {			
				const { address } = (await signer.getAccounts())[0]; 
				const signingClient = await SigningStargateClient.connectWithSigner(addr,signer,{registry});
				let msg = this.eventGuildMembershipApplication({ value: EventGuildMembershipApplication.fromPartial(value) })
				return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo)
			} catch (e: any) {
				throw new Error('TxClient:sendEventGuildMembershipApplication: Could not broadcast Tx: '+ e.message)
			}
		},
		
		async sendMsgGuildMembershipJoin({ value, fee, memo }: sendMsgGuildMembershipJoinParams): Promise<DeliverTxResponse> {
			if (!signer) {
					throw new Error('TxClient:sendMsgGuildMembershipJoin: Unable to sign Tx. Signer is not present.')
			}
			try {			
				const { address } = (await signer.getAccounts())[0]; 
				const signingClient = await SigningStargateClient.connectWithSigner(addr,signer,{registry});
				let msg = this.msgGuildMembershipJoin({ value: MsgGuildMembershipJoin.fromPartial(value) })
				return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo)
			} catch (e: any) {
				throw new Error('TxClient:sendMsgGuildMembershipJoin: Could not broadcast Tx: '+ e.message)
			}
		},
		
		async sendMsgPlanetExplore({ value, fee, memo }: sendMsgPlanetExploreParams): Promise<DeliverTxResponse> {
			if (!signer) {
					throw new Error('TxClient:sendMsgPlanetExplore: Unable to sign Tx. Signer is not present.')
			}
			try {			
				const { address } = (await signer.getAccounts())[0]; 
				const signingClient = await SigningStargateClient.connectWithSigner(addr,signer,{registry});
				let msg = this.msgPlanetExplore({ value: MsgPlanetExplore.fromPartial(value) })
				return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo)
			} catch (e: any) {
				throw new Error('TxClient:sendMsgPlanetExplore: Could not broadcast Tx: '+ e.message)
			}
		},
		
		async sendMsgStructStorageStash({ value, fee, memo }: sendMsgStructStorageStashParams): Promise<DeliverTxResponse> {
			if (!signer) {
					throw new Error('TxClient:sendMsgStructStorageStash: Unable to sign Tx. Signer is not present.')
			}
			try {			
				const { address } = (await signer.getAccounts())[0]; 
				const signingClient = await SigningStargateClient.connectWithSigner(addr,signer,{registry});
				let msg = this.msgStructStorageStash({ value: MsgStructStorageStash.fromPartial(value) })
				return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo)
			} catch (e: any) {
				throw new Error('TxClient:sendMsgStructStorageStash: Could not broadcast Tx: '+ e.message)
			}
		},
		
		async sendMsgSubstationAllocationConnectResponse({ value, fee, memo }: sendMsgSubstationAllocationConnectResponseParams): Promise<DeliverTxResponse> {
			if (!signer) {
					throw new Error('TxClient:sendMsgSubstationAllocationConnectResponse: Unable to sign Tx. Signer is not present.')
			}
			try {			
				const { address } = (await signer.getAccounts())[0]; 
				const signingClient = await SigningStargateClient.connectWithSigner(addr,signer,{registry});
				let msg = this.msgSubstationAllocationConnectResponse({ value: MsgSubstationAllocationConnectResponse.fromPartial(value) })
				return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo)
			} catch (e: any) {
				throw new Error('TxClient:sendMsgSubstationAllocationConnectResponse: Could not broadcast Tx: '+ e.message)
			}
		},
		
		async sendMsgPermissionRevokeOnObject({ value, fee, memo }: sendMsgPermissionRevokeOnObjectParams): Promise<DeliverTxResponse> {
			if (!signer) {
					throw new Error('TxClient:sendMsgPermissionRevokeOnObject: Unable to sign Tx. Signer is not present.')
			}
			try {			
				const { address } = (await signer.getAccounts())[0]; 
				const signingClient = await SigningStargateClient.connectWithSigner(addr,signer,{registry});
				let msg = this.msgPermissionRevokeOnObject({ value: MsgPermissionRevokeOnObject.fromPartial(value) })
				return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo)
			} catch (e: any) {
				throw new Error('TxClient:sendMsgPermissionRevokeOnObject: Could not broadcast Tx: '+ e.message)
			}
		},
		
		async sendMsgReactorCancelDefusion({ value, fee, memo }: sendMsgReactorCancelDefusionParams): Promise<DeliverTxResponse> {
			if (!signer) {
					throw new Error('TxClient:sendMsgReactorCancelDefusion: Unable to sign Tx. Signer is not present.')
			}
			try {			
				const { address } = (await signer.getAccounts())[0]; 
				const signingClient = await SigningStargateClient.connectWithSigner(addr,signer,{registry});
				let msg = this.msgReactorCancelDefusion({ value: MsgReactorCancelDefusion.fromPartial(value) })
				return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo)
			} catch (e: any) {
				throw new Error('TxClient:sendMsgReactorCancelDefusion: Could not broadcast Tx: '+ e.message)
			}
		},
		
		async sendMsgSubstationAllocationConnect({ value, fee, memo }: sendMsgSubstationAllocationConnectParams): Promise<DeliverTxResponse> {
			if (!signer) {
					throw new Error('TxClient:sendMsgSubstationAllocationConnect: Unable to sign Tx. Signer is not present.')
			}
			try {			
				const { address } = (await signer.getAccounts())[0]; 
				const signingClient = await SigningStargateClient.connectWithSigner(addr,signer,{registry});
				let msg = this.msgSubstationAllocationConnect({ value: MsgSubstationAllocationConnect.fromPartial(value) })
				return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo)
			} catch (e: any) {
				throw new Error('TxClient:sendMsgSubstationAllocationConnect: Could not broadcast Tx: '+ e.message)
			}
		},
		
		async sendQueryGetPlanetRequest({ value, fee, memo }: sendQueryGetPlanetRequestParams): Promise<DeliverTxResponse> {
			if (!signer) {
					throw new Error('TxClient:sendQueryGetPlanetRequest: Unable to sign Tx. Signer is not present.')
			}
			try {			
				const { address } = (await signer.getAccounts())[0]; 
				const signingClient = await SigningStargateClient.connectWithSigner(addr,signer,{registry});
				let msg = this.queryGetPlanetRequest({ value: QueryGetPlanetRequest.fromPartial(value) })
				return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo)
			} catch (e: any) {
				throw new Error('TxClient:sendQueryGetPlanetRequest: Could not broadcast Tx: '+ e.message)
			}
		},
		
		async sendStructType({ value, fee, memo }: sendStructTypeParams): Promise<DeliverTxResponse> {
			if (!signer) {
					throw new Error('TxClient:sendStructType: Unable to sign Tx. Signer is not present.')
			}
			try {			
				const { address } = (await signer.getAccounts())[0]; 
				const signingClient = await SigningStargateClient.connectWithSigner(addr,signer,{registry});
				let msg = this.structType({ value: StructType.fromPartial(value) })
				return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo)
			} catch (e: any) {
				throw new Error('TxClient:sendStructType: Could not broadcast Tx: '+ e.message)
			}
		},
		
		async sendMsgGuildMembershipResponse({ value, fee, memo }: sendMsgGuildMembershipResponseParams): Promise<DeliverTxResponse> {
			if (!signer) {
					throw new Error('TxClient:sendMsgGuildMembershipResponse: Unable to sign Tx. Signer is not present.')
			}
			try {			
				const { address } = (await signer.getAccounts())[0]; 
				const signingClient = await SigningStargateClient.connectWithSigner(addr,signer,{registry});
				let msg = this.msgGuildMembershipResponse({ value: MsgGuildMembershipResponse.fromPartial(value) })
				return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo)
			} catch (e: any) {
				throw new Error('TxClient:sendMsgGuildMembershipResponse: Could not broadcast Tx: '+ e.message)
			}
		},
		
		async sendMsgReactorInfuse({ value, fee, memo }: sendMsgReactorInfuseParams): Promise<DeliverTxResponse> {
			if (!signer) {
					throw new Error('TxClient:sendMsgReactorInfuse: Unable to sign Tx. Signer is not present.')
			}
			try {			
				const { address } = (await signer.getAccounts())[0]; 
				const signingClient = await SigningStargateClient.connectWithSigner(addr,signer,{registry});
				let msg = this.msgReactorInfuse({ value: MsgReactorInfuse.fromPartial(value) })
				return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo)
			} catch (e: any) {
				throw new Error('TxClient:sendMsgReactorInfuse: Could not broadcast Tx: '+ e.message)
			}
		},
		
		async sendMsgStructBuildCompleteAndStash({ value, fee, memo }: sendMsgStructBuildCompleteAndStashParams): Promise<DeliverTxResponse> {
			if (!signer) {
					throw new Error('TxClient:sendMsgStructBuildCompleteAndStash: Unable to sign Tx. Signer is not present.')
			}
			try {			
				const { address } = (await signer.getAccounts())[0]; 
				const signingClient = await SigningStargateClient.connectWithSigner(addr,signer,{registry});
				let msg = this.msgStructBuildCompleteAndStash({ value: MsgStructBuildCompleteAndStash.fromPartial(value) })
				return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo)
			} catch (e: any) {
				throw new Error('TxClient:sendMsgStructBuildCompleteAndStash: Could not broadcast Tx: '+ e.message)
			}
		},
		
		async sendAddressAssociation({ value, fee, memo }: sendAddressAssociationParams): Promise<DeliverTxResponse> {
			if (!signer) {
					throw new Error('TxClient:sendAddressAssociation: Unable to sign Tx. Signer is not present.')
			}
			try {			
				const { address } = (await signer.getAccounts())[0]; 
				const signingClient = await SigningStargateClient.connectWithSigner(addr,signer,{registry});
				let msg = this.addressAssociation({ value: AddressAssociation.fromPartial(value) })
				return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo)
			} catch (e: any) {
				throw new Error('TxClient:sendAddressAssociation: Could not broadcast Tx: '+ e.message)
			}
		},
		
		async sendEventAddressAssociation({ value, fee, memo }: sendEventAddressAssociationParams): Promise<DeliverTxResponse> {
			if (!signer) {
					throw new Error('TxClient:sendEventAddressAssociation: Unable to sign Tx. Signer is not present.')
			}
			try {			
				const { address } = (await signer.getAccounts())[0]; 
				const signingClient = await SigningStargateClient.connectWithSigner(addr,signer,{registry});
				let msg = this.eventAddressAssociation({ value: EventAddressAssociation.fromPartial(value) })
				return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo)
			} catch (e: any) {
				throw new Error('TxClient:sendEventAddressAssociation: Could not broadcast Tx: '+ e.message)
			}
		},
		
		async sendMsgReactorCancelDefusionResponse({ value, fee, memo }: sendMsgReactorCancelDefusionResponseParams): Promise<DeliverTxResponse> {
			if (!signer) {
					throw new Error('TxClient:sendMsgReactorCancelDefusionResponse: Unable to sign Tx. Signer is not present.')
			}
			try {			
				const { address } = (await signer.getAccounts())[0]; 
				const signingClient = await SigningStargateClient.connectWithSigner(addr,signer,{registry});
				let msg = this.msgReactorCancelDefusionResponse({ value: MsgReactorCancelDefusionResponse.fromPartial(value) })
				return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo)
			} catch (e: any) {
				throw new Error('TxClient:sendMsgReactorCancelDefusionResponse: Could not broadcast Tx: '+ e.message)
			}
		},
		
		async sendAddressRecord({ value, fee, memo }: sendAddressRecordParams): Promise<DeliverTxResponse> {
			if (!signer) {
					throw new Error('TxClient:sendAddressRecord: Unable to sign Tx. Signer is not present.')
			}
			try {			
				const { address } = (await signer.getAccounts())[0]; 
				const signingClient = await SigningStargateClient.connectWithSigner(addr,signer,{registry});
				let msg = this.addressRecord({ value: AddressRecord.fromPartial(value) })
				return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo)
			} catch (e: any) {
				throw new Error('TxClient:sendAddressRecord: Could not broadcast Tx: '+ e.message)
			}
		},
		
		async sendStructDefenders({ value, fee, memo }: sendStructDefendersParams): Promise<DeliverTxResponse> {
			if (!signer) {
					throw new Error('TxClient:sendStructDefenders: Unable to sign Tx. Signer is not present.')
			}
			try {			
				const { address } = (await signer.getAccounts())[0]; 
				const signingClient = await SigningStargateClient.connectWithSigner(addr,signer,{registry});
				let msg = this.structDefenders({ value: StructDefenders.fromPartial(value) })
				return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo)
			} catch (e: any) {
				throw new Error('TxClient:sendStructDefenders: Could not broadcast Tx: '+ e.message)
			}
		},
		
		async sendEventPlanet({ value, fee, memo }: sendEventPlanetParams): Promise<DeliverTxResponse> {
			if (!signer) {
					throw new Error('TxClient:sendEventPlanet: Unable to sign Tx. Signer is not present.')
			}
			try {			
				const { address } = (await signer.getAccounts())[0]; 
				const signingClient = await SigningStargateClient.connectWithSigner(addr,signer,{registry});
				let msg = this.eventPlanet({ value: EventPlanet.fromPartial(value) })
				return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo)
			} catch (e: any) {
				throw new Error('TxClient:sendEventPlanet: Could not broadcast Tx: '+ e.message)
			}
		},
		
		async sendMsgGuildUpdateEntrySubstationId({ value, fee, memo }: sendMsgGuildUpdateEntrySubstationIdParams): Promise<DeliverTxResponse> {
			if (!signer) {
					throw new Error('TxClient:sendMsgGuildUpdateEntrySubstationId: Unable to sign Tx. Signer is not present.')
			}
			try {			
				const { address } = (await signer.getAccounts())[0]; 
				const signingClient = await SigningStargateClient.connectWithSigner(addr,signer,{registry});
				let msg = this.msgGuildUpdateEntrySubstationId({ value: MsgGuildUpdateEntrySubstationId.fromPartial(value) })
				return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo)
			} catch (e: any) {
				throw new Error('TxClient:sendMsgGuildUpdateEntrySubstationId: Could not broadcast Tx: '+ e.message)
			}
		},
		
		async sendAddressActivity({ value, fee, memo }: sendAddressActivityParams): Promise<DeliverTxResponse> {
			if (!signer) {
					throw new Error('TxClient:sendAddressActivity: Unable to sign Tx. Signer is not present.')
			}
			try {			
				const { address } = (await signer.getAccounts())[0]; 
				const signingClient = await SigningStargateClient.connectWithSigner(addr,signer,{registry});
				let msg = this.addressActivity({ value: AddressActivity.fromPartial(value) })
				return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo)
			} catch (e: any) {
				throw new Error('TxClient:sendAddressActivity: Could not broadcast Tx: '+ e.message)
			}
		},
		
		async sendEventAlphaInfuse({ value, fee, memo }: sendEventAlphaInfuseParams): Promise<DeliverTxResponse> {
			if (!signer) {
					throw new Error('TxClient:sendEventAlphaInfuse: Unable to sign Tx. Signer is not present.')
			}
			try {			
				const { address } = (await signer.getAccounts())[0]; 
				const signingClient = await SigningStargateClient.connectWithSigner(addr,signer,{registry});
				let msg = this.eventAlphaInfuse({ value: EventAlphaInfuse.fromPartial(value) })
				return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo)
			} catch (e: any) {
				throw new Error('TxClient:sendEventAlphaInfuse: Could not broadcast Tx: '+ e.message)
			}
		},
		
		async sendMsgUpdateParamsResponse({ value, fee, memo }: sendMsgUpdateParamsResponseParams): Promise<DeliverTxResponse> {
			if (!signer) {
					throw new Error('TxClient:sendMsgUpdateParamsResponse: Unable to sign Tx. Signer is not present.')
			}
			try {			
				const { address } = (await signer.getAccounts())[0]; 
				const signingClient = await SigningStargateClient.connectWithSigner(addr,signer,{registry});
				let msg = this.msgUpdateParamsResponse({ value: MsgUpdateParamsResponse.fromPartial(value) })
				return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo)
			} catch (e: any) {
				throw new Error('TxClient:sendMsgUpdateParamsResponse: Could not broadcast Tx: '+ e.message)
			}
		},
		
		async sendMsgStructOreRefineryComplete({ value, fee, memo }: sendMsgStructOreRefineryCompleteParams): Promise<DeliverTxResponse> {
			if (!signer) {
					throw new Error('TxClient:sendMsgStructOreRefineryComplete: Unable to sign Tx. Signer is not present.')
			}
			try {			
				const { address } = (await signer.getAccounts())[0]; 
				const signingClient = await SigningStargateClient.connectWithSigner(addr,signer,{registry});
				let msg = this.msgStructOreRefineryComplete({ value: MsgStructOreRefineryComplete.fromPartial(value) })
				return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo)
			} catch (e: any) {
				throw new Error('TxClient:sendMsgStructOreRefineryComplete: Could not broadcast Tx: '+ e.message)
			}
		},
		
		async sendQueryAllPlayerHaltedRequest({ value, fee, memo }: sendQueryAllPlayerHaltedRequestParams): Promise<DeliverTxResponse> {
			if (!signer) {
					throw new Error('TxClient:sendQueryAllPlayerHaltedRequest: Unable to sign Tx. Signer is not present.')
			}
			try {			
				const { address } = (await signer.getAccounts())[0]; 
				const signingClient = await SigningStargateClient.connectWithSigner(addr,signer,{registry});
				let msg = this.queryAllPlayerHaltedRequest({ value: QueryAllPlayerHaltedRequest.fromPartial(value) })
				return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo)
			} catch (e: any) {
				throw new Error('TxClient:sendQueryAllPlayerHaltedRequest: Could not broadcast Tx: '+ e.message)
			}
		},
		
		async sendEventAlphaDefuse({ value, fee, memo }: sendEventAlphaDefuseParams): Promise<DeliverTxResponse> {
			if (!signer) {
					throw new Error('TxClient:sendEventAlphaDefuse: Unable to sign Tx. Signer is not present.')
			}
			try {			
				const { address } = (await signer.getAccounts())[0]; 
				const signingClient = await SigningStargateClient.connectWithSigner(addr,signer,{registry});
				let msg = this.eventAlphaDefuse({ value: EventAlphaDefuse.fromPartial(value) })
				return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo)
			} catch (e: any) {
				throw new Error('TxClient:sendEventAlphaDefuse: Could not broadcast Tx: '+ e.message)
			}
		},
		
		async sendQueryAllAddressResponse({ value, fee, memo }: sendQueryAllAddressResponseParams): Promise<DeliverTxResponse> {
			if (!signer) {
					throw new Error('TxClient:sendQueryAllAddressResponse: Unable to sign Tx. Signer is not present.')
			}
			try {			
				const { address } = (await signer.getAccounts())[0]; 
				const signingClient = await SigningStargateClient.connectWithSigner(addr,signer,{registry});
				let msg = this.queryAllAddressResponse({ value: QueryAllAddressResponse.fromPartial(value) })
				return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo)
			} catch (e: any) {
				throw new Error('TxClient:sendQueryAllAddressResponse: Could not broadcast Tx: '+ e.message)
			}
		},
		
		async sendQueryGetPermissionResponse({ value, fee, memo }: sendQueryGetPermissionResponseParams): Promise<DeliverTxResponse> {
			if (!signer) {
					throw new Error('TxClient:sendQueryGetPermissionResponse: Unable to sign Tx. Signer is not present.')
			}
			try {			
				const { address } = (await signer.getAccounts())[0]; 
				const signingClient = await SigningStargateClient.connectWithSigner(addr,signer,{registry});
				let msg = this.queryGetPermissionResponse({ value: QueryGetPermissionResponse.fromPartial(value) })
				return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo)
			} catch (e: any) {
				throw new Error('TxClient:sendQueryGetPermissionResponse: Could not broadcast Tx: '+ e.message)
			}
		},
		
		async sendQueryGetPlanetAttributeRequest({ value, fee, memo }: sendQueryGetPlanetAttributeRequestParams): Promise<DeliverTxResponse> {
			if (!signer) {
					throw new Error('TxClient:sendQueryGetPlanetAttributeRequest: Unable to sign Tx. Signer is not present.')
			}
			try {			
				const { address } = (await signer.getAccounts())[0]; 
				const signingClient = await SigningStargateClient.connectWithSigner(addr,signer,{registry});
				let msg = this.queryGetPlanetAttributeRequest({ value: QueryGetPlanetAttributeRequest.fromPartial(value) })
				return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo)
			} catch (e: any) {
				throw new Error('TxClient:sendQueryGetPlanetAttributeRequest: Could not broadcast Tx: '+ e.message)
			}
		},
		
		async sendEventPermission({ value, fee, memo }: sendEventPermissionParams): Promise<DeliverTxResponse> {
			if (!signer) {
					throw new Error('TxClient:sendEventPermission: Unable to sign Tx. Signer is not present.')
			}
			try {			
				const { address } = (await signer.getAccounts())[0]; 
				const signingClient = await SigningStargateClient.connectWithSigner(addr,signer,{registry});
				let msg = this.eventPermission({ value: EventPermission.fromPartial(value) })
				return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo)
			} catch (e: any) {
				throw new Error('TxClient:sendEventPermission: Could not broadcast Tx: '+ e.message)
			}
		},
		
		async sendEventOreTheftDetail({ value, fee, memo }: sendEventOreTheftDetailParams): Promise<DeliverTxResponse> {
			if (!signer) {
					throw new Error('TxClient:sendEventOreTheftDetail: Unable to sign Tx. Signer is not present.')
			}
			try {			
				const { address } = (await signer.getAccounts())[0]; 
				const signingClient = await SigningStargateClient.connectWithSigner(addr,signer,{registry});
				let msg = this.eventOreTheftDetail({ value: EventOreTheftDetail.fromPartial(value) })
				return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo)
			} catch (e: any) {
				throw new Error('TxClient:sendEventOreTheftDetail: Could not broadcast Tx: '+ e.message)
			}
		},
		
		async sendQueryGetPlanetResponse({ value, fee, memo }: sendQueryGetPlanetResponseParams): Promise<DeliverTxResponse> {
			if (!signer) {
					throw new Error('TxClient:sendQueryGetPlanetResponse: Unable to sign Tx. Signer is not present.')
			}
			try {			
				const { address } = (await signer.getAccounts())[0]; 
				const signingClient = await SigningStargateClient.connectWithSigner(addr,signer,{registry});
				let msg = this.queryGetPlanetResponse({ value: QueryGetPlanetResponse.fromPartial(value) })
				return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo)
			} catch (e: any) {
				throw new Error('TxClient:sendQueryGetPlanetResponse: Could not broadcast Tx: '+ e.message)
			}
		},
		
		async sendInfusion({ value, fee, memo }: sendInfusionParams): Promise<DeliverTxResponse> {
			if (!signer) {
					throw new Error('TxClient:sendInfusion: Unable to sign Tx. Signer is not present.')
			}
			try {			
				const { address } = (await signer.getAccounts())[0]; 
				const signingClient = await SigningStargateClient.connectWithSigner(addr,signer,{registry});
				let msg = this.infusion({ value: Infusion.fromPartial(value) })
				return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo)
			} catch (e: any) {
				throw new Error('TxClient:sendInfusion: Could not broadcast Tx: '+ e.message)
			}
		},
		
		async sendMsgGuildCreate({ value, fee, memo }: sendMsgGuildCreateParams): Promise<DeliverTxResponse> {
			if (!signer) {
					throw new Error('TxClient:sendMsgGuildCreate: Unable to sign Tx. Signer is not present.')
			}
			try {			
				const { address } = (await signer.getAccounts())[0]; 
				const signingClient = await SigningStargateClient.connectWithSigner(addr,signer,{registry});
				let msg = this.msgGuildCreate({ value: MsgGuildCreate.fromPartial(value) })
				return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo)
			} catch (e: any) {
				throw new Error('TxClient:sendMsgGuildCreate: Could not broadcast Tx: '+ e.message)
			}
		},
		
		async sendMsgGuildMembershipRequest({ value, fee, memo }: sendMsgGuildMembershipRequestParams): Promise<DeliverTxResponse> {
			if (!signer) {
					throw new Error('TxClient:sendMsgGuildMembershipRequest: Unable to sign Tx. Signer is not present.')
			}
			try {			
				const { address } = (await signer.getAccounts())[0]; 
				const signingClient = await SigningStargateClient.connectWithSigner(addr,signer,{registry});
				let msg = this.msgGuildMembershipRequest({ value: MsgGuildMembershipRequest.fromPartial(value) })
				return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo)
			} catch (e: any) {
				throw new Error('TxClient:sendMsgGuildMembershipRequest: Could not broadcast Tx: '+ e.message)
			}
		},
		
		async sendMsgPlayerUpdatePrimaryAddressResponse({ value, fee, memo }: sendMsgPlayerUpdatePrimaryAddressResponseParams): Promise<DeliverTxResponse> {
			if (!signer) {
					throw new Error('TxClient:sendMsgPlayerUpdatePrimaryAddressResponse: Unable to sign Tx. Signer is not present.')
			}
			try {			
				const { address } = (await signer.getAccounts())[0]; 
				const signingClient = await SigningStargateClient.connectWithSigner(addr,signer,{registry});
				let msg = this.msgPlayerUpdatePrimaryAddressResponse({ value: MsgPlayerUpdatePrimaryAddressResponse.fromPartial(value) })
				return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo)
			} catch (e: any) {
				throw new Error('TxClient:sendMsgPlayerUpdatePrimaryAddressResponse: Could not broadcast Tx: '+ e.message)
			}
		},
		
		async sendMsgAgreementClose({ value, fee, memo }: sendMsgAgreementCloseParams): Promise<DeliverTxResponse> {
			if (!signer) {
					throw new Error('TxClient:sendMsgAgreementClose: Unable to sign Tx. Signer is not present.')
			}
			try {			
				const { address } = (await signer.getAccounts())[0]; 
				const signingClient = await SigningStargateClient.connectWithSigner(addr,signer,{registry});
				let msg = this.msgAgreementClose({ value: MsgAgreementClose.fromPartial(value) })
				return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo)
			} catch (e: any) {
				throw new Error('TxClient:sendMsgAgreementClose: Could not broadcast Tx: '+ e.message)
			}
		},
		
		async sendQueryGetAgreementResponse({ value, fee, memo }: sendQueryGetAgreementResponseParams): Promise<DeliverTxResponse> {
			if (!signer) {
					throw new Error('TxClient:sendQueryGetAgreementResponse: Unable to sign Tx. Signer is not present.')
			}
			try {			
				const { address } = (await signer.getAccounts())[0]; 
				const signingClient = await SigningStargateClient.connectWithSigner(addr,signer,{registry});
				let msg = this.queryGetAgreementResponse({ value: QueryGetAgreementResponse.fromPartial(value) })
				return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo)
			} catch (e: any) {
				throw new Error('TxClient:sendQueryGetAgreementResponse: Could not broadcast Tx: '+ e.message)
			}
		},
		
		async sendEventOreMigrate({ value, fee, memo }: sendEventOreMigrateParams): Promise<DeliverTxResponse> {
			if (!signer) {
					throw new Error('TxClient:sendEventOreMigrate: Unable to sign Tx. Signer is not present.')
			}
			try {			
				const { address } = (await signer.getAccounts())[0]; 
				const signingClient = await SigningStargateClient.connectWithSigner(addr,signer,{registry});
				let msg = this.eventOreMigrate({ value: EventOreMigrate.fromPartial(value) })
				return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo)
			} catch (e: any) {
				throw new Error('TxClient:sendEventOreMigrate: Could not broadcast Tx: '+ e.message)
			}
		},
		
		async sendMsgGuildCreateResponse({ value, fee, memo }: sendMsgGuildCreateResponseParams): Promise<DeliverTxResponse> {
			if (!signer) {
					throw new Error('TxClient:sendMsgGuildCreateResponse: Unable to sign Tx. Signer is not present.')
			}
			try {			
				const { address } = (await signer.getAccounts())[0]; 
				const signingClient = await SigningStargateClient.connectWithSigner(addr,signer,{registry});
				let msg = this.msgGuildCreateResponse({ value: MsgGuildCreateResponse.fromPartial(value) })
				return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo)
			} catch (e: any) {
				throw new Error('TxClient:sendMsgGuildCreateResponse: Could not broadcast Tx: '+ e.message)
			}
		},
		
		async sendMsgProviderGuildGrant({ value, fee, memo }: sendMsgProviderGuildGrantParams): Promise<DeliverTxResponse> {
			if (!signer) {
					throw new Error('TxClient:sendMsgProviderGuildGrant: Unable to sign Tx. Signer is not present.')
			}
			try {			
				const { address } = (await signer.getAccounts())[0]; 
				const signingClient = await SigningStargateClient.connectWithSigner(addr,signer,{registry});
				let msg = this.msgProviderGuildGrant({ value: MsgProviderGuildGrant.fromPartial(value) })
				return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo)
			} catch (e: any) {
				throw new Error('TxClient:sendMsgProviderGuildGrant: Could not broadcast Tx: '+ e.message)
			}
		},
		
		async sendQueryAddressResponse({ value, fee, memo }: sendQueryAddressResponseParams): Promise<DeliverTxResponse> {
			if (!signer) {
					throw new Error('TxClient:sendQueryAddressResponse: Unable to sign Tx. Signer is not present.')
			}
			try {			
				const { address } = (await signer.getAccounts())[0]; 
				const signingClient = await SigningStargateClient.connectWithSigner(addr,signer,{registry});
				let msg = this.queryAddressResponse({ value: QueryAddressResponse.fromPartial(value) })
				return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo)
			} catch (e: any) {
				throw new Error('TxClient:sendQueryAddressResponse: Could not broadcast Tx: '+ e.message)
			}
		},
		
		async sendMsgGuildMembershipRequestDeny({ value, fee, memo }: sendMsgGuildMembershipRequestDenyParams): Promise<DeliverTxResponse> {
			if (!signer) {
					throw new Error('TxClient:sendMsgGuildMembershipRequestDeny: Unable to sign Tx. Signer is not present.')
			}
			try {			
				const { address } = (await signer.getAccounts())[0]; 
				const signingClient = await SigningStargateClient.connectWithSigner(addr,signer,{registry});
				let msg = this.msgGuildMembershipRequestDeny({ value: MsgGuildMembershipRequestDeny.fromPartial(value) })
				return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo)
			} catch (e: any) {
				throw new Error('TxClient:sendMsgGuildMembershipRequestDeny: Could not broadcast Tx: '+ e.message)
			}
		},
		
		async sendMsgStructDeactivate({ value, fee, memo }: sendMsgStructDeactivateParams): Promise<DeliverTxResponse> {
			if (!signer) {
					throw new Error('TxClient:sendMsgStructDeactivate: Unable to sign Tx. Signer is not present.')
			}
			try {			
				const { address } = (await signer.getAccounts())[0]; 
				const signingClient = await SigningStargateClient.connectWithSigner(addr,signer,{registry});
				let msg = this.msgStructDeactivate({ value: MsgStructDeactivate.fromPartial(value) })
				return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo)
			} catch (e: any) {
				throw new Error('TxClient:sendMsgStructDeactivate: Could not broadcast Tx: '+ e.message)
			}
		},
		
		async sendMsgProviderResponse({ value, fee, memo }: sendMsgProviderResponseParams): Promise<DeliverTxResponse> {
			if (!signer) {
					throw new Error('TxClient:sendMsgProviderResponse: Unable to sign Tx. Signer is not present.')
			}
			try {			
				const { address } = (await signer.getAccounts())[0]; 
				const signingClient = await SigningStargateClient.connectWithSigner(addr,signer,{registry});
				let msg = this.msgProviderResponse({ value: MsgProviderResponse.fromPartial(value) })
				return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo)
			} catch (e: any) {
				throw new Error('TxClient:sendMsgProviderResponse: Could not broadcast Tx: '+ e.message)
			}
		},
		
		async sendQueryAllPlanetResponse({ value, fee, memo }: sendQueryAllPlanetResponseParams): Promise<DeliverTxResponse> {
			if (!signer) {
					throw new Error('TxClient:sendQueryAllPlanetResponse: Unable to sign Tx. Signer is not present.')
			}
			try {			
				const { address } = (await signer.getAccounts())[0]; 
				const signingClient = await SigningStargateClient.connectWithSigner(addr,signer,{registry});
				let msg = this.queryAllPlanetResponse({ value: QueryAllPlanetResponse.fromPartial(value) })
				return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo)
			} catch (e: any) {
				throw new Error('TxClient:sendQueryAllPlanetResponse: Could not broadcast Tx: '+ e.message)
			}
		},
		
		async sendQueryAllProviderResponse({ value, fee, memo }: sendQueryAllProviderResponseParams): Promise<DeliverTxResponse> {
			if (!signer) {
					throw new Error('TxClient:sendQueryAllProviderResponse: Unable to sign Tx. Signer is not present.')
			}
			try {			
				const { address } = (await signer.getAccounts())[0]; 
				const signingClient = await SigningStargateClient.connectWithSigner(addr,signer,{registry});
				let msg = this.queryAllProviderResponse({ value: QueryAllProviderResponse.fromPartial(value) })
				return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo)
			} catch (e: any) {
				throw new Error('TxClient:sendQueryAllProviderResponse: Could not broadcast Tx: '+ e.message)
			}
		},
		
		async sendEventAlphaInfuseDetail({ value, fee, memo }: sendEventAlphaInfuseDetailParams): Promise<DeliverTxResponse> {
			if (!signer) {
					throw new Error('TxClient:sendEventAlphaInfuseDetail: Unable to sign Tx. Signer is not present.')
			}
			try {			
				const { address } = (await signer.getAccounts())[0]; 
				const signingClient = await SigningStargateClient.connectWithSigner(addr,signer,{registry});
				let msg = this.eventAlphaInfuseDetail({ value: EventAlphaInfuseDetail.fromPartial(value) })
				return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo)
			} catch (e: any) {
				throw new Error('TxClient:sendEventAlphaInfuseDetail: Could not broadcast Tx: '+ e.message)
			}
		},
		
		
		msgFleetMoveResponse({ value }: msgFleetMoveResponseParams): EncodeObject {
			try {
				return { typeUrl: "/structs.structs.MsgFleetMoveResponse", value: MsgFleetMoveResponse.fromPartial( value ) }  
			} catch (e: any) {
				throw new Error('TxClient:MsgFleetMoveResponse: Could not create message: ' + e.message)
			}
		},
		
		msgPermissionSetOnObject({ value }: msgPermissionSetOnObjectParams): EncodeObject {
			try {
				return { typeUrl: "/structs.structs.MsgPermissionSetOnObject", value: MsgPermissionSetOnObject.fromPartial( value ) }  
			} catch (e: any) {
				throw new Error('TxClient:MsgPermissionSetOnObject: Could not create message: ' + e.message)
			}
		},
		
		eventGuild({ value }: eventGuildParams): EncodeObject {
			try {
				return { typeUrl: "/structs.structs.EventGuild", value: EventGuild.fromPartial( value ) }  
			} catch (e: any) {
				throw new Error('TxClient:EventGuild: Could not create message: ' + e.message)
			}
		},
		
		eventOreTheft({ value }: eventOreTheftParams): EncodeObject {
			try {
				return { typeUrl: "/structs.structs.EventOreTheft", value: EventOreTheft.fromPartial( value ) }  
			} catch (e: any) {
				throw new Error('TxClient:EventOreTheft: Could not create message: ' + e.message)
			}
		},
		
		msgStructMove({ value }: msgStructMoveParams): EncodeObject {
			try {
				return { typeUrl: "/structs.structs.MsgStructMove", value: MsgStructMove.fromPartial( value ) }  
			} catch (e: any) {
				throw new Error('TxClient:MsgStructMove: Could not create message: ' + e.message)
			}
		},
		
		msgStructOreMinerComplete({ value }: msgStructOreMinerCompleteParams): EncodeObject {
			try {
				return { typeUrl: "/structs.structs.MsgStructOreMinerComplete", value: MsgStructOreMinerComplete.fromPartial( value ) }  
			} catch (e: any) {
				throw new Error('TxClient:MsgStructOreMinerComplete: Could not create message: ' + e.message)
			}
		},
		
		queryAllAddressByPlayerRequest({ value }: queryAllAddressByPlayerRequestParams): EncodeObject {
			try {
				return { typeUrl: "/structs.structs.QueryAllAddressByPlayerRequest", value: QueryAllAddressByPlayerRequest.fromPartial( value ) }  
			} catch (e: any) {
				throw new Error('TxClient:QueryAllAddressByPlayerRequest: Could not create message: ' + e.message)
			}
		},
		
		eventOreMigrateDetail({ value }: eventOreMigrateDetailParams): EncodeObject {
			try {
				return { typeUrl: "/structs.structs.EventOreMigrateDetail", value: EventOreMigrateDetail.fromPartial( value ) }  
			} catch (e: any) {
				throw new Error('TxClient:EventOreMigrateDetail: Could not create message: ' + e.message)
			}
		},
		
		msgGuildBankRedeemResponse({ value }: msgGuildBankRedeemResponseParams): EncodeObject {
			try {
				return { typeUrl: "/structs.structs.MsgGuildBankRedeemResponse", value: MsgGuildBankRedeemResponse.fromPartial( value ) }  
			} catch (e: any) {
				throw new Error('TxClient:MsgGuildBankRedeemResponse: Could not create message: ' + e.message)
			}
		},
		
		msgStructBuildComplete({ value }: msgStructBuildCompleteParams): EncodeObject {
			try {
				return { typeUrl: "/structs.structs.MsgStructBuildComplete", value: MsgStructBuildComplete.fromPartial( value ) }  
			} catch (e: any) {
				throw new Error('TxClient:MsgStructBuildComplete: Could not create message: ' + e.message)
			}
		},
		
		msgStructDefenseSet({ value }: msgStructDefenseSetParams): EncodeObject {
			try {
				return { typeUrl: "/structs.structs.MsgStructDefenseSet", value: MsgStructDefenseSet.fromPartial( value ) }  
			} catch (e: any) {
				throw new Error('TxClient:MsgStructDefenseSet: Could not create message: ' + e.message)
			}
		},
		
		msgProviderUpdateAccessPolicy({ value }: msgProviderUpdateAccessPolicyParams): EncodeObject {
			try {
				return { typeUrl: "/structs.structs.MsgProviderUpdateAccessPolicy", value: MsgProviderUpdateAccessPolicy.fromPartial( value ) }  
			} catch (e: any) {
				throw new Error('TxClient:MsgProviderUpdateAccessPolicy: Could not create message: ' + e.message)
			}
		},
		
		queryAllFleetRequest({ value }: queryAllFleetRequestParams): EncodeObject {
			try {
				return { typeUrl: "/structs.structs.QueryAllFleetRequest", value: QueryAllFleetRequest.fromPartial( value ) }  
			} catch (e: any) {
				throw new Error('TxClient:QueryAllFleetRequest: Could not create message: ' + e.message)
			}
		},
		
		msgAllocationCreate({ value }: msgAllocationCreateParams): EncodeObject {
			try {
				return { typeUrl: "/structs.structs.MsgAllocationCreate", value: MsgAllocationCreate.fromPartial( value ) }  
			} catch (e: any) {
				throw new Error('TxClient:MsgAllocationCreate: Could not create message: ' + e.message)
			}
		},
		
		msgPermissionResponse({ value }: msgPermissionResponseParams): EncodeObject {
			try {
				return { typeUrl: "/structs.structs.MsgPermissionResponse", value: MsgPermissionResponse.fromPartial( value ) }  
			} catch (e: any) {
				throw new Error('TxClient:MsgPermissionResponse: Could not create message: ' + e.message)
			}
		},
		
		queryParamsRequest({ value }: queryParamsRequestParams): EncodeObject {
			try {
				return { typeUrl: "/structs.structs.QueryParamsRequest", value: QueryParamsRequest.fromPartial( value ) }  
			} catch (e: any) {
				throw new Error('TxClient:QueryParamsRequest: Could not create message: ' + e.message)
			}
		},
		
		queryAllFleetResponse({ value }: queryAllFleetResponseParams): EncodeObject {
			try {
				return { typeUrl: "/structs.structs.QueryAllFleetResponse", value: QueryAllFleetResponse.fromPartial( value ) }  
			} catch (e: any) {
				throw new Error('TxClient:QueryAllFleetResponse: Could not create message: ' + e.message)
			}
		},
		
		playerInventory({ value }: playerInventoryParams): EncodeObject {
			try {
				return { typeUrl: "/structs.structs.PlayerInventory", value: PlayerInventory.fromPartial( value ) }  
			} catch (e: any) {
				throw new Error('TxClient:PlayerInventory: Could not create message: ' + e.message)
			}
		},
		
		eventProviderGrantGuildDetail({ value }: eventProviderGrantGuildDetailParams): EncodeObject {
			try {
				return { typeUrl: "/structs.structs.EventProviderGrantGuildDetail", value: EventProviderGrantGuildDetail.fromPartial( value ) }  
			} catch (e: any) {
				throw new Error('TxClient:EventProviderGrantGuildDetail: Could not create message: ' + e.message)
			}
		},
		
		eventGuildBankMintDetail({ value }: eventGuildBankMintDetailParams): EncodeObject {
			try {
				return { typeUrl: "/structs.structs.EventGuildBankMintDetail", value: EventGuildBankMintDetail.fromPartial( value ) }  
			} catch (e: any) {
				throw new Error('TxClient:EventGuildBankMintDetail: Could not create message: ' + e.message)
			}
		},
		
		msgSubstationCreateResponse({ value }: msgSubstationCreateResponseParams): EncodeObject {
			try {
				return { typeUrl: "/structs.structs.MsgSubstationCreateResponse", value: MsgSubstationCreateResponse.fromPartial( value ) }  
			} catch (e: any) {
				throw new Error('TxClient:MsgSubstationCreateResponse: Could not create message: ' + e.message)
			}
		},
		
		msgSubstationPlayerMigrateResponse({ value }: msgSubstationPlayerMigrateResponseParams): EncodeObject {
			try {
				return { typeUrl: "/structs.structs.MsgSubstationPlayerMigrateResponse", value: MsgSubstationPlayerMigrateResponse.fromPartial( value ) }  
			} catch (e: any) {
				throw new Error('TxClient:MsgSubstationPlayerMigrateResponse: Could not create message: ' + e.message)
			}
		},
		
		msgProviderUpdateCapacityMinimum({ value }: msgProviderUpdateCapacityMinimumParams): EncodeObject {
			try {
				return { typeUrl: "/structs.structs.MsgProviderUpdateCapacityMinimum", value: MsgProviderUpdateCapacityMinimum.fromPartial( value ) }  
			} catch (e: any) {
				throw new Error('TxClient:MsgProviderUpdateCapacityMinimum: Could not create message: ' + e.message)
			}
		},
		
		queryGetGuildMembershipApplicationResponse({ value }: queryGetGuildMembershipApplicationResponseParams): EncodeObject {
			try {
				return { typeUrl: "/structs.structs.QueryGetGuildMembershipApplicationResponse", value: QueryGetGuildMembershipApplicationResponse.fromPartial( value ) }  
			} catch (e: any) {
				throw new Error('TxClient:QueryGetGuildMembershipApplicationResponse: Could not create message: ' + e.message)
			}
		},
		
		queryGetPlayerResponse({ value }: queryGetPlayerResponseParams): EncodeObject {
			try {
				return { typeUrl: "/structs.structs.QueryGetPlayerResponse", value: QueryGetPlayerResponse.fromPartial( value ) }  
			} catch (e: any) {
				throw new Error('TxClient:QueryGetPlayerResponse: Could not create message: ' + e.message)
			}
		},
		
		queryGetSubstationResponse({ value }: queryGetSubstationResponseParams): EncodeObject {
			try {
				return { typeUrl: "/structs.structs.QueryGetSubstationResponse", value: QueryGetSubstationResponse.fromPartial( value ) }  
			} catch (e: any) {
				throw new Error('TxClient:QueryGetSubstationResponse: Could not create message: ' + e.message)
			}
		},
		
		structDefender({ value }: structDefenderParams): EncodeObject {
			try {
				return { typeUrl: "/structs.structs.StructDefender", value: StructDefender.fromPartial( value ) }  
			} catch (e: any) {
				throw new Error('TxClient:StructDefender: Could not create message: ' + e.message)
			}
		},
		
		msgReactorDefuseResponse({ value }: msgReactorDefuseResponseParams): EncodeObject {
			try {
				return { typeUrl: "/structs.structs.MsgReactorDefuseResponse", value: MsgReactorDefuseResponse.fromPartial( value ) }  
			} catch (e: any) {
				throw new Error('TxClient:MsgReactorDefuseResponse: Could not create message: ' + e.message)
			}
		},
		
		msgStructAttack({ value }: msgStructAttackParams): EncodeObject {
			try {
				return { typeUrl: "/structs.structs.MsgStructAttack", value: MsgStructAttack.fromPartial( value ) }  
			} catch (e: any) {
				throw new Error('TxClient:MsgStructAttack: Could not create message: ' + e.message)
			}
		},
		
		eventTime({ value }: eventTimeParams): EncodeObject {
			try {
				return { typeUrl: "/structs.structs.EventTime", value: EventTime.fromPartial( value ) }  
			} catch (e: any) {
				throw new Error('TxClient:EventTime: Could not create message: ' + e.message)
			}
		},
		
		msgSubstationDelete({ value }: msgSubstationDeleteParams): EncodeObject {
			try {
				return { typeUrl: "/structs.structs.MsgSubstationDelete", value: MsgSubstationDelete.fromPartial( value ) }  
			} catch (e: any) {
				throw new Error('TxClient:MsgSubstationDelete: Could not create message: ' + e.message)
			}
		},
		
		guild({ value }: guildParams): EncodeObject {
			try {
				return { typeUrl: "/structs.structs.Guild", value: Guild.fromPartial( value ) }  
			} catch (e: any) {
				throw new Error('TxClient:Guild: Could not create message: ' + e.message)
			}
		},
		
		queryGetProviderRequest({ value }: queryGetProviderRequestParams): EncodeObject {
			try {
				return { typeUrl: "/structs.structs.QueryGetProviderRequest", value: QueryGetProviderRequest.fromPartial( value ) }  
			} catch (e: any) {
				throw new Error('TxClient:QueryGetProviderRequest: Could not create message: ' + e.message)
			}
		},
		
		msgAllocationUpdate({ value }: msgAllocationUpdateParams): EncodeObject {
			try {
				return { typeUrl: "/structs.structs.MsgAllocationUpdate", value: MsgAllocationUpdate.fromPartial( value ) }  
			} catch (e: any) {
				throw new Error('TxClient:MsgAllocationUpdate: Could not create message: ' + e.message)
			}
		},
		
		msgSubstationPlayerDisconnectResponse({ value }: msgSubstationPlayerDisconnectResponseParams): EncodeObject {
			try {
				return { typeUrl: "/structs.structs.MsgSubstationPlayerDisconnectResponse", value: MsgSubstationPlayerDisconnectResponse.fromPartial( value ) }  
			} catch (e: any) {
				throw new Error('TxClient:MsgSubstationPlayerDisconnectResponse: Could not create message: ' + e.message)
			}
		},
		
		eventAlphaRefineDetail({ value }: eventAlphaRefineDetailParams): EncodeObject {
			try {
				return { typeUrl: "/structs.structs.EventAlphaRefineDetail", value: EventAlphaRefineDetail.fromPartial( value ) }  
			} catch (e: any) {
				throw new Error('TxClient:EventAlphaRefineDetail: Could not create message: ' + e.message)
			}
		},
		
		msgAllocationDeleteResponse({ value }: msgAllocationDeleteResponseParams): EncodeObject {
			try {
				return { typeUrl: "/structs.structs.MsgAllocationDeleteResponse", value: MsgAllocationDeleteResponse.fromPartial( value ) }  
			} catch (e: any) {
				throw new Error('TxClient:MsgAllocationDeleteResponse: Could not create message: ' + e.message)
			}
		},
		
		msgGuildMembershipInviteRevoke({ value }: msgGuildMembershipInviteRevokeParams): EncodeObject {
			try {
				return { typeUrl: "/structs.structs.MsgGuildMembershipInviteRevoke", value: MsgGuildMembershipInviteRevoke.fromPartial( value ) }  
			} catch (e: any) {
				throw new Error('TxClient:MsgGuildMembershipInviteRevoke: Could not create message: ' + e.message)
			}
		},
		
		msgProviderUpdateDurationMinimum({ value }: msgProviderUpdateDurationMinimumParams): EncodeObject {
			try {
				return { typeUrl: "/structs.structs.MsgProviderUpdateDurationMinimum", value: MsgProviderUpdateDurationMinimum.fromPartial( value ) }  
			} catch (e: any) {
				throw new Error('TxClient:MsgProviderUpdateDurationMinimum: Could not create message: ' + e.message)
			}
		},
		
		internalAddressAssociation({ value }: internalAddressAssociationParams): EncodeObject {
			try {
				return { typeUrl: "/structs.structs.InternalAddressAssociation", value: InternalAddressAssociation.fromPartial( value ) }  
			} catch (e: any) {
				throw new Error('TxClient:InternalAddressAssociation: Could not create message: ' + e.message)
			}
		},
		
		params({ value }: paramsParams): EncodeObject {
			try {
				return { typeUrl: "/structs.structs.Params", value: Params.fromPartial( value ) }  
			} catch (e: any) {
				throw new Error('TxClient:Params: Could not create message: ' + e.message)
			}
		},
		
		permissionRecord({ value }: permissionRecordParams): EncodeObject {
			try {
				return { typeUrl: "/structs.structs.PermissionRecord", value: PermissionRecord.fromPartial( value ) }  
			} catch (e: any) {
				throw new Error('TxClient:PermissionRecord: Could not create message: ' + e.message)
			}
		},
		
		eventReactor({ value }: eventReactorParams): EncodeObject {
			try {
				return { typeUrl: "/structs.structs.EventReactor", value: EventReactor.fromPartial( value ) }  
			} catch (e: any) {
				throw new Error('TxClient:EventReactor: Could not create message: ' + e.message)
			}
		},
		
		eventStructAttribute({ value }: eventStructAttributeParams): EncodeObject {
			try {
				return { typeUrl: "/structs.structs.EventStructAttribute", value: EventStructAttribute.fromPartial( value ) }  
			} catch (e: any) {
				throw new Error('TxClient:EventStructAttribute: Could not create message: ' + e.message)
			}
		},
		
		msgAddressRevoke({ value }: msgAddressRevokeParams): EncodeObject {
			try {
				return { typeUrl: "/structs.structs.MsgAddressRevoke", value: MsgAddressRevoke.fromPartial( value ) }  
			} catch (e: any) {
				throw new Error('TxClient:MsgAddressRevoke: Could not create message: ' + e.message)
			}
		},
		
		msgSubstationPlayerConnectResponse({ value }: msgSubstationPlayerConnectResponseParams): EncodeObject {
			try {
				return { typeUrl: "/structs.structs.MsgSubstationPlayerConnectResponse", value: MsgSubstationPlayerConnectResponse.fromPartial( value ) }  
			} catch (e: any) {
				throw new Error('TxClient:MsgSubstationPlayerConnectResponse: Could not create message: ' + e.message)
			}
		},
		
		queryGetFleetRequest({ value }: queryGetFleetRequestParams): EncodeObject {
			try {
				return { typeUrl: "/structs.structs.QueryGetFleetRequest", value: QueryGetFleetRequest.fromPartial( value ) }  
			} catch (e: any) {
				throw new Error('TxClient:QueryGetFleetRequest: Could not create message: ' + e.message)
			}
		},
		
		queryGetInfusionResponse({ value }: queryGetInfusionResponseParams): EncodeObject {
			try {
				return { typeUrl: "/structs.structs.QueryGetInfusionResponse", value: QueryGetInfusionResponse.fromPartial( value ) }  
			} catch (e: any) {
				throw new Error('TxClient:QueryGetInfusionResponse: Could not create message: ' + e.message)
			}
		},
		
		queryGetStructTypeRequest({ value }: queryGetStructTypeRequestParams): EncodeObject {
			try {
				return { typeUrl: "/structs.structs.QueryGetStructTypeRequest", value: QueryGetStructTypeRequest.fromPartial( value ) }  
			} catch (e: any) {
				throw new Error('TxClient:QueryGetStructTypeRequest: Could not create message: ' + e.message)
			}
		},
		
		eventAttackDefenderCounterDetail({ value }: eventAttackDefenderCounterDetailParams): EncodeObject {
			try {
				return { typeUrl: "/structs.structs.EventAttackDefenderCounterDetail", value: EventAttackDefenderCounterDetail.fromPartial( value ) }  
			} catch (e: any) {
				throw new Error('TxClient:EventAttackDefenderCounterDetail: Could not create message: ' + e.message)
			}
		},
		
		msgStructGeneratorInfuse({ value }: msgStructGeneratorInfuseParams): EncodeObject {
			try {
				return { typeUrl: "/structs.structs.MsgStructGeneratorInfuse", value: MsgStructGeneratorInfuse.fromPartial( value ) }  
			} catch (e: any) {
				throw new Error('TxClient:MsgStructGeneratorInfuse: Could not create message: ' + e.message)
			}
		},
		
		queryAllPlayerHaltedResponse({ value }: queryAllPlayerHaltedResponseParams): EncodeObject {
			try {
				return { typeUrl: "/structs.structs.QueryAllPlayerHaltedResponse", value: QueryAllPlayerHaltedResponse.fromPartial( value ) }  
			} catch (e: any) {
				throw new Error('TxClient:QueryAllPlayerHaltedResponse: Could not create message: ' + e.message)
			}
		},
		
		eventProviderRevokeGuildDetail({ value }: eventProviderRevokeGuildDetailParams): EncodeObject {
			try {
				return { typeUrl: "/structs.structs.EventProviderRevokeGuildDetail", value: EventProviderRevokeGuildDetail.fromPartial( value ) }  
			} catch (e: any) {
				throw new Error('TxClient:EventProviderRevokeGuildDetail: Could not create message: ' + e.message)
			}
		},
		
		planetAttributeRecord({ value }: planetAttributeRecordParams): EncodeObject {
			try {
				return { typeUrl: "/structs.structs.PlanetAttributeRecord", value: PlanetAttributeRecord.fromPartial( value ) }  
			} catch (e: any) {
				throw new Error('TxClient:PlanetAttributeRecord: Could not create message: ' + e.message)
			}
		},
		
		msgPlanetExploreResponse({ value }: msgPlanetExploreResponseParams): EncodeObject {
			try {
				return { typeUrl: "/structs.structs.MsgPlanetExploreResponse", value: MsgPlanetExploreResponse.fromPartial( value ) }  
			} catch (e: any) {
				throw new Error('TxClient:MsgPlanetExploreResponse: Could not create message: ' + e.message)
			}
		},
		
		queryGetStructTypeResponse({ value }: queryGetStructTypeResponseParams): EncodeObject {
			try {
				return { typeUrl: "/structs.structs.QueryGetStructTypeResponse", value: QueryGetStructTypeResponse.fromPartial( value ) }  
			} catch (e: any) {
				throw new Error('TxClient:QueryGetStructTypeResponse: Could not create message: ' + e.message)
			}
		},
		
		eventInfusion({ value }: eventInfusionParams): EncodeObject {
			try {
				return { typeUrl: "/structs.structs.EventInfusion", value: EventInfusion.fromPartial( value ) }  
			} catch (e: any) {
				throw new Error('TxClient:EventInfusion: Could not create message: ' + e.message)
			}
		},
		
		planetAttributes({ value }: planetAttributesParams): EncodeObject {
			try {
				return { typeUrl: "/structs.structs.PlanetAttributes", value: PlanetAttributes.fromPartial( value ) }  
			} catch (e: any) {
				throw new Error('TxClient:PlanetAttributes: Could not create message: ' + e.message)
			}
		},
		
		msgStructOreRefineryStatusResponse({ value }: msgStructOreRefineryStatusResponseParams): EncodeObject {
			try {
				return { typeUrl: "/structs.structs.MsgStructOreRefineryStatusResponse", value: MsgStructOreRefineryStatusResponse.fromPartial( value ) }  
			} catch (e: any) {
				throw new Error('TxClient:MsgStructOreRefineryStatusResponse: Could not create message: ' + e.message)
			}
		},
		
		queryAllAgreementByProviderRequest({ value }: queryAllAgreementByProviderRequestParams): EncodeObject {
			try {
				return { typeUrl: "/structs.structs.QueryAllAgreementByProviderRequest", value: QueryAllAgreementByProviderRequest.fromPartial( value ) }  
			} catch (e: any) {
				throw new Error('TxClient:QueryAllAgreementByProviderRequest: Could not create message: ' + e.message)
			}
		},
		
		queryAllGuildResponse({ value }: queryAllGuildResponseParams): EncodeObject {
			try {
				return { typeUrl: "/structs.structs.QueryAllGuildResponse", value: QueryAllGuildResponse.fromPartial( value ) }  
			} catch (e: any) {
				throw new Error('TxClient:QueryAllGuildResponse: Could not create message: ' + e.message)
			}
		},
		
		queryGetGuildMembershipApplicationRequest({ value }: queryGetGuildMembershipApplicationRequestParams): EncodeObject {
			try {
				return { typeUrl: "/structs.structs.QueryGetGuildMembershipApplicationRequest", value: QueryGetGuildMembershipApplicationRequest.fromPartial( value ) }  
			} catch (e: any) {
				throw new Error('TxClient:QueryGetGuildMembershipApplicationRequest: Could not create message: ' + e.message)
			}
		},
		
		queryGetProviderByCollateralAddressRequest({ value }: queryGetProviderByCollateralAddressRequestParams): EncodeObject {
			try {
				return { typeUrl: "/structs.structs.QueryGetProviderByCollateralAddressRequest", value: QueryGetProviderByCollateralAddressRequest.fromPartial( value ) }  
			} catch (e: any) {
				throw new Error('TxClient:QueryGetProviderByCollateralAddressRequest: Could not create message: ' + e.message)
			}
		},
		
		eventGuildBankAddressDetail({ value }: eventGuildBankAddressDetailParams): EncodeObject {
			try {
				return { typeUrl: "/structs.structs.EventGuildBankAddressDetail", value: EventGuildBankAddressDetail.fromPartial( value ) }  
			} catch (e: any) {
				throw new Error('TxClient:EventGuildBankAddressDetail: Could not create message: ' + e.message)
			}
		},
		
		msgGuildUpdateJoinInfusionMinimumBypassByRequest({ value }: msgGuildUpdateJoinInfusionMinimumBypassByRequestParams): EncodeObject {
			try {
				return { typeUrl: "/structs.structs.MsgGuildUpdateJoinInfusionMinimumBypassByRequest", value: MsgGuildUpdateJoinInfusionMinimumBypassByRequest.fromPartial( value ) }  
			} catch (e: any) {
				throw new Error('TxClient:MsgGuildUpdateJoinInfusionMinimumBypassByRequest: Could not create message: ' + e.message)
			}
		},
		
		msgPermissionRevokeOnAddress({ value }: msgPermissionRevokeOnAddressParams): EncodeObject {
			try {
				return { typeUrl: "/structs.structs.MsgPermissionRevokeOnAddress", value: MsgPermissionRevokeOnAddress.fromPartial( value ) }  
			} catch (e: any) {
				throw new Error('TxClient:MsgPermissionRevokeOnAddress: Could not create message: ' + e.message)
			}
		},
		
		queryParamsResponse({ value }: queryParamsResponseParams): EncodeObject {
			try {
				return { typeUrl: "/structs.structs.QueryParamsResponse", value: QueryParamsResponse.fromPartial( value ) }  
			} catch (e: any) {
				throw new Error('TxClient:QueryParamsResponse: Could not create message: ' + e.message)
			}
		},
		
		queryAllPlanetRequest({ value }: queryAllPlanetRequestParams): EncodeObject {
			try {
				return { typeUrl: "/structs.structs.QueryAllPlanetRequest", value: QueryAllPlanetRequest.fromPartial( value ) }  
			} catch (e: any) {
				throw new Error('TxClient:QueryAllPlanetRequest: Could not create message: ' + e.message)
			}
		},
		
		queryAllPlayerResponse({ value }: queryAllPlayerResponseParams): EncodeObject {
			try {
				return { typeUrl: "/structs.structs.QueryAllPlayerResponse", value: QueryAllPlayerResponse.fromPartial( value ) }  
			} catch (e: any) {
				throw new Error('TxClient:QueryAllPlayerResponse: Could not create message: ' + e.message)
			}
		},
		
		msgAddressRevokeResponse({ value }: msgAddressRevokeResponseParams): EncodeObject {
			try {
				return { typeUrl: "/structs.structs.MsgAddressRevokeResponse", value: MsgAddressRevokeResponse.fromPartial( value ) }  
			} catch (e: any) {
				throw new Error('TxClient:MsgAddressRevokeResponse: Could not create message: ' + e.message)
			}
		},
		
		msgStructActivate({ value }: msgStructActivateParams): EncodeObject {
			try {
				return { typeUrl: "/structs.structs.MsgStructActivate", value: MsgStructActivate.fromPartial( value ) }  
			} catch (e: any) {
				throw new Error('TxClient:MsgStructActivate: Could not create message: ' + e.message)
			}
		},
		
		msgStructGeneratorStatusResponse({ value }: msgStructGeneratorStatusResponseParams): EncodeObject {
			try {
				return { typeUrl: "/structs.structs.MsgStructGeneratorStatusResponse", value: MsgStructGeneratorStatusResponse.fromPartial( value ) }  
			} catch (e: any) {
				throw new Error('TxClient:MsgStructGeneratorStatusResponse: Could not create message: ' + e.message)
			}
		},
		
		msgAgreementCapacityIncrease({ value }: msgAgreementCapacityIncreaseParams): EncodeObject {
			try {
				return { typeUrl: "/structs.structs.MsgAgreementCapacityIncrease", value: MsgAgreementCapacityIncrease.fromPartial( value ) }  
			} catch (e: any) {
				throw new Error('TxClient:MsgAgreementCapacityIncrease: Could not create message: ' + e.message)
			}
		},
		
		queryGetGuildByBankCollateralAddressRequest({ value }: queryGetGuildByBankCollateralAddressRequestParams): EncodeObject {
			try {
				return { typeUrl: "/structs.structs.QueryGetGuildByBankCollateralAddressRequest", value: QueryGetGuildByBankCollateralAddressRequest.fromPartial( value ) }  
			} catch (e: any) {
				throw new Error('TxClient:QueryGetGuildByBankCollateralAddressRequest: Could not create message: ' + e.message)
			}
		},
		
		queryValidateSignatureRequest({ value }: queryValidateSignatureRequestParams): EncodeObject {
			try {
				return { typeUrl: "/structs.structs.QueryValidateSignatureRequest", value: QueryValidateSignatureRequest.fromPartial( value ) }  
			} catch (e: any) {
				throw new Error('TxClient:QueryValidateSignatureRequest: Could not create message: ' + e.message)
			}
		},
		
		msgPlanetRaidComplete({ value }: msgPlanetRaidCompleteParams): EncodeObject {
			try {
				return { typeUrl: "/structs.structs.MsgPlanetRaidComplete", value: MsgPlanetRaidComplete.fromPartial( value ) }  
			} catch (e: any) {
				throw new Error('TxClient:MsgPlanetRaidComplete: Could not create message: ' + e.message)
			}
		},
		
		queryAllAgreementRequest({ value }: queryAllAgreementRequestParams): EncodeObject {
			try {
				return { typeUrl: "/structs.structs.QueryAllAgreementRequest", value: QueryAllAgreementRequest.fromPartial( value ) }  
			} catch (e: any) {
				throw new Error('TxClient:QueryAllAgreementRequest: Could not create message: ' + e.message)
			}
		},
		
		queryAllStructResponse({ value }: queryAllStructResponseParams): EncodeObject {
			try {
				return { typeUrl: "/structs.structs.QueryAllStructResponse", value: QueryAllStructResponse.fromPartial( value ) }  
			} catch (e: any) {
				throw new Error('TxClient:QueryAllStructResponse: Could not create message: ' + e.message)
			}
		},
		
		queryAllSubstationResponse({ value }: queryAllSubstationResponseParams): EncodeObject {
			try {
				return { typeUrl: "/structs.structs.QueryAllSubstationResponse", value: QueryAllSubstationResponse.fromPartial( value ) }  
			} catch (e: any) {
				throw new Error('TxClient:QueryAllSubstationResponse: Could not create message: ' + e.message)
			}
		},
		
		eventPlayerResumed({ value }: eventPlayerResumedParams): EncodeObject {
			try {
				return { typeUrl: "/structs.structs.EventPlayerResumed", value: EventPlayerResumed.fromPartial( value ) }  
			} catch (e: any) {
				throw new Error('TxClient:EventPlayerResumed: Could not create message: ' + e.message)
			}
		},
		
		queryAllGuildBankCollateralAddressRequest({ value }: queryAllGuildBankCollateralAddressRequestParams): EncodeObject {
			try {
				return { typeUrl: "/structs.structs.QueryAllGuildBankCollateralAddressRequest", value: QueryAllGuildBankCollateralAddressRequest.fromPartial( value ) }  
			} catch (e: any) {
				throw new Error('TxClient:QueryAllGuildBankCollateralAddressRequest: Could not create message: ' + e.message)
			}
		},
		
		eventStructDefender({ value }: eventStructDefenderParams): EncodeObject {
			try {
				return { typeUrl: "/structs.structs.EventStructDefender", value: EventStructDefender.fromPartial( value ) }  
			} catch (e: any) {
				throw new Error('TxClient:EventStructDefender: Could not create message: ' + e.message)
			}
		},
		
		eventAttackDetail({ value }: eventAttackDetailParams): EncodeObject {
			try {
				return { typeUrl: "/structs.structs.EventAttackDetail", value: EventAttackDetail.fromPartial( value ) }  
			} catch (e: any) {
				throw new Error('TxClient:EventAttackDetail: Could not create message: ' + e.message)
			}
		},
		
		msgAddressRegister({ value }: msgAddressRegisterParams): EncodeObject {
			try {
				return { typeUrl: "/structs.structs.MsgAddressRegister", value: MsgAddressRegister.fromPartial( value ) }  
			} catch (e: any) {
				throw new Error('TxClient:MsgAddressRegister: Could not create message: ' + e.message)
			}
		},
		
		msgGuildMembershipRequestApprove({ value }: msgGuildMembershipRequestApproveParams): EncodeObject {
			try {
				return { typeUrl: "/structs.structs.MsgGuildMembershipRequestApprove", value: MsgGuildMembershipRequestApprove.fromPartial( value ) }  
			} catch (e: any) {
				throw new Error('TxClient:MsgGuildMembershipRequestApprove: Could not create message: ' + e.message)
			}
		},
		
		msgStructOreMinerStatusResponse({ value }: msgStructOreMinerStatusResponseParams): EncodeObject {
			try {
				return { typeUrl: "/structs.structs.MsgStructOreMinerStatusResponse", value: MsgStructOreMinerStatusResponse.fromPartial( value ) }  
			} catch (e: any) {
				throw new Error('TxClient:MsgStructOreMinerStatusResponse: Could not create message: ' + e.message)
			}
		},
		
		queryAllAllocationRequest({ value }: queryAllAllocationRequestParams): EncodeObject {
			try {
				return { typeUrl: "/structs.structs.QueryAllAllocationRequest", value: QueryAllAllocationRequest.fromPartial( value ) }  
			} catch (e: any) {
				throw new Error('TxClient:QueryAllAllocationRequest: Could not create message: ' + e.message)
			}
		},
		
		queryAllAllocationBySourceRequest({ value }: queryAllAllocationBySourceRequestParams): EncodeObject {
			try {
				return { typeUrl: "/structs.structs.QueryAllAllocationBySourceRequest", value: QueryAllAllocationBySourceRequest.fromPartial( value ) }  
			} catch (e: any) {
				throw new Error('TxClient:QueryAllAllocationBySourceRequest: Could not create message: ' + e.message)
			}
		},
		
		gridAttributes({ value }: gridAttributesParams): EncodeObject {
			try {
				return { typeUrl: "/structs.structs.GridAttributes", value: GridAttributes.fromPartial( value ) }  
			} catch (e: any) {
				throw new Error('TxClient:GridAttributes: Could not create message: ' + e.message)
			}
		},
		
		structsPacketData({ value }: structsPacketDataParams): EncodeObject {
			try {
				return { typeUrl: "/structs.structs.StructsPacketData", value: StructsPacketData.fromPartial( value ) }  
			} catch (e: any) {
				throw new Error('TxClient:StructsPacketData: Could not create message: ' + e.message)
			}
		},
		
		eventSubstation({ value }: eventSubstationParams): EncodeObject {
			try {
				return { typeUrl: "/structs.structs.EventSubstation", value: EventSubstation.fromPartial( value ) }  
			} catch (e: any) {
				throw new Error('TxClient:EventSubstation: Could not create message: ' + e.message)
			}
		},
		
		msgFleetMove({ value }: msgFleetMoveParams): EncodeObject {
			try {
				return { typeUrl: "/structs.structs.MsgFleetMove", value: MsgFleetMove.fromPartial( value ) }  
			} catch (e: any) {
				throw new Error('TxClient:MsgFleetMove: Could not create message: ' + e.message)
			}
		},
		
		msgGuildBankRedeem({ value }: msgGuildBankRedeemParams): EncodeObject {
			try {
				return { typeUrl: "/structs.structs.MsgGuildBankRedeem", value: MsgGuildBankRedeem.fromPartial( value ) }  
			} catch (e: any) {
				throw new Error('TxClient:MsgGuildBankRedeem: Could not create message: ' + e.message)
			}
		},
		
		queryGetFleetByIndexRequest({ value }: queryGetFleetByIndexRequestParams): EncodeObject {
			try {
				return { typeUrl: "/structs.structs.QueryGetFleetByIndexRequest", value: QueryGetFleetByIndexRequest.fromPartial( value ) }  
			} catch (e: any) {
				throw new Error('TxClient:QueryGetFleetByIndexRequest: Could not create message: ' + e.message)
			}
		},
		
		queryGetGridResponse({ value }: queryGetGridResponseParams): EncodeObject {
			try {
				return { typeUrl: "/structs.structs.QueryGetGridResponse", value: QueryGetGridResponse.fromPartial( value ) }  
			} catch (e: any) {
				throw new Error('TxClient:QueryGetGridResponse: Could not create message: ' + e.message)
			}
		},
		
		queryGetInfusionRequest({ value }: queryGetInfusionRequestParams): EncodeObject {
			try {
				return { typeUrl: "/structs.structs.QueryGetInfusionRequest", value: QueryGetInfusionRequest.fromPartial( value ) }  
			} catch (e: any) {
				throw new Error('TxClient:QueryGetInfusionRequest: Could not create message: ' + e.message)
			}
		},
		
		queryAllInfusionResponse({ value }: queryAllInfusionResponseParams): EncodeObject {
			try {
				return { typeUrl: "/structs.structs.QueryAllInfusionResponse", value: QueryAllInfusionResponse.fromPartial( value ) }  
			} catch (e: any) {
				throw new Error('TxClient:QueryAllInfusionResponse: Could not create message: ' + e.message)
			}
		},
		
		eventProviderAddressDetail({ value }: eventProviderAddressDetailParams): EncodeObject {
			try {
				return { typeUrl: "/structs.structs.EventProviderAddressDetail", value: EventProviderAddressDetail.fromPartial( value ) }  
			} catch (e: any) {
				throw new Error('TxClient:EventProviderAddressDetail: Could not create message: ' + e.message)
			}
		},
		
		msgGuildUpdateEndpoint({ value }: msgGuildUpdateEndpointParams): EncodeObject {
			try {
				return { typeUrl: "/structs.structs.MsgGuildUpdateEndpoint", value: MsgGuildUpdateEndpoint.fromPartial( value ) }  
			} catch (e: any) {
				throw new Error('TxClient:MsgGuildUpdateEndpoint: Could not create message: ' + e.message)
			}
		},
		
		msgAgreementDurationIncrease({ value }: msgAgreementDurationIncreaseParams): EncodeObject {
			try {
				return { typeUrl: "/structs.structs.MsgAgreementDurationIncrease", value: MsgAgreementDurationIncrease.fromPartial( value ) }  
			} catch (e: any) {
				throw new Error('TxClient:MsgAgreementDurationIncrease: Could not create message: ' + e.message)
			}
		},
		
		queryAllAllocationResponse({ value }: queryAllAllocationResponseParams): EncodeObject {
			try {
				return { typeUrl: "/structs.structs.QueryAllAllocationResponse", value: QueryAllAllocationResponse.fromPartial( value ) }  
			} catch (e: any) {
				throw new Error('TxClient:QueryAllAllocationResponse: Could not create message: ' + e.message)
			}
		},
		
		queryAllReactorResponse({ value }: queryAllReactorResponseParams): EncodeObject {
			try {
				return { typeUrl: "/structs.structs.QueryAllReactorResponse", value: QueryAllReactorResponse.fromPartial( value ) }  
			} catch (e: any) {
				throw new Error('TxClient:QueryAllReactorResponse: Could not create message: ' + e.message)
			}
		},
		
		eventStructType({ value }: eventStructTypeParams): EncodeObject {
			try {
				return { typeUrl: "/structs.structs.EventStructType", value: EventStructType.fromPartial( value ) }  
			} catch (e: any) {
				throw new Error('TxClient:EventStructType: Could not create message: ' + e.message)
			}
		},
		
		eventGrid({ value }: eventGridParams): EncodeObject {
			try {
				return { typeUrl: "/structs.structs.EventGrid", value: EventGrid.fromPartial( value ) }  
			} catch (e: any) {
				throw new Error('TxClient:EventGrid: Could not create message: ' + e.message)
			}
		},
		
		eventGuildBankRedeem({ value }: eventGuildBankRedeemParams): EncodeObject {
			try {
				return { typeUrl: "/structs.structs.EventGuildBankRedeem", value: EventGuildBankRedeem.fromPartial( value ) }  
			} catch (e: any) {
				throw new Error('TxClient:EventGuildBankRedeem: Could not create message: ' + e.message)
			}
		},
		
		eventOreMineDetail({ value }: eventOreMineDetailParams): EncodeObject {
			try {
				return { typeUrl: "/structs.structs.EventOreMineDetail", value: EventOreMineDetail.fromPartial( value ) }  
			} catch (e: any) {
				throw new Error('TxClient:EventOreMineDetail: Could not create message: ' + e.message)
			}
		},
		
		queryAllAllocationByDestinationRequest({ value }: queryAllAllocationByDestinationRequestParams): EncodeObject {
			try {
				return { typeUrl: "/structs.structs.QueryAllAllocationByDestinationRequest", value: QueryAllAllocationByDestinationRequest.fromPartial( value ) }  
			} catch (e: any) {
				throw new Error('TxClient:QueryAllAllocationByDestinationRequest: Could not create message: ' + e.message)
			}
		},
		
		player({ value }: playerParams): EncodeObject {
			try {
				return { typeUrl: "/structs.structs.Player", value: Player.fromPartial( value ) }  
			} catch (e: any) {
				throw new Error('TxClient:Player: Could not create message: ' + e.message)
			}
		},
		
		msgPlayerResumeResponse({ value }: msgPlayerResumeResponseParams): EncodeObject {
			try {
				return { typeUrl: "/structs.structs.MsgPlayerResumeResponse", value: MsgPlayerResumeResponse.fromPartial( value ) }  
			} catch (e: any) {
				throw new Error('TxClient:MsgPlayerResumeResponse: Could not create message: ' + e.message)
			}
		},
		
		msgStructStatusResponse({ value }: msgStructStatusResponseParams): EncodeObject {
			try {
				return { typeUrl: "/structs.structs.MsgStructStatusResponse", value: MsgStructStatusResponse.fromPartial( value ) }  
			} catch (e: any) {
				throw new Error('TxClient:MsgStructStatusResponse: Could not create message: ' + e.message)
			}
		},
		
		msgStructStorageRecall({ value }: msgStructStorageRecallParams): EncodeObject {
			try {
				return { typeUrl: "/structs.structs.MsgStructStorageRecall", value: MsgStructStorageRecall.fromPartial( value ) }  
			} catch (e: any) {
				throw new Error('TxClient:MsgStructStorageRecall: Could not create message: ' + e.message)
			}
		},
		
		msgAgreementResponse({ value }: msgAgreementResponseParams): EncodeObject {
			try {
				return { typeUrl: "/structs.structs.MsgAgreementResponse", value: MsgAgreementResponse.fromPartial( value ) }  
			} catch (e: any) {
				throw new Error('TxClient:MsgAgreementResponse: Could not create message: ' + e.message)
			}
		},
		
		msgProviderCreate({ value }: msgProviderCreateParams): EncodeObject {
			try {
				return { typeUrl: "/structs.structs.MsgProviderCreate", value: MsgProviderCreate.fromPartial( value ) }  
			} catch (e: any) {
				throw new Error('TxClient:MsgProviderCreate: Could not create message: ' + e.message)
			}
		},
		
		msgPlayerSendResponse({ value }: msgPlayerSendResponseParams): EncodeObject {
			try {
				return { typeUrl: "/structs.structs.MsgPlayerSendResponse", value: MsgPlayerSendResponse.fromPartial( value ) }  
			} catch (e: any) {
				throw new Error('TxClient:MsgPlayerSendResponse: Could not create message: ' + e.message)
			}
		},
		
		queryAllAddressRequest({ value }: queryAllAddressRequestParams): EncodeObject {
			try {
				return { typeUrl: "/structs.structs.QueryAllAddressRequest", value: QueryAllAddressRequest.fromPartial( value ) }  
			} catch (e: any) {
				throw new Error('TxClient:QueryAllAddressRequest: Could not create message: ' + e.message)
			}
		},
		
		queryGetReactorResponse({ value }: queryGetReactorResponseParams): EncodeObject {
			try {
				return { typeUrl: "/structs.structs.QueryGetReactorResponse", value: QueryGetReactorResponse.fromPartial( value ) }  
			} catch (e: any) {
				throw new Error('TxClient:QueryGetReactorResponse: Could not create message: ' + e.message)
			}
		},
		
		eventProviderGrantGuild({ value }: eventProviderGrantGuildParams): EncodeObject {
			try {
				return { typeUrl: "/structs.structs.EventProviderGrantGuild", value: EventProviderGrantGuild.fromPartial( value ) }  
			} catch (e: any) {
				throw new Error('TxClient:EventProviderGrantGuild: Could not create message: ' + e.message)
			}
		},
		
		eventGuildBankConfiscateAndBurn({ value }: eventGuildBankConfiscateAndBurnParams): EncodeObject {
			try {
				return { typeUrl: "/structs.structs.EventGuildBankConfiscateAndBurn", value: EventGuildBankConfiscateAndBurn.fromPartial( value ) }  
			} catch (e: any) {
				throw new Error('TxClient:EventGuildBankConfiscateAndBurn: Could not create message: ' + e.message)
			}
		},
		
		queryBlockHeightResponse({ value }: queryBlockHeightResponseParams): EncodeObject {
			try {
				return { typeUrl: "/structs.structs.QueryBlockHeightResponse", value: QueryBlockHeightResponse.fromPartial( value ) }  
			} catch (e: any) {
				throw new Error('TxClient:QueryBlockHeightResponse: Could not create message: ' + e.message)
			}
		},
		
		queryAllPlanetByPlayerRequest({ value }: queryAllPlanetByPlayerRequestParams): EncodeObject {
			try {
				return { typeUrl: "/structs.structs.QueryAllPlanetByPlayerRequest", value: QueryAllPlanetByPlayerRequest.fromPartial( value ) }  
			} catch (e: any) {
				throw new Error('TxClient:QueryAllPlanetByPlayerRequest: Could not create message: ' + e.message)
			}
		},
		
		msgGuildMembershipRequestRevoke({ value }: msgGuildMembershipRequestRevokeParams): EncodeObject {
			try {
				return { typeUrl: "/structs.structs.MsgGuildMembershipRequestRevoke", value: MsgGuildMembershipRequestRevoke.fromPartial( value ) }  
			} catch (e: any) {
				throw new Error('TxClient:MsgGuildMembershipRequestRevoke: Could not create message: ' + e.message)
			}
		},
		
		queryAllStructAttributeRequest({ value }: queryAllStructAttributeRequestParams): EncodeObject {
			try {
				return { typeUrl: "/structs.structs.QueryAllStructAttributeRequest", value: QueryAllStructAttributeRequest.fromPartial( value ) }  
			} catch (e: any) {
				throw new Error('TxClient:QueryAllStructAttributeRequest: Could not create message: ' + e.message)
			}
		},
		
		reactor({ value }: reactorParams): EncodeObject {
			try {
				return { typeUrl: "/structs.structs.Reactor", value: Reactor.fromPartial( value ) }  
			} catch (e: any) {
				throw new Error('TxClient:Reactor: Could not create message: ' + e.message)
			}
		},
		
		eventAttack({ value }: eventAttackParams): EncodeObject {
			try {
				return { typeUrl: "/structs.structs.EventAttack", value: EventAttack.fromPartial( value ) }  
			} catch (e: any) {
				throw new Error('TxClient:EventAttack: Could not create message: ' + e.message)
			}
		},
		
		msgSubstationAllocationDisconnectResponse({ value }: msgSubstationAllocationDisconnectResponseParams): EncodeObject {
			try {
				return { typeUrl: "/structs.structs.MsgSubstationAllocationDisconnectResponse", value: MsgSubstationAllocationDisconnectResponse.fromPartial( value ) }  
			} catch (e: any) {
				throw new Error('TxClient:MsgSubstationAllocationDisconnectResponse: Could not create message: ' + e.message)
			}
		},
		
		msgAgreementCapacityDecrease({ value }: msgAgreementCapacityDecreaseParams): EncodeObject {
			try {
				return { typeUrl: "/structs.structs.MsgAgreementCapacityDecrease", value: MsgAgreementCapacityDecrease.fromPartial( value ) }  
			} catch (e: any) {
				throw new Error('TxClient:MsgAgreementCapacityDecrease: Could not create message: ' + e.message)
			}
		},
		
		queryAllGuildBankCollateralAddressResponse({ value }: queryAllGuildBankCollateralAddressResponseParams): EncodeObject {
			try {
				return { typeUrl: "/structs.structs.QueryAllGuildBankCollateralAddressResponse", value: QueryAllGuildBankCollateralAddressResponse.fromPartial( value ) }  
			} catch (e: any) {
				throw new Error('TxClient:QueryAllGuildBankCollateralAddressResponse: Could not create message: ' + e.message)
			}
		},
		
		queryAllSubstationRequest({ value }: queryAllSubstationRequestParams): EncodeObject {
			try {
				return { typeUrl: "/structs.structs.QueryAllSubstationRequest", value: QueryAllSubstationRequest.fromPartial( value ) }  
			} catch (e: any) {
				throw new Error('TxClient:QueryAllSubstationRequest: Could not create message: ' + e.message)
			}
		},
		
		queryValidateSignatureResponse({ value }: queryValidateSignatureResponseParams): EncodeObject {
			try {
				return { typeUrl: "/structs.structs.QueryValidateSignatureResponse", value: QueryValidateSignatureResponse.fromPartial( value ) }  
			} catch (e: any) {
				throw new Error('TxClient:QueryValidateSignatureResponse: Could not create message: ' + e.message)
			}
		},
		
		eventFleet({ value }: eventFleetParams): EncodeObject {
			try {
				return { typeUrl: "/structs.structs.EventFleet", value: EventFleet.fromPartial( value ) }  
			} catch (e: any) {
				throw new Error('TxClient:EventFleet: Could not create message: ' + e.message)
			}
		},
		
		provider({ value }: providerParams): EncodeObject {
			try {
				return { typeUrl: "/structs.structs.Provider", value: Provider.fromPartial( value ) }  
			} catch (e: any) {
				throw new Error('TxClient:Provider: Could not create message: ' + e.message)
			}
		},
		
		queryBlockHeight({ value }: queryBlockHeightParams): EncodeObject {
			try {
				return { typeUrl: "/structs.structs.QueryBlockHeight", value: QueryBlockHeight.fromPartial( value ) }  
			} catch (e: any) {
				throw new Error('TxClient:QueryBlockHeight: Could not create message: ' + e.message)
			}
		},
		
		queryGetReactorRequest({ value }: queryGetReactorRequestParams): EncodeObject {
			try {
				return { typeUrl: "/structs.structs.QueryGetReactorRequest", value: QueryGetReactorRequest.fromPartial( value ) }  
			} catch (e: any) {
				throw new Error('TxClient:QueryGetReactorRequest: Could not create message: ' + e.message)
			}
		},
		
		gridRecord({ value }: gridRecordParams): EncodeObject {
			try {
				return { typeUrl: "/structs.structs.GridRecord", value: GridRecord.fromPartial( value ) }  
			} catch (e: any) {
				throw new Error('TxClient:GridRecord: Could not create message: ' + e.message)
			}
		},
		
		msgGuildUpdateJoinInfusionMinimumBypassByInvite({ value }: msgGuildUpdateJoinInfusionMinimumBypassByInviteParams): EncodeObject {
			try {
				return { typeUrl: "/structs.structs.MsgGuildUpdateJoinInfusionMinimumBypassByInvite", value: MsgGuildUpdateJoinInfusionMinimumBypassByInvite.fromPartial( value ) }  
			} catch (e: any) {
				throw new Error('TxClient:MsgGuildUpdateJoinInfusionMinimumBypassByInvite: Could not create message: ' + e.message)
			}
		},
		
		msgReactorInfuseResponse({ value }: msgReactorInfuseResponseParams): EncodeObject {
			try {
				return { typeUrl: "/structs.structs.MsgReactorInfuseResponse", value: MsgReactorInfuseResponse.fromPartial( value ) }  
			} catch (e: any) {
				throw new Error('TxClient:MsgReactorInfuseResponse: Could not create message: ' + e.message)
			}
		},
		
		msgStructBuildCancel({ value }: msgStructBuildCancelParams): EncodeObject {
			try {
				return { typeUrl: "/structs.structs.MsgStructBuildCancel", value: MsgStructBuildCancel.fromPartial( value ) }  
			} catch (e: any) {
				throw new Error('TxClient:MsgStructBuildCancel: Could not create message: ' + e.message)
			}
		},
		
		substation({ value }: substationParams): EncodeObject {
			try {
				return { typeUrl: "/structs.structs.Substation", value: Substation.fromPartial( value ) }  
			} catch (e: any) {
				throw new Error('TxClient:Substation: Could not create message: ' + e.message)
			}
		},
		
		msgGuildUpdateOwnerId({ value }: msgGuildUpdateOwnerIdParams): EncodeObject {
			try {
				return { typeUrl: "/structs.structs.MsgGuildUpdateOwnerId", value: MsgGuildUpdateOwnerId.fromPartial( value ) }  
			} catch (e: any) {
				throw new Error('TxClient:MsgGuildUpdateOwnerId: Could not create message: ' + e.message)
			}
		},
		
		msgGuildMembershipInviteDeny({ value }: msgGuildMembershipInviteDenyParams): EncodeObject {
			try {
				return { typeUrl: "/structs.structs.MsgGuildMembershipInviteDeny", value: MsgGuildMembershipInviteDeny.fromPartial( value ) }  
			} catch (e: any) {
				throw new Error('TxClient:MsgGuildMembershipInviteDeny: Could not create message: ' + e.message)
			}
		},
		
		msgSubstationDeleteResponse({ value }: msgSubstationDeleteResponseParams): EncodeObject {
			try {
				return { typeUrl: "/structs.structs.MsgSubstationDeleteResponse", value: MsgSubstationDeleteResponse.fromPartial( value ) }  
			} catch (e: any) {
				throw new Error('TxClient:MsgSubstationDeleteResponse: Could not create message: ' + e.message)
			}
		},
		
		fleet({ value }: fleetParams): EncodeObject {
			try {
				return { typeUrl: "/structs.structs.Fleet", value: Fleet.fromPartial( value ) }  
			} catch (e: any) {
				throw new Error('TxClient:Fleet: Could not create message: ' + e.message)
			}
		},
		
		queryAllPlanetAttributeRequest({ value }: queryAllPlanetAttributeRequestParams): EncodeObject {
			try {
				return { typeUrl: "/structs.structs.QueryAllPlanetAttributeRequest", value: QueryAllPlanetAttributeRequest.fromPartial( value ) }  
			} catch (e: any) {
				throw new Error('TxClient:QueryAllPlanetAttributeRequest: Could not create message: ' + e.message)
			}
		},
		
		queryAllReactorRequest({ value }: queryAllReactorRequestParams): EncodeObject {
			try {
				return { typeUrl: "/structs.structs.QueryAllReactorRequest", value: QueryAllReactorRequest.fromPartial( value ) }  
			} catch (e: any) {
				throw new Error('TxClient:QueryAllReactorRequest: Could not create message: ' + e.message)
			}
		},
		
		eventProvider({ value }: eventProviderParams): EncodeObject {
			try {
				return { typeUrl: "/structs.structs.EventProvider", value: EventProvider.fromPartial( value ) }  
			} catch (e: any) {
				throw new Error('TxClient:EventProvider: Could not create message: ' + e.message)
			}
		},
		
		eventGuildBankRedeemDetail({ value }: eventGuildBankRedeemDetailParams): EncodeObject {
			try {
				return { typeUrl: "/structs.structs.EventGuildBankRedeemDetail", value: EventGuildBankRedeemDetail.fromPartial( value ) }  
			} catch (e: any) {
				throw new Error('TxClient:EventGuildBankRedeemDetail: Could not create message: ' + e.message)
			}
		},
		
		msgPlayerResume({ value }: msgPlayerResumeParams): EncodeObject {
			try {
				return { typeUrl: "/structs.structs.MsgPlayerResume", value: MsgPlayerResume.fromPartial( value ) }  
			} catch (e: any) {
				throw new Error('TxClient:MsgPlayerResume: Could not create message: ' + e.message)
			}
		},
		
		msgProviderWithdrawBalance({ value }: msgProviderWithdrawBalanceParams): EncodeObject {
			try {
				return { typeUrl: "/structs.structs.MsgProviderWithdrawBalance", value: MsgProviderWithdrawBalance.fromPartial( value ) }  
			} catch (e: any) {
				throw new Error('TxClient:MsgProviderWithdrawBalance: Could not create message: ' + e.message)
			}
		},
		
		msgProviderUpdateDurationMaximum({ value }: msgProviderUpdateDurationMaximumParams): EncodeObject {
			try {
				return { typeUrl: "/structs.structs.MsgProviderUpdateDurationMaximum", value: MsgProviderUpdateDurationMaximum.fromPartial( value ) }  
			} catch (e: any) {
				throw new Error('TxClient:MsgProviderUpdateDurationMaximum: Could not create message: ' + e.message)
			}
		},
		
		queryAllInfusionRequest({ value }: queryAllInfusionRequestParams): EncodeObject {
			try {
				return { typeUrl: "/structs.structs.QueryAllInfusionRequest", value: QueryAllInfusionRequest.fromPartial( value ) }  
			} catch (e: any) {
				throw new Error('TxClient:QueryAllInfusionRequest: Could not create message: ' + e.message)
			}
		},
		
		queryGetProviderResponse({ value }: queryGetProviderResponseParams): EncodeObject {
			try {
				return { typeUrl: "/structs.structs.QueryGetProviderResponse", value: QueryGetProviderResponse.fromPartial( value ) }  
			} catch (e: any) {
				throw new Error('TxClient:QueryGetProviderResponse: Could not create message: ' + e.message)
			}
		},
		
		queryAllProviderCollateralAddressResponse({ value }: queryAllProviderCollateralAddressResponseParams): EncodeObject {
			try {
				return { typeUrl: "/structs.structs.QueryAllProviderCollateralAddressResponse", value: QueryAllProviderCollateralAddressResponse.fromPartial( value ) }  
			} catch (e: any) {
				throw new Error('TxClient:QueryAllProviderCollateralAddressResponse: Could not create message: ' + e.message)
			}
		},
		
		noData({ value }: noDataParams): EncodeObject {
			try {
				return { typeUrl: "/structs.structs.NoData", value: NoData.fromPartial( value ) }  
			} catch (e: any) {
				throw new Error('TxClient:NoData: Could not create message: ' + e.message)
			}
		},
		
		msgReactorBeginMigration({ value }: msgReactorBeginMigrationParams): EncodeObject {
			try {
				return { typeUrl: "/structs.structs.MsgReactorBeginMigration", value: MsgReactorBeginMigration.fromPartial( value ) }  
			} catch (e: any) {
				throw new Error('TxClient:MsgReactorBeginMigration: Could not create message: ' + e.message)
			}
		},
		
		msgReactorBeginMigrationResponse({ value }: msgReactorBeginMigrationResponseParams): EncodeObject {
			try {
				return { typeUrl: "/structs.structs.MsgReactorBeginMigrationResponse", value: MsgReactorBeginMigrationResponse.fromPartial( value ) }  
			} catch (e: any) {
				throw new Error('TxClient:MsgReactorBeginMigrationResponse: Could not create message: ' + e.message)
			}
		},
		
		msgSubstationPlayerDisconnect({ value }: msgSubstationPlayerDisconnectParams): EncodeObject {
			try {
				return { typeUrl: "/structs.structs.MsgSubstationPlayerDisconnect", value: MsgSubstationPlayerDisconnect.fromPartial( value ) }  
			} catch (e: any) {
				throw new Error('TxClient:MsgSubstationPlayerDisconnect: Could not create message: ' + e.message)
			}
		},
		
		guildMembershipApplication({ value }: guildMembershipApplicationParams): EncodeObject {
			try {
				return { typeUrl: "/structs.structs.GuildMembershipApplication", value: GuildMembershipApplication.fromPartial( value ) }  
			} catch (e: any) {
				throw new Error('TxClient:GuildMembershipApplication: Could not create message: ' + e.message)
			}
		},
		
		queryGetAllocationRequest({ value }: queryGetAllocationRequestParams): EncodeObject {
			try {
				return { typeUrl: "/structs.structs.QueryGetAllocationRequest", value: QueryGetAllocationRequest.fromPartial( value ) }  
			} catch (e: any) {
				throw new Error('TxClient:QueryGetAllocationRequest: Could not create message: ' + e.message)
			}
		},
		
		eventAgreement({ value }: eventAgreementParams): EncodeObject {
			try {
				return { typeUrl: "/structs.structs.EventAgreement", value: EventAgreement.fromPartial( value ) }  
			} catch (e: any) {
				throw new Error('TxClient:EventAgreement: Could not create message: ' + e.message)
			}
		},
		
		msgAllocationDelete({ value }: msgAllocationDeleteParams): EncodeObject {
			try {
				return { typeUrl: "/structs.structs.MsgAllocationDelete", value: MsgAllocationDelete.fromPartial( value ) }  
			} catch (e: any) {
				throw new Error('TxClient:MsgAllocationDelete: Could not create message: ' + e.message)
			}
		},
		
		msgAgreementOpen({ value }: msgAgreementOpenParams): EncodeObject {
			try {
				return { typeUrl: "/structs.structs.MsgAgreementOpen", value: MsgAgreementOpen.fromPartial( value ) }  
			} catch (e: any) {
				throw new Error('TxClient:MsgAgreementOpen: Could not create message: ' + e.message)
			}
		},
		
		msgPlayerSend({ value }: msgPlayerSendParams): EncodeObject {
			try {
				return { typeUrl: "/structs.structs.MsgPlayerSend", value: MsgPlayerSend.fromPartial( value ) }  
			} catch (e: any) {
				throw new Error('TxClient:MsgPlayerSend: Could not create message: ' + e.message)
			}
		},
		
		queryGetGuildRequest({ value }: queryGetGuildRequestParams): EncodeObject {
			try {
				return { typeUrl: "/structs.structs.QueryGetGuildRequest", value: QueryGetGuildRequest.fromPartial( value ) }  
			} catch (e: any) {
				throw new Error('TxClient:QueryGetGuildRequest: Could not create message: ' + e.message)
			}
		},
		
		planet({ value }: planetParams): EncodeObject {
			try {
				return { typeUrl: "/structs.structs.Planet", value: Planet.fromPartial( value ) }  
			} catch (e: any) {
				throw new Error('TxClient:Planet: Could not create message: ' + e.message)
			}
		},
		
		msgAllocationTransferResponse({ value }: msgAllocationTransferResponseParams): EncodeObject {
			try {
				return { typeUrl: "/structs.structs.MsgAllocationTransferResponse", value: MsgAllocationTransferResponse.fromPartial( value ) }  
			} catch (e: any) {
				throw new Error('TxClient:MsgAllocationTransferResponse: Could not create message: ' + e.message)
			}
		},
		
		msgStructDefenseClear({ value }: msgStructDefenseClearParams): EncodeObject {
			try {
				return { typeUrl: "/structs.structs.MsgStructDefenseClear", value: MsgStructDefenseClear.fromPartial( value ) }  
			} catch (e: any) {
				throw new Error('TxClient:MsgStructDefenseClear: Could not create message: ' + e.message)
			}
		},
		
		queryAllAgreementResponse({ value }: queryAllAgreementResponseParams): EncodeObject {
			try {
				return { typeUrl: "/structs.structs.QueryAllAgreementResponse", value: QueryAllAgreementResponse.fromPartial( value ) }  
			} catch (e: any) {
				throw new Error('TxClient:QueryAllAgreementResponse: Could not create message: ' + e.message)
			}
		},
		
		queryAllPermissionByObjectRequest({ value }: queryAllPermissionByObjectRequestParams): EncodeObject {
			try {
				return { typeUrl: "/structs.structs.QueryAllPermissionByObjectRequest", value: QueryAllPermissionByObjectRequest.fromPartial( value ) }  
			} catch (e: any) {
				throw new Error('TxClient:QueryAllPermissionByObjectRequest: Could not create message: ' + e.message)
			}
		},
		
		queryAllStructAttributeResponse({ value }: queryAllStructAttributeResponseParams): EncodeObject {
			try {
				return { typeUrl: "/structs.structs.QueryAllStructAttributeResponse", value: QueryAllStructAttributeResponse.fromPartial( value ) }  
			} catch (e: any) {
				throw new Error('TxClient:QueryAllStructAttributeResponse: Could not create message: ' + e.message)
			}
		},
		
		eventAlphaDefuseDetail({ value }: eventAlphaDefuseDetailParams): EncodeObject {
			try {
				return { typeUrl: "/structs.structs.EventAlphaDefuseDetail", value: EventAlphaDefuseDetail.fromPartial( value ) }  
			} catch (e: any) {
				throw new Error('TxClient:EventAlphaDefuseDetail: Could not create message: ' + e.message)
			}
		},
		
		msgGuildMembershipJoinProxy({ value }: msgGuildMembershipJoinProxyParams): EncodeObject {
			try {
				return { typeUrl: "/structs.structs.MsgGuildMembershipJoinProxy", value: MsgGuildMembershipJoinProxy.fromPartial( value ) }  
			} catch (e: any) {
				throw new Error('TxClient:MsgGuildMembershipJoinProxy: Could not create message: ' + e.message)
			}
		},
		
		msgStructBuildInitiate({ value }: msgStructBuildInitiateParams): EncodeObject {
			try {
				return { typeUrl: "/structs.structs.MsgStructBuildInitiate", value: MsgStructBuildInitiate.fromPartial( value ) }  
			} catch (e: any) {
				throw new Error('TxClient:MsgStructBuildInitiate: Could not create message: ' + e.message)
			}
		},
		
		genesisState({ value }: genesisStateParams): EncodeObject {
			try {
				return { typeUrl: "/structs.structs.GenesisState", value: GenesisState.fromPartial( value ) }  
			} catch (e: any) {
				throw new Error('TxClient:GenesisState: Could not create message: ' + e.message)
			}
		},
		
		queryGetFleetResponse({ value }: queryGetFleetResponseParams): EncodeObject {
			try {
				return { typeUrl: "/structs.structs.QueryGetFleetResponse", value: QueryGetFleetResponse.fromPartial( value ) }  
			} catch (e: any) {
				throw new Error('TxClient:QueryGetFleetResponse: Could not create message: ' + e.message)
			}
		},
		
		queryAllGuildRequest({ value }: queryAllGuildRequestParams): EncodeObject {
			try {
				return { typeUrl: "/structs.structs.QueryAllGuildRequest", value: QueryAllGuildRequest.fromPartial( value ) }  
			} catch (e: any) {
				throw new Error('TxClient:QueryAllGuildRequest: Could not create message: ' + e.message)
			}
		},
		
		queryGetPlanetAttributeResponse({ value }: queryGetPlanetAttributeResponseParams): EncodeObject {
			try {
				return { typeUrl: "/structs.structs.QueryGetPlanetAttributeResponse", value: QueryGetPlanetAttributeResponse.fromPartial( value ) }  
			} catch (e: any) {
				throw new Error('TxClient:QueryGetPlanetAttributeResponse: Could not create message: ' + e.message)
			}
		},
		
		msgGuildBankMintResponse({ value }: msgGuildBankMintResponseParams): EncodeObject {
			try {
				return { typeUrl: "/structs.structs.MsgGuildBankMintResponse", value: MsgGuildBankMintResponse.fromPartial( value ) }  
			} catch (e: any) {
				throw new Error('TxClient:MsgGuildBankMintResponse: Could not create message: ' + e.message)
			}
		},
		
		msgGuildBankConfiscateAndBurn({ value }: msgGuildBankConfiscateAndBurnParams): EncodeObject {
			try {
				return { typeUrl: "/structs.structs.MsgGuildBankConfiscateAndBurn", value: MsgGuildBankConfiscateAndBurn.fromPartial( value ) }  
			} catch (e: any) {
				throw new Error('TxClient:MsgGuildBankConfiscateAndBurn: Could not create message: ' + e.message)
			}
		},
		
		msgSubstationPlayerConnect({ value }: msgSubstationPlayerConnectParams): EncodeObject {
			try {
				return { typeUrl: "/structs.structs.MsgSubstationPlayerConnect", value: MsgSubstationPlayerConnect.fromPartial( value ) }  
			} catch (e: any) {
				throw new Error('TxClient:MsgSubstationPlayerConnect: Could not create message: ' + e.message)
			}
		},
		
		queryAllGuildMembershipApplicationResponse({ value }: queryAllGuildMembershipApplicationResponseParams): EncodeObject {
			try {
				return { typeUrl: "/structs.structs.QueryAllGuildMembershipApplicationResponse", value: QueryAllGuildMembershipApplicationResponse.fromPartial( value ) }  
			} catch (e: any) {
				throw new Error('TxClient:QueryAllGuildMembershipApplicationResponse: Could not create message: ' + e.message)
			}
		},
		
		queryAllProviderRequest({ value }: queryAllProviderRequestParams): EncodeObject {
			try {
				return { typeUrl: "/structs.structs.QueryAllProviderRequest", value: QueryAllProviderRequest.fromPartial( value ) }  
			} catch (e: any) {
				throw new Error('TxClient:QueryAllProviderRequest: Could not create message: ' + e.message)
			}
		},
		
		queryGetProviderByEarningsAddressRequest({ value }: queryGetProviderByEarningsAddressRequestParams): EncodeObject {
			try {
				return { typeUrl: "/structs.structs.QueryGetProviderByEarningsAddressRequest", value: QueryGetProviderByEarningsAddressRequest.fromPartial( value ) }  
			} catch (e: any) {
				throw new Error('TxClient:QueryGetProviderByEarningsAddressRequest: Could not create message: ' + e.message)
			}
		},
		
		eventPlayer({ value }: eventPlayerParams): EncodeObject {
			try {
				return { typeUrl: "/structs.structs.EventPlayer", value: EventPlayer.fromPartial( value ) }  
			} catch (e: any) {
				throw new Error('TxClient:EventPlayer: Could not create message: ' + e.message)
			}
		},
		
		eventProviderRevokeGuild({ value }: eventProviderRevokeGuildParams): EncodeObject {
			try {
				return { typeUrl: "/structs.structs.EventProviderRevokeGuild", value: EventProviderRevokeGuild.fromPartial( value ) }  
			} catch (e: any) {
				throw new Error('TxClient:EventProviderRevokeGuild: Could not create message: ' + e.message)
			}
		},
		
		msgAddressRegisterResponse({ value }: msgAddressRegisterResponseParams): EncodeObject {
			try {
				return { typeUrl: "/structs.structs.MsgAddressRegisterResponse", value: MsgAddressRegisterResponse.fromPartial( value ) }  
			} catch (e: any) {
				throw new Error('TxClient:MsgAddressRegisterResponse: Could not create message: ' + e.message)
			}
		},
		
		msgPermissionGrantOnObject({ value }: msgPermissionGrantOnObjectParams): EncodeObject {
			try {
				return { typeUrl: "/structs.structs.MsgPermissionGrantOnObject", value: MsgPermissionGrantOnObject.fromPartial( value ) }  
			} catch (e: any) {
				throw new Error('TxClient:MsgPermissionGrantOnObject: Could not create message: ' + e.message)
			}
		},
		
		queryGetPlayerRequest({ value }: queryGetPlayerRequestParams): EncodeObject {
			try {
				return { typeUrl: "/structs.structs.QueryGetPlayerRequest", value: QueryGetPlayerRequest.fromPartial( value ) }  
			} catch (e: any) {
				throw new Error('TxClient:QueryGetPlayerRequest: Could not create message: ' + e.message)
			}
		},
		
		queryAllStructTypeResponse({ value }: queryAllStructTypeResponseParams): EncodeObject {
			try {
				return { typeUrl: "/structs.structs.QueryAllStructTypeResponse", value: QueryAllStructTypeResponse.fromPartial( value ) }  
			} catch (e: any) {
				throw new Error('TxClient:QueryAllStructTypeResponse: Could not create message: ' + e.message)
			}
		},
		
		msgPlanetRaidCompleteResponse({ value }: msgPlanetRaidCompleteResponseParams): EncodeObject {
			try {
				return { typeUrl: "/structs.structs.MsgPlanetRaidCompleteResponse", value: MsgPlanetRaidCompleteResponse.fromPartial( value ) }  
			} catch (e: any) {
				throw new Error('TxClient:MsgPlanetRaidCompleteResponse: Could not create message: ' + e.message)
			}
		},
		
		msgReactorDefuse({ value }: msgReactorDefuseParams): EncodeObject {
			try {
				return { typeUrl: "/structs.structs.MsgReactorDefuse", value: MsgReactorDefuse.fromPartial( value ) }  
			} catch (e: any) {
				throw new Error('TxClient:MsgReactorDefuse: Could not create message: ' + e.message)
			}
		},
		
		msgStructStealthActivate({ value }: msgStructStealthActivateParams): EncodeObject {
			try {
				return { typeUrl: "/structs.structs.MsgStructStealthActivate", value: MsgStructStealthActivate.fromPartial( value ) }  
			} catch (e: any) {
				throw new Error('TxClient:MsgStructStealthActivate: Could not create message: ' + e.message)
			}
		},
		
		queryGetGuildBankCollateralAddressRequest({ value }: queryGetGuildBankCollateralAddressRequestParams): EncodeObject {
			try {
				return { typeUrl: "/structs.structs.QueryGetGuildBankCollateralAddressRequest", value: QueryGetGuildBankCollateralAddressRequest.fromPartial( value ) }  
			} catch (e: any) {
				throw new Error('TxClient:QueryGetGuildBankCollateralAddressRequest: Could not create message: ' + e.message)
			}
		},
		
		queryAllGuildMembershipApplicationRequest({ value }: queryAllGuildMembershipApplicationRequestParams): EncodeObject {
			try {
				return { typeUrl: "/structs.structs.QueryAllGuildMembershipApplicationRequest", value: QueryAllGuildMembershipApplicationRequest.fromPartial( value ) }  
			} catch (e: any) {
				throw new Error('TxClient:QueryAllGuildMembershipApplicationRequest: Could not create message: ' + e.message)
			}
		},
		
		queryAllPermissionRequest({ value }: queryAllPermissionRequestParams): EncodeObject {
			try {
				return { typeUrl: "/structs.structs.QueryAllPermissionRequest", value: QueryAllPermissionRequest.fromPartial( value ) }  
			} catch (e: any) {
				throw new Error('TxClient:QueryAllPermissionRequest: Could not create message: ' + e.message)
			}
		},
		
		queryAllProviderEarningsAddressResponse({ value }: queryAllProviderEarningsAddressResponseParams): EncodeObject {
			try {
				return { typeUrl: "/structs.structs.QueryAllProviderEarningsAddressResponse", value: QueryAllProviderEarningsAddressResponse.fromPartial( value ) }  
			} catch (e: any) {
				throw new Error('TxClient:QueryAllProviderEarningsAddressResponse: Could not create message: ' + e.message)
			}
		},
		
		struct({ value }: structParams): EncodeObject {
			try {
				return { typeUrl: "/structs.structs.Struct", value: Struct.fromPartial( value ) }  
			} catch (e: any) {
				throw new Error('TxClient:Struct: Could not create message: ' + e.message)
			}
		},
		
		eventProviderAddress({ value }: eventProviderAddressParams): EncodeObject {
			try {
				return { typeUrl: "/structs.structs.EventProviderAddress", value: EventProviderAddress.fromPartial( value ) }  
			} catch (e: any) {
				throw new Error('TxClient:EventProviderAddress: Could not create message: ' + e.message)
			}
		},
		
		msgSubstationAllocationDisconnect({ value }: msgSubstationAllocationDisconnectParams): EncodeObject {
			try {
				return { typeUrl: "/structs.structs.MsgSubstationAllocationDisconnect", value: MsgSubstationAllocationDisconnect.fromPartial( value ) }  
			} catch (e: any) {
				throw new Error('TxClient:MsgSubstationAllocationDisconnect: Could not create message: ' + e.message)
			}
		},
		
		queryGetAddressRequest({ value }: queryGetAddressRequestParams): EncodeObject {
			try {
				return { typeUrl: "/structs.structs.QueryGetAddressRequest", value: QueryGetAddressRequest.fromPartial( value ) }  
			} catch (e: any) {
				throw new Error('TxClient:QueryGetAddressRequest: Could not create message: ' + e.message)
			}
		},
		
		eventPlayerHalted({ value }: eventPlayerHaltedParams): EncodeObject {
			try {
				return { typeUrl: "/structs.structs.EventPlayerHalted", value: EventPlayerHalted.fromPartial( value ) }  
			} catch (e: any) {
				throw new Error('TxClient:EventPlayerHalted: Could not create message: ' + e.message)
			}
		},
		
		msgUpdateParams({ value }: msgUpdateParamsParams): EncodeObject {
			try {
				return { typeUrl: "/structs.structs.MsgUpdateParams", value: MsgUpdateParams.fromPartial( value ) }  
			} catch (e: any) {
				throw new Error('TxClient:MsgUpdateParams: Could not create message: ' + e.message)
			}
		},
		
		msgGuildBankMint({ value }: msgGuildBankMintParams): EncodeObject {
			try {
				return { typeUrl: "/structs.structs.MsgGuildBankMint", value: MsgGuildBankMint.fromPartial( value ) }  
			} catch (e: any) {
				throw new Error('TxClient:MsgGuildBankMint: Could not create message: ' + e.message)
			}
		},
		
		msgGuildUpdateJoinInfusionMinimum({ value }: msgGuildUpdateJoinInfusionMinimumParams): EncodeObject {
			try {
				return { typeUrl: "/structs.structs.MsgGuildUpdateJoinInfusionMinimum", value: MsgGuildUpdateJoinInfusionMinimum.fromPartial( value ) }  
			} catch (e: any) {
				throw new Error('TxClient:MsgGuildUpdateJoinInfusionMinimum: Could not create message: ' + e.message)
			}
		},
		
		queryAllPermissionResponse({ value }: queryAllPermissionResponseParams): EncodeObject {
			try {
				return { typeUrl: "/structs.structs.QueryAllPermissionResponse", value: QueryAllPermissionResponse.fromPartial( value ) }  
			} catch (e: any) {
				throw new Error('TxClient:QueryAllPermissionResponse: Could not create message: ' + e.message)
			}
		},
		
		eventAllocation({ value }: eventAllocationParams): EncodeObject {
			try {
				return { typeUrl: "/structs.structs.EventAllocation", value: EventAllocation.fromPartial( value ) }  
			} catch (e: any) {
				throw new Error('TxClient:EventAllocation: Could not create message: ' + e.message)
			}
		},
		
		eventTimeDetail({ value }: eventTimeDetailParams): EncodeObject {
			try {
				return { typeUrl: "/structs.structs.EventTimeDetail", value: EventTimeDetail.fromPartial( value ) }  
			} catch (e: any) {
				throw new Error('TxClient:EventTimeDetail: Could not create message: ' + e.message)
			}
		},
		
		msgPlayerUpdatePrimaryAddress({ value }: msgPlayerUpdatePrimaryAddressParams): EncodeObject {
			try {
				return { typeUrl: "/structs.structs.MsgPlayerUpdatePrimaryAddress", value: MsgPlayerUpdatePrimaryAddress.fromPartial( value ) }  
			} catch (e: any) {
				throw new Error('TxClient:MsgPlayerUpdatePrimaryAddress: Could not create message: ' + e.message)
			}
		},
		
		queryGetAgreementRequest({ value }: queryGetAgreementRequestParams): EncodeObject {
			try {
				return { typeUrl: "/structs.structs.QueryGetAgreementRequest", value: QueryGetAgreementRequest.fromPartial( value ) }  
			} catch (e: any) {
				throw new Error('TxClient:QueryGetAgreementRequest: Could not create message: ' + e.message)
			}
		},
		
		msgPermissionGrantOnAddress({ value }: msgPermissionGrantOnAddressParams): EncodeObject {
			try {
				return { typeUrl: "/structs.structs.MsgPermissionGrantOnAddress", value: MsgPermissionGrantOnAddress.fromPartial( value ) }  
			} catch (e: any) {
				throw new Error('TxClient:MsgPermissionGrantOnAddress: Could not create message: ' + e.message)
			}
		},
		
		msgPermissionSetOnAddress({ value }: msgPermissionSetOnAddressParams): EncodeObject {
			try {
				return { typeUrl: "/structs.structs.MsgPermissionSetOnAddress", value: MsgPermissionSetOnAddress.fromPartial( value ) }  
			} catch (e: any) {
				throw new Error('TxClient:MsgPermissionSetOnAddress: Could not create message: ' + e.message)
			}
		},
		
		eventAddressActivity({ value }: eventAddressActivityParams): EncodeObject {
			try {
				return { typeUrl: "/structs.structs.EventAddressActivity", value: EventAddressActivity.fromPartial( value ) }  
			} catch (e: any) {
				throw new Error('TxClient:EventAddressActivity: Could not create message: ' + e.message)
			}
		},
		
		eventRaid({ value }: eventRaidParams): EncodeObject {
			try {
				return { typeUrl: "/structs.structs.EventRaid", value: EventRaid.fromPartial( value ) }  
			} catch (e: any) {
				throw new Error('TxClient:EventRaid: Could not create message: ' + e.message)
			}
		},
		
		msgAllocationUpdateResponse({ value }: msgAllocationUpdateResponseParams): EncodeObject {
			try {
				return { typeUrl: "/structs.structs.MsgAllocationUpdateResponse", value: MsgAllocationUpdateResponse.fromPartial( value ) }  
			} catch (e: any) {
				throw new Error('TxClient:MsgAllocationUpdateResponse: Could not create message: ' + e.message)
			}
		},
		
		msgStructAttackResponse({ value }: msgStructAttackResponseParams): EncodeObject {
			try {
				return { typeUrl: "/structs.structs.MsgStructAttackResponse", value: MsgStructAttackResponse.fromPartial( value ) }  
			} catch (e: any) {
				throw new Error('TxClient:MsgStructAttackResponse: Could not create message: ' + e.message)
			}
		},
		
		msgSubstationCreate({ value }: msgSubstationCreateParams): EncodeObject {
			try {
				return { typeUrl: "/structs.structs.MsgSubstationCreate", value: MsgSubstationCreate.fromPartial( value ) }  
			} catch (e: any) {
				throw new Error('TxClient:MsgSubstationCreate: Could not create message: ' + e.message)
			}
		},
		
		queryAllPlanetAttributeResponse({ value }: queryAllPlanetAttributeResponseParams): EncodeObject {
			try {
				return { typeUrl: "/structs.structs.QueryAllPlanetAttributeResponse", value: QueryAllPlanetAttributeResponse.fromPartial( value ) }  
			} catch (e: any) {
				throw new Error('TxClient:QueryAllPlanetAttributeResponse: Could not create message: ' + e.message)
			}
		},
		
		queryAllProviderEarningsAddressRequest({ value }: queryAllProviderEarningsAddressRequestParams): EncodeObject {
			try {
				return { typeUrl: "/structs.structs.QueryAllProviderEarningsAddressRequest", value: QueryAllProviderEarningsAddressRequest.fromPartial( value ) }  
			} catch (e: any) {
				throw new Error('TxClient:QueryAllProviderEarningsAddressRequest: Could not create message: ' + e.message)
			}
		},
		
		queryAllPlayerRequest({ value }: queryAllPlayerRequestParams): EncodeObject {
			try {
				return { typeUrl: "/structs.structs.QueryAllPlayerRequest", value: QueryAllPlayerRequest.fromPartial( value ) }  
			} catch (e: any) {
				throw new Error('TxClient:QueryAllPlayerRequest: Could not create message: ' + e.message)
			}
		},
		
		queryGetStructAttributeRequest({ value }: queryGetStructAttributeRequestParams): EncodeObject {
			try {
				return { typeUrl: "/structs.structs.QueryGetStructAttributeRequest", value: QueryGetStructAttributeRequest.fromPartial( value ) }  
			} catch (e: any) {
				throw new Error('TxClient:QueryGetStructAttributeRequest: Could not create message: ' + e.message)
			}
		},
		
		eventGuildBankAddress({ value }: eventGuildBankAddressParams): EncodeObject {
			try {
				return { typeUrl: "/structs.structs.EventGuildBankAddress", value: EventGuildBankAddress.fromPartial( value ) }  
			} catch (e: any) {
				throw new Error('TxClient:EventGuildBankAddress: Could not create message: ' + e.message)
			}
		},
		
		msgAllocationCreateResponse({ value }: msgAllocationCreateResponseParams): EncodeObject {
			try {
				return { typeUrl: "/structs.structs.MsgAllocationCreateResponse", value: MsgAllocationCreateResponse.fromPartial( value ) }  
			} catch (e: any) {
				throw new Error('TxClient:MsgAllocationCreateResponse: Could not create message: ' + e.message)
			}
		},
		
		allocation({ value }: allocationParams): EncodeObject {
			try {
				return { typeUrl: "/structs.structs.Allocation", value: Allocation.fromPartial( value ) }  
			} catch (e: any) {
				throw new Error('TxClient:Allocation: Could not create message: ' + e.message)
			}
		},
		
		queryAllPermissionByPlayerRequest({ value }: queryAllPermissionByPlayerRequestParams): EncodeObject {
			try {
				return { typeUrl: "/structs.structs.QueryAllPermissionByPlayerRequest", value: QueryAllPermissionByPlayerRequest.fromPartial( value ) }  
			} catch (e: any) {
				throw new Error('TxClient:QueryAllPermissionByPlayerRequest: Could not create message: ' + e.message)
			}
		},
		
		queryAllProviderCollateralAddressRequest({ value }: queryAllProviderCollateralAddressRequestParams): EncodeObject {
			try {
				return { typeUrl: "/structs.structs.QueryAllProviderCollateralAddressRequest", value: QueryAllProviderCollateralAddressRequest.fromPartial( value ) }  
			} catch (e: any) {
				throw new Error('TxClient:QueryAllProviderCollateralAddressRequest: Could not create message: ' + e.message)
			}
		},
		
		queryGetProviderEarningsAddressRequest({ value }: queryGetProviderEarningsAddressRequestParams): EncodeObject {
			try {
				return { typeUrl: "/structs.structs.QueryGetProviderEarningsAddressRequest", value: QueryGetProviderEarningsAddressRequest.fromPartial( value ) }  
			} catch (e: any) {
				throw new Error('TxClient:QueryGetProviderEarningsAddressRequest: Could not create message: ' + e.message)
			}
		},
		
		msgAllocationTransfer({ value }: msgAllocationTransferParams): EncodeObject {
			try {
				return { typeUrl: "/structs.structs.MsgAllocationTransfer", value: MsgAllocationTransfer.fromPartial( value ) }  
			} catch (e: any) {
				throw new Error('TxClient:MsgAllocationTransfer: Could not create message: ' + e.message)
			}
		},
		
		msgGuildBankConfiscateAndBurnResponse({ value }: msgGuildBankConfiscateAndBurnResponseParams): EncodeObject {
			try {
				return { typeUrl: "/structs.structs.MsgGuildBankConfiscateAndBurnResponse", value: MsgGuildBankConfiscateAndBurnResponse.fromPartial( value ) }  
			} catch (e: any) {
				throw new Error('TxClient:MsgGuildBankConfiscateAndBurnResponse: Could not create message: ' + e.message)
			}
		},
		
		msgGuildMembershipKick({ value }: msgGuildMembershipKickParams): EncodeObject {
			try {
				return { typeUrl: "/structs.structs.MsgGuildMembershipKick", value: MsgGuildMembershipKick.fromPartial( value ) }  
			} catch (e: any) {
				throw new Error('TxClient:MsgGuildMembershipKick: Could not create message: ' + e.message)
			}
		},
		
		queryAllGridResponse({ value }: queryAllGridResponseParams): EncodeObject {
			try {
				return { typeUrl: "/structs.structs.QueryAllGridResponse", value: QueryAllGridResponse.fromPartial( value ) }  
			} catch (e: any) {
				throw new Error('TxClient:QueryAllGridResponse: Could not create message: ' + e.message)
			}
		},
		
		fleetAttributeRecord({ value }: fleetAttributeRecordParams): EncodeObject {
			try {
				return { typeUrl: "/structs.structs.FleetAttributeRecord", value: FleetAttributeRecord.fromPartial( value ) }  
			} catch (e: any) {
				throw new Error('TxClient:FleetAttributeRecord: Could not create message: ' + e.message)
			}
		},
		
		msgSubstationPlayerMigrate({ value }: msgSubstationPlayerMigrateParams): EncodeObject {
			try {
				return { typeUrl: "/structs.structs.MsgSubstationPlayerMigrate", value: MsgSubstationPlayerMigrate.fromPartial( value ) }  
			} catch (e: any) {
				throw new Error('TxClient:MsgSubstationPlayerMigrate: Could not create message: ' + e.message)
			}
		},
		
		msgProviderUpdateCapacityMaximum({ value }: msgProviderUpdateCapacityMaximumParams): EncodeObject {
			try {
				return { typeUrl: "/structs.structs.MsgProviderUpdateCapacityMaximum", value: MsgProviderUpdateCapacityMaximum.fromPartial( value ) }  
			} catch (e: any) {
				throw new Error('TxClient:MsgProviderUpdateCapacityMaximum: Could not create message: ' + e.message)
			}
		},
		
		eventDelete({ value }: eventDeleteParams): EncodeObject {
			try {
				return { typeUrl: "/structs.structs.EventDelete", value: EventDelete.fromPartial( value ) }  
			} catch (e: any) {
				throw new Error('TxClient:EventDelete: Could not create message: ' + e.message)
			}
		},
		
		eventGuildBankMint({ value }: eventGuildBankMintParams): EncodeObject {
			try {
				return { typeUrl: "/structs.structs.EventGuildBankMint", value: EventGuildBankMint.fromPartial( value ) }  
			} catch (e: any) {
				throw new Error('TxClient:EventGuildBankMint: Could not create message: ' + e.message)
			}
		},
		
		queryGetGridRequest({ value }: queryGetGridRequestParams): EncodeObject {
			try {
				return { typeUrl: "/structs.structs.QueryGetGridRequest", value: QueryGetGridRequest.fromPartial( value ) }  
			} catch (e: any) {
				throw new Error('TxClient:QueryGetGridRequest: Could not create message: ' + e.message)
			}
		},
		
		queryGetGuildResponse({ value }: queryGetGuildResponseParams): EncodeObject {
			try {
				return { typeUrl: "/structs.structs.QueryGetGuildResponse", value: QueryGetGuildResponse.fromPartial( value ) }  
			} catch (e: any) {
				throw new Error('TxClient:QueryGetGuildResponse: Could not create message: ' + e.message)
			}
		},
		
		queryGetProviderCollateralAddressRequest({ value }: queryGetProviderCollateralAddressRequestParams): EncodeObject {
			try {
				return { typeUrl: "/structs.structs.QueryGetProviderCollateralAddressRequest", value: QueryGetProviderCollateralAddressRequest.fromPartial( value ) }  
			} catch (e: any) {
				throw new Error('TxClient:QueryGetProviderCollateralAddressRequest: Could not create message: ' + e.message)
			}
		},
		
		queryGetStructRequest({ value }: queryGetStructRequestParams): EncodeObject {
			try {
				return { typeUrl: "/structs.structs.QueryGetStructRequest", value: QueryGetStructRequest.fromPartial( value ) }  
			} catch (e: any) {
				throw new Error('TxClient:QueryGetStructRequest: Could not create message: ' + e.message)
			}
		},
		
		queryGetStructAttributeResponse({ value }: queryGetStructAttributeResponseParams): EncodeObject {
			try {
				return { typeUrl: "/structs.structs.QueryGetStructAttributeResponse", value: QueryGetStructAttributeResponse.fromPartial( value ) }  
			} catch (e: any) {
				throw new Error('TxClient:QueryGetStructAttributeResponse: Could not create message: ' + e.message)
			}
		},
		
		queryAllStructTypeRequest({ value }: queryAllStructTypeRequestParams): EncodeObject {
			try {
				return { typeUrl: "/structs.structs.QueryAllStructTypeRequest", value: QueryAllStructTypeRequest.fromPartial( value ) }  
			} catch (e: any) {
				throw new Error('TxClient:QueryAllStructTypeRequest: Could not create message: ' + e.message)
			}
		},
		
		eventAlphaRefine({ value }: eventAlphaRefineParams): EncodeObject {
			try {
				return { typeUrl: "/structs.structs.EventAlphaRefine", value: EventAlphaRefine.fromPartial( value ) }  
			} catch (e: any) {
				throw new Error('TxClient:EventAlphaRefine: Could not create message: ' + e.message)
			}
		},
		
		queryAllInfusionByDestinationRequest({ value }: queryAllInfusionByDestinationRequestParams): EncodeObject {
			try {
				return { typeUrl: "/structs.structs.QueryAllInfusionByDestinationRequest", value: QueryAllInfusionByDestinationRequest.fromPartial( value ) }  
			} catch (e: any) {
				throw new Error('TxClient:QueryAllInfusionByDestinationRequest: Could not create message: ' + e.message)
			}
		},
		
		queryGetPermissionRequest({ value }: queryGetPermissionRequestParams): EncodeObject {
			try {
				return { typeUrl: "/structs.structs.QueryGetPermissionRequest", value: QueryGetPermissionRequest.fromPartial( value ) }  
			} catch (e: any) {
				throw new Error('TxClient:QueryGetPermissionRequest: Could not create message: ' + e.message)
			}
		},
		
		queryGetStructResponse({ value }: queryGetStructResponseParams): EncodeObject {
			try {
				return { typeUrl: "/structs.structs.QueryGetStructResponse", value: QueryGetStructResponse.fromPartial( value ) }  
			} catch (e: any) {
				throw new Error('TxClient:QueryGetStructResponse: Could not create message: ' + e.message)
			}
		},
		
		queryGetSubstationRequest({ value }: queryGetSubstationRequestParams): EncodeObject {
			try {
				return { typeUrl: "/structs.structs.QueryGetSubstationRequest", value: QueryGetSubstationRequest.fromPartial( value ) }  
			} catch (e: any) {
				throw new Error('TxClient:QueryGetSubstationRequest: Could not create message: ' + e.message)
			}
		},
		
		eventRaidDetail({ value }: eventRaidDetailParams): EncodeObject {
			try {
				return { typeUrl: "/structs.structs.EventRaidDetail", value: EventRaidDetail.fromPartial( value ) }  
			} catch (e: any) {
				throw new Error('TxClient:EventRaidDetail: Could not create message: ' + e.message)
			}
		},
		
		msgGuildMembershipInvite({ value }: msgGuildMembershipInviteParams): EncodeObject {
			try {
				return { typeUrl: "/structs.structs.MsgGuildMembershipInvite", value: MsgGuildMembershipInvite.fromPartial( value ) }  
			} catch (e: any) {
				throw new Error('TxClient:MsgGuildMembershipInvite: Could not create message: ' + e.message)
			}
		},
		
		msgGuildMembershipInviteApprove({ value }: msgGuildMembershipInviteApproveParams): EncodeObject {
			try {
				return { typeUrl: "/structs.structs.MsgGuildMembershipInviteApprove", value: MsgGuildMembershipInviteApprove.fromPartial( value ) }  
			} catch (e: any) {
				throw new Error('TxClient:MsgGuildMembershipInviteApprove: Could not create message: ' + e.message)
			}
		},
		
		queryGetAllocationResponse({ value }: queryGetAllocationResponseParams): EncodeObject {
			try {
				return { typeUrl: "/structs.structs.QueryGetAllocationResponse", value: QueryGetAllocationResponse.fromPartial( value ) }  
			} catch (e: any) {
				throw new Error('TxClient:QueryGetAllocationResponse: Could not create message: ' + e.message)
			}
		},
		
		queryAllGridRequest({ value }: queryAllGridRequestParams): EncodeObject {
			try {
				return { typeUrl: "/structs.structs.QueryAllGridRequest", value: QueryAllGridRequest.fromPartial( value ) }  
			} catch (e: any) {
				throw new Error('TxClient:QueryAllGridRequest: Could not create message: ' + e.message)
			}
		},
		
		queryAllStructRequest({ value }: queryAllStructRequestParams): EncodeObject {
			try {
				return { typeUrl: "/structs.structs.QueryAllStructRequest", value: QueryAllStructRequest.fromPartial( value ) }  
			} catch (e: any) {
				throw new Error('TxClient:QueryAllStructRequest: Could not create message: ' + e.message)
			}
		},
		
		structAttributeRecord({ value }: structAttributeRecordParams): EncodeObject {
			try {
				return { typeUrl: "/structs.structs.StructAttributeRecord", value: StructAttributeRecord.fromPartial( value ) }  
			} catch (e: any) {
				throw new Error('TxClient:StructAttributeRecord: Could not create message: ' + e.message)
			}
		},
		
		eventPlanetAttribute({ value }: eventPlanetAttributeParams): EncodeObject {
			try {
				return { typeUrl: "/structs.structs.EventPlanetAttribute", value: EventPlanetAttribute.fromPartial( value ) }  
			} catch (e: any) {
				throw new Error('TxClient:EventPlanetAttribute: Could not create message: ' + e.message)
			}
		},
		
		eventOreMine({ value }: eventOreMineParams): EncodeObject {
			try {
				return { typeUrl: "/structs.structs.EventOreMine", value: EventOreMine.fromPartial( value ) }  
			} catch (e: any) {
				throw new Error('TxClient:EventOreMine: Could not create message: ' + e.message)
			}
		},
		
		eventAttackShotDetail({ value }: eventAttackShotDetailParams): EncodeObject {
			try {
				return { typeUrl: "/structs.structs.EventAttackShotDetail", value: EventAttackShotDetail.fromPartial( value ) }  
			} catch (e: any) {
				throw new Error('TxClient:EventAttackShotDetail: Could not create message: ' + e.message)
			}
		},
		
		msgStructStealthDeactivate({ value }: msgStructStealthDeactivateParams): EncodeObject {
			try {
				return { typeUrl: "/structs.structs.MsgStructStealthDeactivate", value: MsgStructStealthDeactivate.fromPartial( value ) }  
			} catch (e: any) {
				throw new Error('TxClient:MsgStructStealthDeactivate: Could not create message: ' + e.message)
			}
		},
		
		structAttributes({ value }: structAttributesParams): EncodeObject {
			try {
				return { typeUrl: "/structs.structs.StructAttributes", value: StructAttributes.fromPartial( value ) }  
			} catch (e: any) {
				throw new Error('TxClient:StructAttributes: Could not create message: ' + e.message)
			}
		},
		
		eventStruct({ value }: eventStructParams): EncodeObject {
			try {
				return { typeUrl: "/structs.structs.EventStruct", value: EventStruct.fromPartial( value ) }  
			} catch (e: any) {
				throw new Error('TxClient:EventStruct: Could not create message: ' + e.message)
			}
		},
		
		msgGuildUpdateResponse({ value }: msgGuildUpdateResponseParams): EncodeObject {
			try {
				return { typeUrl: "/structs.structs.MsgGuildUpdateResponse", value: MsgGuildUpdateResponse.fromPartial( value ) }  
			} catch (e: any) {
				throw new Error('TxClient:MsgGuildUpdateResponse: Could not create message: ' + e.message)
			}
		},
		
		msgProviderGuildRevoke({ value }: msgProviderGuildRevokeParams): EncodeObject {
			try {
				return { typeUrl: "/structs.structs.MsgProviderGuildRevoke", value: MsgProviderGuildRevoke.fromPartial( value ) }  
			} catch (e: any) {
				throw new Error('TxClient:MsgProviderGuildRevoke: Could not create message: ' + e.message)
			}
		},
		
		msgProviderDelete({ value }: msgProviderDeleteParams): EncodeObject {
			try {
				return { typeUrl: "/structs.structs.MsgProviderDelete", value: MsgProviderDelete.fromPartial( value ) }  
			} catch (e: any) {
				throw new Error('TxClient:MsgProviderDelete: Could not create message: ' + e.message)
			}
		},
		
		agreement({ value }: agreementParams): EncodeObject {
			try {
				return { typeUrl: "/structs.structs.Agreement", value: Agreement.fromPartial( value ) }  
			} catch (e: any) {
				throw new Error('TxClient:Agreement: Could not create message: ' + e.message)
			}
		},
		
		eventGuildBankConfiscateAndBurnDetail({ value }: eventGuildBankConfiscateAndBurnDetailParams): EncodeObject {
			try {
				return { typeUrl: "/structs.structs.EventGuildBankConfiscateAndBurnDetail", value: EventGuildBankConfiscateAndBurnDetail.fromPartial( value ) }  
			} catch (e: any) {
				throw new Error('TxClient:EventGuildBankConfiscateAndBurnDetail: Could not create message: ' + e.message)
			}
		},
		
		eventGuildMembershipApplication({ value }: eventGuildMembershipApplicationParams): EncodeObject {
			try {
				return { typeUrl: "/structs.structs.EventGuildMembershipApplication", value: EventGuildMembershipApplication.fromPartial( value ) }  
			} catch (e: any) {
				throw new Error('TxClient:EventGuildMembershipApplication: Could not create message: ' + e.message)
			}
		},
		
		msgGuildMembershipJoin({ value }: msgGuildMembershipJoinParams): EncodeObject {
			try {
				return { typeUrl: "/structs.structs.MsgGuildMembershipJoin", value: MsgGuildMembershipJoin.fromPartial( value ) }  
			} catch (e: any) {
				throw new Error('TxClient:MsgGuildMembershipJoin: Could not create message: ' + e.message)
			}
		},
		
		msgPlanetExplore({ value }: msgPlanetExploreParams): EncodeObject {
			try {
				return { typeUrl: "/structs.structs.MsgPlanetExplore", value: MsgPlanetExplore.fromPartial( value ) }  
			} catch (e: any) {
				throw new Error('TxClient:MsgPlanetExplore: Could not create message: ' + e.message)
			}
		},
		
		msgStructStorageStash({ value }: msgStructStorageStashParams): EncodeObject {
			try {
				return { typeUrl: "/structs.structs.MsgStructStorageStash", value: MsgStructStorageStash.fromPartial( value ) }  
			} catch (e: any) {
				throw new Error('TxClient:MsgStructStorageStash: Could not create message: ' + e.message)
			}
		},
		
		msgSubstationAllocationConnectResponse({ value }: msgSubstationAllocationConnectResponseParams): EncodeObject {
			try {
				return { typeUrl: "/structs.structs.MsgSubstationAllocationConnectResponse", value: MsgSubstationAllocationConnectResponse.fromPartial( value ) }  
			} catch (e: any) {
				throw new Error('TxClient:MsgSubstationAllocationConnectResponse: Could not create message: ' + e.message)
			}
		},
		
		msgPermissionRevokeOnObject({ value }: msgPermissionRevokeOnObjectParams): EncodeObject {
			try {
				return { typeUrl: "/structs.structs.MsgPermissionRevokeOnObject", value: MsgPermissionRevokeOnObject.fromPartial( value ) }  
			} catch (e: any) {
				throw new Error('TxClient:MsgPermissionRevokeOnObject: Could not create message: ' + e.message)
			}
		},
		
		msgReactorCancelDefusion({ value }: msgReactorCancelDefusionParams): EncodeObject {
			try {
				return { typeUrl: "/structs.structs.MsgReactorCancelDefusion", value: MsgReactorCancelDefusion.fromPartial( value ) }  
			} catch (e: any) {
				throw new Error('TxClient:MsgReactorCancelDefusion: Could not create message: ' + e.message)
			}
		},
		
		msgSubstationAllocationConnect({ value }: msgSubstationAllocationConnectParams): EncodeObject {
			try {
				return { typeUrl: "/structs.structs.MsgSubstationAllocationConnect", value: MsgSubstationAllocationConnect.fromPartial( value ) }  
			} catch (e: any) {
				throw new Error('TxClient:MsgSubstationAllocationConnect: Could not create message: ' + e.message)
			}
		},
		
		queryGetPlanetRequest({ value }: queryGetPlanetRequestParams): EncodeObject {
			try {
				return { typeUrl: "/structs.structs.QueryGetPlanetRequest", value: QueryGetPlanetRequest.fromPartial( value ) }  
			} catch (e: any) {
				throw new Error('TxClient:QueryGetPlanetRequest: Could not create message: ' + e.message)
			}
		},
		
		structType({ value }: structTypeParams): EncodeObject {
			try {
				return { typeUrl: "/structs.structs.StructType", value: StructType.fromPartial( value ) }  
			} catch (e: any) {
				throw new Error('TxClient:StructType: Could not create message: ' + e.message)
			}
		},
		
		msgGuildMembershipResponse({ value }: msgGuildMembershipResponseParams): EncodeObject {
			try {
				return { typeUrl: "/structs.structs.MsgGuildMembershipResponse", value: MsgGuildMembershipResponse.fromPartial( value ) }  
			} catch (e: any) {
				throw new Error('TxClient:MsgGuildMembershipResponse: Could not create message: ' + e.message)
			}
		},
		
		msgReactorInfuse({ value }: msgReactorInfuseParams): EncodeObject {
			try {
				return { typeUrl: "/structs.structs.MsgReactorInfuse", value: MsgReactorInfuse.fromPartial( value ) }  
			} catch (e: any) {
				throw new Error('TxClient:MsgReactorInfuse: Could not create message: ' + e.message)
			}
		},
		
		msgStructBuildCompleteAndStash({ value }: msgStructBuildCompleteAndStashParams): EncodeObject {
			try {
				return { typeUrl: "/structs.structs.MsgStructBuildCompleteAndStash", value: MsgStructBuildCompleteAndStash.fromPartial( value ) }  
			} catch (e: any) {
				throw new Error('TxClient:MsgStructBuildCompleteAndStash: Could not create message: ' + e.message)
			}
		},
		
		addressAssociation({ value }: addressAssociationParams): EncodeObject {
			try {
				return { typeUrl: "/structs.structs.AddressAssociation", value: AddressAssociation.fromPartial( value ) }  
			} catch (e: any) {
				throw new Error('TxClient:AddressAssociation: Could not create message: ' + e.message)
			}
		},
		
		eventAddressAssociation({ value }: eventAddressAssociationParams): EncodeObject {
			try {
				return { typeUrl: "/structs.structs.EventAddressAssociation", value: EventAddressAssociation.fromPartial( value ) }  
			} catch (e: any) {
				throw new Error('TxClient:EventAddressAssociation: Could not create message: ' + e.message)
			}
		},
		
		msgReactorCancelDefusionResponse({ value }: msgReactorCancelDefusionResponseParams): EncodeObject {
			try {
				return { typeUrl: "/structs.structs.MsgReactorCancelDefusionResponse", value: MsgReactorCancelDefusionResponse.fromPartial( value ) }  
			} catch (e: any) {
				throw new Error('TxClient:MsgReactorCancelDefusionResponse: Could not create message: ' + e.message)
			}
		},
		
		addressRecord({ value }: addressRecordParams): EncodeObject {
			try {
				return { typeUrl: "/structs.structs.AddressRecord", value: AddressRecord.fromPartial( value ) }  
			} catch (e: any) {
				throw new Error('TxClient:AddressRecord: Could not create message: ' + e.message)
			}
		},
		
		structDefenders({ value }: structDefendersParams): EncodeObject {
			try {
				return { typeUrl: "/structs.structs.StructDefenders", value: StructDefenders.fromPartial( value ) }  
			} catch (e: any) {
				throw new Error('TxClient:StructDefenders: Could not create message: ' + e.message)
			}
		},
		
		eventPlanet({ value }: eventPlanetParams): EncodeObject {
			try {
				return { typeUrl: "/structs.structs.EventPlanet", value: EventPlanet.fromPartial( value ) }  
			} catch (e: any) {
				throw new Error('TxClient:EventPlanet: Could not create message: ' + e.message)
			}
		},
		
		msgGuildUpdateEntrySubstationId({ value }: msgGuildUpdateEntrySubstationIdParams): EncodeObject {
			try {
				return { typeUrl: "/structs.structs.MsgGuildUpdateEntrySubstationId", value: MsgGuildUpdateEntrySubstationId.fromPartial( value ) }  
			} catch (e: any) {
				throw new Error('TxClient:MsgGuildUpdateEntrySubstationId: Could not create message: ' + e.message)
			}
		},
		
		addressActivity({ value }: addressActivityParams): EncodeObject {
			try {
				return { typeUrl: "/structs.structs.AddressActivity", value: AddressActivity.fromPartial( value ) }  
			} catch (e: any) {
				throw new Error('TxClient:AddressActivity: Could not create message: ' + e.message)
			}
		},
		
		eventAlphaInfuse({ value }: eventAlphaInfuseParams): EncodeObject {
			try {
				return { typeUrl: "/structs.structs.EventAlphaInfuse", value: EventAlphaInfuse.fromPartial( value ) }  
			} catch (e: any) {
				throw new Error('TxClient:EventAlphaInfuse: Could not create message: ' + e.message)
			}
		},
		
		msgUpdateParamsResponse({ value }: msgUpdateParamsResponseParams): EncodeObject {
			try {
				return { typeUrl: "/structs.structs.MsgUpdateParamsResponse", value: MsgUpdateParamsResponse.fromPartial( value ) }  
			} catch (e: any) {
				throw new Error('TxClient:MsgUpdateParamsResponse: Could not create message: ' + e.message)
			}
		},
		
		msgStructOreRefineryComplete({ value }: msgStructOreRefineryCompleteParams): EncodeObject {
			try {
				return { typeUrl: "/structs.structs.MsgStructOreRefineryComplete", value: MsgStructOreRefineryComplete.fromPartial( value ) }  
			} catch (e: any) {
				throw new Error('TxClient:MsgStructOreRefineryComplete: Could not create message: ' + e.message)
			}
		},
		
		queryAllPlayerHaltedRequest({ value }: queryAllPlayerHaltedRequestParams): EncodeObject {
			try {
				return { typeUrl: "/structs.structs.QueryAllPlayerHaltedRequest", value: QueryAllPlayerHaltedRequest.fromPartial( value ) }  
			} catch (e: any) {
				throw new Error('TxClient:QueryAllPlayerHaltedRequest: Could not create message: ' + e.message)
			}
		},
		
		eventAlphaDefuse({ value }: eventAlphaDefuseParams): EncodeObject {
			try {
				return { typeUrl: "/structs.structs.EventAlphaDefuse", value: EventAlphaDefuse.fromPartial( value ) }  
			} catch (e: any) {
				throw new Error('TxClient:EventAlphaDefuse: Could not create message: ' + e.message)
			}
		},
		
		queryAllAddressResponse({ value }: queryAllAddressResponseParams): EncodeObject {
			try {
				return { typeUrl: "/structs.structs.QueryAllAddressResponse", value: QueryAllAddressResponse.fromPartial( value ) }  
			} catch (e: any) {
				throw new Error('TxClient:QueryAllAddressResponse: Could not create message: ' + e.message)
			}
		},
		
		queryGetPermissionResponse({ value }: queryGetPermissionResponseParams): EncodeObject {
			try {
				return { typeUrl: "/structs.structs.QueryGetPermissionResponse", value: QueryGetPermissionResponse.fromPartial( value ) }  
			} catch (e: any) {
				throw new Error('TxClient:QueryGetPermissionResponse: Could not create message: ' + e.message)
			}
		},
		
		queryGetPlanetAttributeRequest({ value }: queryGetPlanetAttributeRequestParams): EncodeObject {
			try {
				return { typeUrl: "/structs.structs.QueryGetPlanetAttributeRequest", value: QueryGetPlanetAttributeRequest.fromPartial( value ) }  
			} catch (e: any) {
				throw new Error('TxClient:QueryGetPlanetAttributeRequest: Could not create message: ' + e.message)
			}
		},
		
		eventPermission({ value }: eventPermissionParams): EncodeObject {
			try {
				return { typeUrl: "/structs.structs.EventPermission", value: EventPermission.fromPartial( value ) }  
			} catch (e: any) {
				throw new Error('TxClient:EventPermission: Could not create message: ' + e.message)
			}
		},
		
		eventOreTheftDetail({ value }: eventOreTheftDetailParams): EncodeObject {
			try {
				return { typeUrl: "/structs.structs.EventOreTheftDetail", value: EventOreTheftDetail.fromPartial( value ) }  
			} catch (e: any) {
				throw new Error('TxClient:EventOreTheftDetail: Could not create message: ' + e.message)
			}
		},
		
		queryGetPlanetResponse({ value }: queryGetPlanetResponseParams): EncodeObject {
			try {
				return { typeUrl: "/structs.structs.QueryGetPlanetResponse", value: QueryGetPlanetResponse.fromPartial( value ) }  
			} catch (e: any) {
				throw new Error('TxClient:QueryGetPlanetResponse: Could not create message: ' + e.message)
			}
		},
		
		infusion({ value }: infusionParams): EncodeObject {
			try {
				return { typeUrl: "/structs.structs.Infusion", value: Infusion.fromPartial( value ) }  
			} catch (e: any) {
				throw new Error('TxClient:Infusion: Could not create message: ' + e.message)
			}
		},
		
		msgGuildCreate({ value }: msgGuildCreateParams): EncodeObject {
			try {
				return { typeUrl: "/structs.structs.MsgGuildCreate", value: MsgGuildCreate.fromPartial( value ) }  
			} catch (e: any) {
				throw new Error('TxClient:MsgGuildCreate: Could not create message: ' + e.message)
			}
		},
		
		msgGuildMembershipRequest({ value }: msgGuildMembershipRequestParams): EncodeObject {
			try {
				return { typeUrl: "/structs.structs.MsgGuildMembershipRequest", value: MsgGuildMembershipRequest.fromPartial( value ) }  
			} catch (e: any) {
				throw new Error('TxClient:MsgGuildMembershipRequest: Could not create message: ' + e.message)
			}
		},
		
		msgPlayerUpdatePrimaryAddressResponse({ value }: msgPlayerUpdatePrimaryAddressResponseParams): EncodeObject {
			try {
				return { typeUrl: "/structs.structs.MsgPlayerUpdatePrimaryAddressResponse", value: MsgPlayerUpdatePrimaryAddressResponse.fromPartial( value ) }  
			} catch (e: any) {
				throw new Error('TxClient:MsgPlayerUpdatePrimaryAddressResponse: Could not create message: ' + e.message)
			}
		},
		
		msgAgreementClose({ value }: msgAgreementCloseParams): EncodeObject {
			try {
				return { typeUrl: "/structs.structs.MsgAgreementClose", value: MsgAgreementClose.fromPartial( value ) }  
			} catch (e: any) {
				throw new Error('TxClient:MsgAgreementClose: Could not create message: ' + e.message)
			}
		},
		
		queryGetAgreementResponse({ value }: queryGetAgreementResponseParams): EncodeObject {
			try {
				return { typeUrl: "/structs.structs.QueryGetAgreementResponse", value: QueryGetAgreementResponse.fromPartial( value ) }  
			} catch (e: any) {
				throw new Error('TxClient:QueryGetAgreementResponse: Could not create message: ' + e.message)
			}
		},
		
		eventOreMigrate({ value }: eventOreMigrateParams): EncodeObject {
			try {
				return { typeUrl: "/structs.structs.EventOreMigrate", value: EventOreMigrate.fromPartial( value ) }  
			} catch (e: any) {
				throw new Error('TxClient:EventOreMigrate: Could not create message: ' + e.message)
			}
		},
		
		msgGuildCreateResponse({ value }: msgGuildCreateResponseParams): EncodeObject {
			try {
				return { typeUrl: "/structs.structs.MsgGuildCreateResponse", value: MsgGuildCreateResponse.fromPartial( value ) }  
			} catch (e: any) {
				throw new Error('TxClient:MsgGuildCreateResponse: Could not create message: ' + e.message)
			}
		},
		
		msgProviderGuildGrant({ value }: msgProviderGuildGrantParams): EncodeObject {
			try {
				return { typeUrl: "/structs.structs.MsgProviderGuildGrant", value: MsgProviderGuildGrant.fromPartial( value ) }  
			} catch (e: any) {
				throw new Error('TxClient:MsgProviderGuildGrant: Could not create message: ' + e.message)
			}
		},
		
		queryAddressResponse({ value }: queryAddressResponseParams): EncodeObject {
			try {
				return { typeUrl: "/structs.structs.QueryAddressResponse", value: QueryAddressResponse.fromPartial( value ) }  
			} catch (e: any) {
				throw new Error('TxClient:QueryAddressResponse: Could not create message: ' + e.message)
			}
		},
		
		msgGuildMembershipRequestDeny({ value }: msgGuildMembershipRequestDenyParams): EncodeObject {
			try {
				return { typeUrl: "/structs.structs.MsgGuildMembershipRequestDeny", value: MsgGuildMembershipRequestDeny.fromPartial( value ) }  
			} catch (e: any) {
				throw new Error('TxClient:MsgGuildMembershipRequestDeny: Could not create message: ' + e.message)
			}
		},
		
		msgStructDeactivate({ value }: msgStructDeactivateParams): EncodeObject {
			try {
				return { typeUrl: "/structs.structs.MsgStructDeactivate", value: MsgStructDeactivate.fromPartial( value ) }  
			} catch (e: any) {
				throw new Error('TxClient:MsgStructDeactivate: Could not create message: ' + e.message)
			}
		},
		
		msgProviderResponse({ value }: msgProviderResponseParams): EncodeObject {
			try {
				return { typeUrl: "/structs.structs.MsgProviderResponse", value: MsgProviderResponse.fromPartial( value ) }  
			} catch (e: any) {
				throw new Error('TxClient:MsgProviderResponse: Could not create message: ' + e.message)
			}
		},
		
		queryAllPlanetResponse({ value }: queryAllPlanetResponseParams): EncodeObject {
			try {
				return { typeUrl: "/structs.structs.QueryAllPlanetResponse", value: QueryAllPlanetResponse.fromPartial( value ) }  
			} catch (e: any) {
				throw new Error('TxClient:QueryAllPlanetResponse: Could not create message: ' + e.message)
			}
		},
		
		queryAllProviderResponse({ value }: queryAllProviderResponseParams): EncodeObject {
			try {
				return { typeUrl: "/structs.structs.QueryAllProviderResponse", value: QueryAllProviderResponse.fromPartial( value ) }  
			} catch (e: any) {
				throw new Error('TxClient:QueryAllProviderResponse: Could not create message: ' + e.message)
			}
		},
		
		eventAlphaInfuseDetail({ value }: eventAlphaInfuseDetailParams): EncodeObject {
			try {
				return { typeUrl: "/structs.structs.EventAlphaInfuseDetail", value: EventAlphaInfuseDetail.fromPartial( value ) }  
			} catch (e: any) {
				throw new Error('TxClient:EventAlphaInfuseDetail: Could not create message: ' + e.message)
			}
		},
		
	}
};

interface QueryClientOptions {
  addr: string
}

export const queryClient = ({ addr: addr }: QueryClientOptions = { addr: "http://localhost:1317" }) => {
  return new Api({ baseURL: addr });
};

class SDKModule {
	public query: ReturnType<typeof queryClient>;
	public tx: ReturnType<typeof txClient>;
	public structure: Record<string,unknown>;
	public registry: Array<[string, GeneratedType]> = [];

	constructor(client: IgniteClient) {		
	
		this.query = queryClient({ addr: client.env.apiURL });		
		this.updateTX(client);
		this.structure =  {
						
		};
		client.on('signer-changed',(signer) => {			
		 this.updateTX(client);
		})
	}
	updateTX(client: IgniteClient) {
    const methods = txClient({
        signer: client.signer,
        addr: client.env.rpcURL,
        prefix: client.env.prefix ?? "cosmos",
    })
	
    this.tx = methods;
    for (let m in methods) {
        this.tx[m] = methods[m].bind(this.tx);
    }
	}
};

const IgntModule = (test: IgniteClient) => {
	return {
		module: {
			StructsStructs: new SDKModule(test)
		},
		registry: msgTypes
  }
}
export default IgntModule;