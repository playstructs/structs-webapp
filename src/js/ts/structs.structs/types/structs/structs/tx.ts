// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.6.1
//   protoc               unknown
// source: structs/structs/tx.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import { Coin } from "../../cosmos/base/v1beta1/coin";
import { Fleet } from "./fleet";
import { GuildMembershipApplication } from "./guild";
import {
  allocationType,
  allocationTypeFromJSON,
  allocationTypeToJSON,
  ambit,
  ambitFromJSON,
  ambitToJSON,
  guildJoinBypassLevel,
  guildJoinBypassLevelFromJSON,
  guildJoinBypassLevelToJSON,
  objectType,
  objectTypeFromJSON,
  objectTypeToJSON,
  providerAccessPolicy,
  providerAccessPolicyFromJSON,
  providerAccessPolicyToJSON,
} from "./keys";
import { Params } from "./params";
import { Planet } from "./planet";
import { Struct } from "./struct";

export const protobufPackage = "structs.structs";

/** MsgUpdateParams is the Msg/UpdateParams request type. */
export interface MsgUpdateParams {
  /** authority is the address that controls the module (defaults to x/gov unless overwritten). */
  authority: string;
  /**
   * params defines the module parameters to update.
   *
   * NOTE: All parameters must be supplied.
   */
  params: Params | undefined;
}

/**
 * MsgUpdateParamsResponse defines the response structure for executing a
 * MsgUpdateParams message.
 */
export interface MsgUpdateParamsResponse {
}

export interface MsgAddressRegister {
  creator: string;
  playerId: string;
  address: string;
  proofPubKey: string;
  proofSignature: string;
  permissions: number;
}

export interface MsgAddressRegisterResponse {
}

export interface MsgAddressRevoke {
  creator: string;
  address: string;
}

export interface MsgAddressRevokeResponse {
}

export interface MsgAllocationCreate {
  creator: string;
  controller: string;
  sourceObjectId: string;
  allocationType: allocationType;
  power: number;
}

export interface MsgAllocationCreateResponse {
  allocationId: string;
}

export interface MsgAllocationDelete {
  creator: string;
  allocationId: string;
}

export interface MsgAllocationDeleteResponse {
  allocationId: string;
}

export interface MsgAllocationUpdate {
  creator: string;
  allocationId: string;
  power: number;
}

export interface MsgAllocationUpdateResponse {
  allocationId: string;
}

export interface MsgAllocationTransfer {
  creator: string;
  allocationId: string;
  controller: string;
}

export interface MsgAllocationTransferResponse {
  allocationId: string;
}

export interface MsgFleetMove {
  creator: string;
  fleetId: string;
  destinationLocationId: string;
}

export interface MsgFleetMoveResponse {
  fleet: Fleet | undefined;
}

export interface MsgGuildBankMint {
  creator: string;
  amountAlpha: number;
  amountToken: number;
}

export interface MsgGuildBankMintResponse {
}

export interface MsgGuildBankRedeem {
  creator: string;
  amountToken: Coin | undefined;
}

export interface MsgGuildBankRedeemResponse {
}

export interface MsgGuildBankConfiscateAndBurn {
  creator: string;
  address: string;
  amountToken: number;
}

export interface MsgGuildBankConfiscateAndBurnResponse {
}

export interface MsgGuildCreate {
  creator: string;
  endpoint: string;
  entrySubstationId: string;
}

export interface MsgGuildCreateResponse {
  guildId: string;
}

export interface MsgGuildUpdateOwnerId {
  creator: string;
  guildId: string;
  owner: string;
}

export interface MsgGuildUpdateEntrySubstationId {
  creator: string;
  guildId: string;
  entrySubstationId: string;
}

export interface MsgGuildUpdateEndpoint {
  creator: string;
  guildId: string;
  endpoint: string;
}

export interface MsgGuildUpdateJoinInfusionMinimum {
  creator: string;
  guildId: string;
  joinInfusionMinimum: number;
}

export interface MsgGuildUpdateJoinInfusionMinimumBypassByRequest {
  creator: string;
  guildId: string;
  guildJoinBypassLevel: guildJoinBypassLevel;
}

export interface MsgGuildUpdateJoinInfusionMinimumBypassByInvite {
  creator: string;
  guildId: string;
  guildJoinBypassLevel: guildJoinBypassLevel;
}

export interface MsgGuildUpdateResponse {
}

export interface MsgGuildMembershipInvite {
  creator: string;
  guildId: string;
  playerId: string;
  substationId: string;
}

export interface MsgGuildMembershipInviteApprove {
  creator: string;
  guildId: string;
  playerId: string;
  substationId: string;
}

export interface MsgGuildMembershipInviteDeny {
  creator: string;
  guildId: string;
  playerId: string;
}

export interface MsgGuildMembershipInviteRevoke {
  creator: string;
  guildId: string;
  playerId: string;
}

export interface MsgGuildMembershipJoin {
  creator: string;
  guildId: string;
  playerId: string;
  substationId: string;
  infusionId: string[];
}

export interface MsgGuildMembershipJoinProxy {
  creator: string;
  address: string;
  substationId: string;
  proofPubKey: string;
  proofSignature: string;
}

export interface MsgGuildMembershipKick {
  creator: string;
  guildId: string;
  playerId: string;
}

export interface MsgGuildMembershipRequest {
  creator: string;
  guildId: string;
  playerId: string;
  substationId: string;
}

export interface MsgGuildMembershipRequestApprove {
  creator: string;
  guildId: string;
  playerId: string;
  substationId: string;
}

export interface MsgGuildMembershipRequestDeny {
  creator: string;
  guildId: string;
  playerId: string;
}

export interface MsgGuildMembershipRequestRevoke {
  creator: string;
  guildId: string;
  playerId: string;
}

export interface MsgGuildMembershipResponse {
  guildMembershipApplication: GuildMembershipApplication | undefined;
}

export interface MsgPermissionGrantOnObject {
  creator: string;
  objectId: string;
  playerId: string;
  permissions: number;
}

export interface MsgPermissionGrantOnAddress {
  creator: string;
  address: string;
  permissions: number;
}

export interface MsgPermissionRevokeOnObject {
  creator: string;
  objectId: string;
  playerId: string;
  permissions: number;
}

export interface MsgPermissionRevokeOnAddress {
  creator: string;
  address: string;
  permissions: number;
}

export interface MsgPermissionSetOnObject {
  creator: string;
  objectId: string;
  playerId: string;
  permissions: number;
}

export interface MsgPermissionSetOnAddress {
  creator: string;
  address: string;
  permissions: number;
}

export interface MsgPermissionResponse {
}

export interface MsgPlanetExplore {
  creator: string;
  playerId: string;
}

export interface MsgPlanetExploreResponse {
  planet: Planet | undefined;
}

export interface MsgPlanetRaidComplete {
  creator: string;
  fleetId: string;
  proof: string;
  nonce: string;
}

export interface MsgPlanetRaidCompleteResponse {
  fleet: Fleet | undefined;
  planet: Planet | undefined;
  oreStolen: number;
}

export interface MsgPlayerUpdatePrimaryAddress {
  creator: string;
  playerId: string;
  primaryAddress: string;
}

export interface MsgPlayerUpdatePrimaryAddressResponse {
}

export interface MsgPlayerResume {
  creator: string;
  playerId: string;
}

export interface MsgPlayerResumeResponse {
}

export interface MsgStructStatusResponse {
  struct: Struct | undefined;
}

export interface MsgStructActivate {
  creator: string;
  structId: string;
}

export interface MsgStructDeactivate {
  creator: string;
  structId: string;
}

export interface MsgStructBuildInitiate {
  creator: string;
  playerId: string;
  structTypeId: number;
  /** objectType locationType = 4; */
  operatingAmbit: ambit;
  slot: number;
}

export interface MsgStructBuildComplete {
  creator: string;
  structId: string;
  proof: string;
  nonce: string;
}

export interface MsgStructBuildCancel {
  creator: string;
  structId: string;
}

export interface MsgStructBuildCompleteAndStash {
  creator: string;
  structId: string;
  proof: string;
  nonce: string;
  storageDestinationId: string;
  storageAmbit: ambit;
  storageSlot: number;
}

export interface MsgStructDefenseSet {
  creator: string;
  defenderStructId: string;
  protectedStructId: string;
}

export interface MsgStructDefenseClear {
  creator: string;
  defenderStructId: string;
}

export interface MsgStructMove {
  creator: string;
  structId: string;
  locationType: objectType;
  ambit: ambit;
  slot: number;
}

export interface MsgStructAttack {
  creator: string;
  operatingStructId: string;
  targetStructId: string[];
  weaponSystem: string;
}

export interface MsgStructAttackResponse {
}

export interface MsgStructStealthActivate {
  creator: string;
  structId: string;
}

export interface MsgStructStealthDeactivate {
  creator: string;
  structId: string;
}

export interface MsgStructGeneratorInfuse {
  creator: string;
  structId: string;
  infuseAmount: string;
}

export interface MsgStructGeneratorStatusResponse {
}

export interface MsgStructOreMinerComplete {
  creator: string;
  structId: string;
  proof: string;
  nonce: string;
}

export interface MsgStructOreMinerStatusResponse {
  struct: Struct | undefined;
}

export interface MsgStructOreRefineryComplete {
  creator: string;
  structId: string;
  proof: string;
  nonce: string;
}

export interface MsgStructOreRefineryStatusResponse {
  struct: Struct | undefined;
}

export interface MsgStructStorageStash {
  creator: string;
  structId: string;
  locationId: string;
  ambit: ambit;
  slot: number;
}

export interface MsgStructStorageRecall {
  creator: string;
  structId: string;
  locationId: string;
  ambit: ambit;
  slot: number;
  activate: boolean;
}

export interface MsgSubstationCreate {
  creator: string;
  owner: string;
  allocationId: string;
}

export interface MsgSubstationCreateResponse {
  substationId: string;
}

export interface MsgSubstationDelete {
  creator: string;
  substationId: string;
  migrationSubstationId: string;
}

export interface MsgSubstationDeleteResponse {
}

export interface MsgSubstationAllocationConnect {
  creator: string;
  allocationId: string;
  destinationId: string;
}

export interface MsgSubstationAllocationConnectResponse {
}

export interface MsgSubstationAllocationDisconnect {
  creator: string;
  allocationId: string;
}

export interface MsgSubstationAllocationDisconnectResponse {
}

export interface MsgSubstationPlayerConnect {
  creator: string;
  substationId: string;
  playerId: string;
}

export interface MsgSubstationPlayerConnectResponse {
}

export interface MsgSubstationPlayerDisconnect {
  creator: string;
  playerId: string;
}

export interface MsgSubstationPlayerDisconnectResponse {
}

export interface MsgSubstationPlayerMigrate {
  creator: string;
  substationId: string;
  playerId: string[];
}

export interface MsgSubstationPlayerMigrateResponse {
}

export interface MsgAgreementOpen {
  creator: string;
  providerId: string;
  duration: number;
  capacity: number;
}

export interface MsgAgreementClose {
  creator: string;
  agreementId: string;
}

export interface MsgAgreementCapacityIncrease {
  creator: string;
  agreementId: string;
  capacityIncrease: number;
}

export interface MsgAgreementCapacityDecrease {
  creator: string;
  agreementId: string;
  capacityDecrease: number;
}

export interface MsgAgreementDurationIncrease {
  creator: string;
  agreementId: string;
  durationIncrease: number;
}

export interface MsgAgreementResponse {
}

export interface MsgProviderCreate {
  creator: string;
  substationId: string;
  rate: Coin | undefined;
  accessPolicy: providerAccessPolicy;
  providerCancellationPenalty: string;
  consumerCancellationPenalty: string;
  capacityMinimum: number;
  capacityMaximum: number;
  durationMinimum: number;
  durationMaximum: number;
}

export interface MsgProviderWithdrawBalance {
  creator: string;
  providerId: string;
  destinationAddress: string;
}

export interface MsgProviderUpdateCapacityMinimum {
  creator: string;
  providerId: string;
  newMinimumCapacity: number;
}

export interface MsgProviderUpdateCapacityMaximum {
  creator: string;
  providerId: string;
  newMaximumCapacity: number;
}

export interface MsgProviderUpdateDurationMinimum {
  creator: string;
  providerId: string;
  newMinimumDuration: number;
}

export interface MsgProviderUpdateDurationMaximum {
  creator: string;
  providerId: string;
  newMaximumDuration: number;
}

export interface MsgProviderUpdateAccessPolicy {
  creator: string;
  providerId: string;
  accessPolicy: providerAccessPolicy;
}

export interface MsgProviderGuildGrant {
  creator: string;
  providerId: string;
  guildId: string[];
}

export interface MsgProviderGuildRevoke {
  creator: string;
  providerId: string;
  guildId: string[];
}

export interface MsgProviderDelete {
  creator: string;
  providerId: string;
}

export interface MsgProviderResponse {
}

function createBaseMsgUpdateParams(): MsgUpdateParams {
  return { authority: "", params: undefined };
}

export const MsgUpdateParams: MessageFns<MsgUpdateParams> = {
  encode(message: MsgUpdateParams, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.authority !== "") {
      writer.uint32(10).string(message.authority);
    }
    if (message.params !== undefined) {
      Params.encode(message.params, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MsgUpdateParams {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgUpdateParams();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.authority = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.params = Params.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MsgUpdateParams {
    return {
      authority: isSet(object.authority) ? globalThis.String(object.authority) : "",
      params: isSet(object.params) ? Params.fromJSON(object.params) : undefined,
    };
  },

  toJSON(message: MsgUpdateParams): unknown {
    const obj: any = {};
    if (message.authority !== "") {
      obj.authority = message.authority;
    }
    if (message.params !== undefined) {
      obj.params = Params.toJSON(message.params);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<MsgUpdateParams>, I>>(base?: I): MsgUpdateParams {
    return MsgUpdateParams.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MsgUpdateParams>, I>>(object: I): MsgUpdateParams {
    const message = createBaseMsgUpdateParams();
    message.authority = object.authority ?? "";
    message.params = (object.params !== undefined && object.params !== null)
      ? Params.fromPartial(object.params)
      : undefined;
    return message;
  },
};

function createBaseMsgUpdateParamsResponse(): MsgUpdateParamsResponse {
  return {};
}

export const MsgUpdateParamsResponse: MessageFns<MsgUpdateParamsResponse> = {
  encode(_: MsgUpdateParamsResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MsgUpdateParamsResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgUpdateParamsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): MsgUpdateParamsResponse {
    return {};
  },

  toJSON(_: MsgUpdateParamsResponse): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<MsgUpdateParamsResponse>, I>>(base?: I): MsgUpdateParamsResponse {
    return MsgUpdateParamsResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MsgUpdateParamsResponse>, I>>(_: I): MsgUpdateParamsResponse {
    const message = createBaseMsgUpdateParamsResponse();
    return message;
  },
};

function createBaseMsgAddressRegister(): MsgAddressRegister {
  return { creator: "", playerId: "", address: "", proofPubKey: "", proofSignature: "", permissions: 0 };
}

export const MsgAddressRegister: MessageFns<MsgAddressRegister> = {
  encode(message: MsgAddressRegister, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.creator !== "") {
      writer.uint32(10).string(message.creator);
    }
    if (message.playerId !== "") {
      writer.uint32(18).string(message.playerId);
    }
    if (message.address !== "") {
      writer.uint32(26).string(message.address);
    }
    if (message.proofPubKey !== "") {
      writer.uint32(34).string(message.proofPubKey);
    }
    if (message.proofSignature !== "") {
      writer.uint32(42).string(message.proofSignature);
    }
    if (message.permissions !== 0) {
      writer.uint32(48).uint64(message.permissions);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MsgAddressRegister {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgAddressRegister();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.creator = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.playerId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.address = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.proofPubKey = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.proofSignature = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.permissions = longToNumber(reader.uint64());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MsgAddressRegister {
    return {
      creator: isSet(object.creator) ? globalThis.String(object.creator) : "",
      playerId: isSet(object.playerId) ? globalThis.String(object.playerId) : "",
      address: isSet(object.address) ? globalThis.String(object.address) : "",
      proofPubKey: isSet(object.proofPubKey) ? globalThis.String(object.proofPubKey) : "",
      proofSignature: isSet(object.proofSignature) ? globalThis.String(object.proofSignature) : "",
      permissions: isSet(object.permissions) ? globalThis.Number(object.permissions) : 0,
    };
  },

  toJSON(message: MsgAddressRegister): unknown {
    const obj: any = {};
    if (message.creator !== "") {
      obj.creator = message.creator;
    }
    if (message.playerId !== "") {
      obj.playerId = message.playerId;
    }
    if (message.address !== "") {
      obj.address = message.address;
    }
    if (message.proofPubKey !== "") {
      obj.proofPubKey = message.proofPubKey;
    }
    if (message.proofSignature !== "") {
      obj.proofSignature = message.proofSignature;
    }
    if (message.permissions !== 0) {
      obj.permissions = Math.round(message.permissions);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<MsgAddressRegister>, I>>(base?: I): MsgAddressRegister {
    return MsgAddressRegister.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MsgAddressRegister>, I>>(object: I): MsgAddressRegister {
    const message = createBaseMsgAddressRegister();
    message.creator = object.creator ?? "";
    message.playerId = object.playerId ?? "";
    message.address = object.address ?? "";
    message.proofPubKey = object.proofPubKey ?? "";
    message.proofSignature = object.proofSignature ?? "";
    message.permissions = object.permissions ?? 0;
    return message;
  },
};

function createBaseMsgAddressRegisterResponse(): MsgAddressRegisterResponse {
  return {};
}

export const MsgAddressRegisterResponse: MessageFns<MsgAddressRegisterResponse> = {
  encode(_: MsgAddressRegisterResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MsgAddressRegisterResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgAddressRegisterResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): MsgAddressRegisterResponse {
    return {};
  },

  toJSON(_: MsgAddressRegisterResponse): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<MsgAddressRegisterResponse>, I>>(base?: I): MsgAddressRegisterResponse {
    return MsgAddressRegisterResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MsgAddressRegisterResponse>, I>>(_: I): MsgAddressRegisterResponse {
    const message = createBaseMsgAddressRegisterResponse();
    return message;
  },
};

function createBaseMsgAddressRevoke(): MsgAddressRevoke {
  return { creator: "", address: "" };
}

export const MsgAddressRevoke: MessageFns<MsgAddressRevoke> = {
  encode(message: MsgAddressRevoke, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.creator !== "") {
      writer.uint32(10).string(message.creator);
    }
    if (message.address !== "") {
      writer.uint32(18).string(message.address);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MsgAddressRevoke {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgAddressRevoke();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.creator = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.address = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MsgAddressRevoke {
    return {
      creator: isSet(object.creator) ? globalThis.String(object.creator) : "",
      address: isSet(object.address) ? globalThis.String(object.address) : "",
    };
  },

  toJSON(message: MsgAddressRevoke): unknown {
    const obj: any = {};
    if (message.creator !== "") {
      obj.creator = message.creator;
    }
    if (message.address !== "") {
      obj.address = message.address;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<MsgAddressRevoke>, I>>(base?: I): MsgAddressRevoke {
    return MsgAddressRevoke.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MsgAddressRevoke>, I>>(object: I): MsgAddressRevoke {
    const message = createBaseMsgAddressRevoke();
    message.creator = object.creator ?? "";
    message.address = object.address ?? "";
    return message;
  },
};

function createBaseMsgAddressRevokeResponse(): MsgAddressRevokeResponse {
  return {};
}

export const MsgAddressRevokeResponse: MessageFns<MsgAddressRevokeResponse> = {
  encode(_: MsgAddressRevokeResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MsgAddressRevokeResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgAddressRevokeResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): MsgAddressRevokeResponse {
    return {};
  },

  toJSON(_: MsgAddressRevokeResponse): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<MsgAddressRevokeResponse>, I>>(base?: I): MsgAddressRevokeResponse {
    return MsgAddressRevokeResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MsgAddressRevokeResponse>, I>>(_: I): MsgAddressRevokeResponse {
    const message = createBaseMsgAddressRevokeResponse();
    return message;
  },
};

function createBaseMsgAllocationCreate(): MsgAllocationCreate {
  return { creator: "", controller: "", sourceObjectId: "", allocationType: 0, power: 0 };
}

export const MsgAllocationCreate: MessageFns<MsgAllocationCreate> = {
  encode(message: MsgAllocationCreate, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.creator !== "") {
      writer.uint32(10).string(message.creator);
    }
    if (message.controller !== "") {
      writer.uint32(18).string(message.controller);
    }
    if (message.sourceObjectId !== "") {
      writer.uint32(26).string(message.sourceObjectId);
    }
    if (message.allocationType !== 0) {
      writer.uint32(32).int32(message.allocationType);
    }
    if (message.power !== 0) {
      writer.uint32(40).uint64(message.power);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MsgAllocationCreate {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgAllocationCreate();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.creator = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.controller = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.sourceObjectId = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.allocationType = reader.int32() as any;
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.power = longToNumber(reader.uint64());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MsgAllocationCreate {
    return {
      creator: isSet(object.creator) ? globalThis.String(object.creator) : "",
      controller: isSet(object.controller) ? globalThis.String(object.controller) : "",
      sourceObjectId: isSet(object.sourceObjectId) ? globalThis.String(object.sourceObjectId) : "",
      allocationType: isSet(object.allocationType) ? allocationTypeFromJSON(object.allocationType) : 0,
      power: isSet(object.power) ? globalThis.Number(object.power) : 0,
    };
  },

  toJSON(message: MsgAllocationCreate): unknown {
    const obj: any = {};
    if (message.creator !== "") {
      obj.creator = message.creator;
    }
    if (message.controller !== "") {
      obj.controller = message.controller;
    }
    if (message.sourceObjectId !== "") {
      obj.sourceObjectId = message.sourceObjectId;
    }
    if (message.allocationType !== 0) {
      obj.allocationType = allocationTypeToJSON(message.allocationType);
    }
    if (message.power !== 0) {
      obj.power = Math.round(message.power);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<MsgAllocationCreate>, I>>(base?: I): MsgAllocationCreate {
    return MsgAllocationCreate.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MsgAllocationCreate>, I>>(object: I): MsgAllocationCreate {
    const message = createBaseMsgAllocationCreate();
    message.creator = object.creator ?? "";
    message.controller = object.controller ?? "";
    message.sourceObjectId = object.sourceObjectId ?? "";
    message.allocationType = object.allocationType ?? 0;
    message.power = object.power ?? 0;
    return message;
  },
};

function createBaseMsgAllocationCreateResponse(): MsgAllocationCreateResponse {
  return { allocationId: "" };
}

export const MsgAllocationCreateResponse: MessageFns<MsgAllocationCreateResponse> = {
  encode(message: MsgAllocationCreateResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.allocationId !== "") {
      writer.uint32(10).string(message.allocationId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MsgAllocationCreateResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgAllocationCreateResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.allocationId = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MsgAllocationCreateResponse {
    return { allocationId: isSet(object.allocationId) ? globalThis.String(object.allocationId) : "" };
  },

  toJSON(message: MsgAllocationCreateResponse): unknown {
    const obj: any = {};
    if (message.allocationId !== "") {
      obj.allocationId = message.allocationId;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<MsgAllocationCreateResponse>, I>>(base?: I): MsgAllocationCreateResponse {
    return MsgAllocationCreateResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MsgAllocationCreateResponse>, I>>(object: I): MsgAllocationCreateResponse {
    const message = createBaseMsgAllocationCreateResponse();
    message.allocationId = object.allocationId ?? "";
    return message;
  },
};

function createBaseMsgAllocationDelete(): MsgAllocationDelete {
  return { creator: "", allocationId: "" };
}

export const MsgAllocationDelete: MessageFns<MsgAllocationDelete> = {
  encode(message: MsgAllocationDelete, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.creator !== "") {
      writer.uint32(10).string(message.creator);
    }
    if (message.allocationId !== "") {
      writer.uint32(18).string(message.allocationId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MsgAllocationDelete {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgAllocationDelete();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.creator = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.allocationId = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MsgAllocationDelete {
    return {
      creator: isSet(object.creator) ? globalThis.String(object.creator) : "",
      allocationId: isSet(object.allocationId) ? globalThis.String(object.allocationId) : "",
    };
  },

  toJSON(message: MsgAllocationDelete): unknown {
    const obj: any = {};
    if (message.creator !== "") {
      obj.creator = message.creator;
    }
    if (message.allocationId !== "") {
      obj.allocationId = message.allocationId;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<MsgAllocationDelete>, I>>(base?: I): MsgAllocationDelete {
    return MsgAllocationDelete.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MsgAllocationDelete>, I>>(object: I): MsgAllocationDelete {
    const message = createBaseMsgAllocationDelete();
    message.creator = object.creator ?? "";
    message.allocationId = object.allocationId ?? "";
    return message;
  },
};

function createBaseMsgAllocationDeleteResponse(): MsgAllocationDeleteResponse {
  return { allocationId: "" };
}

export const MsgAllocationDeleteResponse: MessageFns<MsgAllocationDeleteResponse> = {
  encode(message: MsgAllocationDeleteResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.allocationId !== "") {
      writer.uint32(10).string(message.allocationId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MsgAllocationDeleteResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgAllocationDeleteResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.allocationId = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MsgAllocationDeleteResponse {
    return { allocationId: isSet(object.allocationId) ? globalThis.String(object.allocationId) : "" };
  },

  toJSON(message: MsgAllocationDeleteResponse): unknown {
    const obj: any = {};
    if (message.allocationId !== "") {
      obj.allocationId = message.allocationId;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<MsgAllocationDeleteResponse>, I>>(base?: I): MsgAllocationDeleteResponse {
    return MsgAllocationDeleteResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MsgAllocationDeleteResponse>, I>>(object: I): MsgAllocationDeleteResponse {
    const message = createBaseMsgAllocationDeleteResponse();
    message.allocationId = object.allocationId ?? "";
    return message;
  },
};

function createBaseMsgAllocationUpdate(): MsgAllocationUpdate {
  return { creator: "", allocationId: "", power: 0 };
}

export const MsgAllocationUpdate: MessageFns<MsgAllocationUpdate> = {
  encode(message: MsgAllocationUpdate, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.creator !== "") {
      writer.uint32(10).string(message.creator);
    }
    if (message.allocationId !== "") {
      writer.uint32(18).string(message.allocationId);
    }
    if (message.power !== 0) {
      writer.uint32(24).uint64(message.power);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MsgAllocationUpdate {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgAllocationUpdate();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.creator = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.allocationId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.power = longToNumber(reader.uint64());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MsgAllocationUpdate {
    return {
      creator: isSet(object.creator) ? globalThis.String(object.creator) : "",
      allocationId: isSet(object.allocationId) ? globalThis.String(object.allocationId) : "",
      power: isSet(object.power) ? globalThis.Number(object.power) : 0,
    };
  },

  toJSON(message: MsgAllocationUpdate): unknown {
    const obj: any = {};
    if (message.creator !== "") {
      obj.creator = message.creator;
    }
    if (message.allocationId !== "") {
      obj.allocationId = message.allocationId;
    }
    if (message.power !== 0) {
      obj.power = Math.round(message.power);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<MsgAllocationUpdate>, I>>(base?: I): MsgAllocationUpdate {
    return MsgAllocationUpdate.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MsgAllocationUpdate>, I>>(object: I): MsgAllocationUpdate {
    const message = createBaseMsgAllocationUpdate();
    message.creator = object.creator ?? "";
    message.allocationId = object.allocationId ?? "";
    message.power = object.power ?? 0;
    return message;
  },
};

function createBaseMsgAllocationUpdateResponse(): MsgAllocationUpdateResponse {
  return { allocationId: "" };
}

export const MsgAllocationUpdateResponse: MessageFns<MsgAllocationUpdateResponse> = {
  encode(message: MsgAllocationUpdateResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.allocationId !== "") {
      writer.uint32(10).string(message.allocationId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MsgAllocationUpdateResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgAllocationUpdateResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.allocationId = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MsgAllocationUpdateResponse {
    return { allocationId: isSet(object.allocationId) ? globalThis.String(object.allocationId) : "" };
  },

  toJSON(message: MsgAllocationUpdateResponse): unknown {
    const obj: any = {};
    if (message.allocationId !== "") {
      obj.allocationId = message.allocationId;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<MsgAllocationUpdateResponse>, I>>(base?: I): MsgAllocationUpdateResponse {
    return MsgAllocationUpdateResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MsgAllocationUpdateResponse>, I>>(object: I): MsgAllocationUpdateResponse {
    const message = createBaseMsgAllocationUpdateResponse();
    message.allocationId = object.allocationId ?? "";
    return message;
  },
};

function createBaseMsgAllocationTransfer(): MsgAllocationTransfer {
  return { creator: "", allocationId: "", controller: "" };
}

export const MsgAllocationTransfer: MessageFns<MsgAllocationTransfer> = {
  encode(message: MsgAllocationTransfer, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.creator !== "") {
      writer.uint32(10).string(message.creator);
    }
    if (message.allocationId !== "") {
      writer.uint32(18).string(message.allocationId);
    }
    if (message.controller !== "") {
      writer.uint32(26).string(message.controller);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MsgAllocationTransfer {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgAllocationTransfer();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.creator = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.allocationId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.controller = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MsgAllocationTransfer {
    return {
      creator: isSet(object.creator) ? globalThis.String(object.creator) : "",
      allocationId: isSet(object.allocationId) ? globalThis.String(object.allocationId) : "",
      controller: isSet(object.controller) ? globalThis.String(object.controller) : "",
    };
  },

  toJSON(message: MsgAllocationTransfer): unknown {
    const obj: any = {};
    if (message.creator !== "") {
      obj.creator = message.creator;
    }
    if (message.allocationId !== "") {
      obj.allocationId = message.allocationId;
    }
    if (message.controller !== "") {
      obj.controller = message.controller;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<MsgAllocationTransfer>, I>>(base?: I): MsgAllocationTransfer {
    return MsgAllocationTransfer.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MsgAllocationTransfer>, I>>(object: I): MsgAllocationTransfer {
    const message = createBaseMsgAllocationTransfer();
    message.creator = object.creator ?? "";
    message.allocationId = object.allocationId ?? "";
    message.controller = object.controller ?? "";
    return message;
  },
};

function createBaseMsgAllocationTransferResponse(): MsgAllocationTransferResponse {
  return { allocationId: "" };
}

export const MsgAllocationTransferResponse: MessageFns<MsgAllocationTransferResponse> = {
  encode(message: MsgAllocationTransferResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.allocationId !== "") {
      writer.uint32(10).string(message.allocationId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MsgAllocationTransferResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgAllocationTransferResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.allocationId = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MsgAllocationTransferResponse {
    return { allocationId: isSet(object.allocationId) ? globalThis.String(object.allocationId) : "" };
  },

  toJSON(message: MsgAllocationTransferResponse): unknown {
    const obj: any = {};
    if (message.allocationId !== "") {
      obj.allocationId = message.allocationId;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<MsgAllocationTransferResponse>, I>>(base?: I): MsgAllocationTransferResponse {
    return MsgAllocationTransferResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MsgAllocationTransferResponse>, I>>(
    object: I,
  ): MsgAllocationTransferResponse {
    const message = createBaseMsgAllocationTransferResponse();
    message.allocationId = object.allocationId ?? "";
    return message;
  },
};

function createBaseMsgFleetMove(): MsgFleetMove {
  return { creator: "", fleetId: "", destinationLocationId: "" };
}

export const MsgFleetMove: MessageFns<MsgFleetMove> = {
  encode(message: MsgFleetMove, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.creator !== "") {
      writer.uint32(10).string(message.creator);
    }
    if (message.fleetId !== "") {
      writer.uint32(18).string(message.fleetId);
    }
    if (message.destinationLocationId !== "") {
      writer.uint32(26).string(message.destinationLocationId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MsgFleetMove {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgFleetMove();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.creator = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.fleetId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.destinationLocationId = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MsgFleetMove {
    return {
      creator: isSet(object.creator) ? globalThis.String(object.creator) : "",
      fleetId: isSet(object.fleetId) ? globalThis.String(object.fleetId) : "",
      destinationLocationId: isSet(object.destinationLocationId) ? globalThis.String(object.destinationLocationId) : "",
    };
  },

  toJSON(message: MsgFleetMove): unknown {
    const obj: any = {};
    if (message.creator !== "") {
      obj.creator = message.creator;
    }
    if (message.fleetId !== "") {
      obj.fleetId = message.fleetId;
    }
    if (message.destinationLocationId !== "") {
      obj.destinationLocationId = message.destinationLocationId;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<MsgFleetMove>, I>>(base?: I): MsgFleetMove {
    return MsgFleetMove.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MsgFleetMove>, I>>(object: I): MsgFleetMove {
    const message = createBaseMsgFleetMove();
    message.creator = object.creator ?? "";
    message.fleetId = object.fleetId ?? "";
    message.destinationLocationId = object.destinationLocationId ?? "";
    return message;
  },
};

function createBaseMsgFleetMoveResponse(): MsgFleetMoveResponse {
  return { fleet: undefined };
}

export const MsgFleetMoveResponse: MessageFns<MsgFleetMoveResponse> = {
  encode(message: MsgFleetMoveResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.fleet !== undefined) {
      Fleet.encode(message.fleet, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MsgFleetMoveResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgFleetMoveResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.fleet = Fleet.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MsgFleetMoveResponse {
    return { fleet: isSet(object.fleet) ? Fleet.fromJSON(object.fleet) : undefined };
  },

  toJSON(message: MsgFleetMoveResponse): unknown {
    const obj: any = {};
    if (message.fleet !== undefined) {
      obj.fleet = Fleet.toJSON(message.fleet);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<MsgFleetMoveResponse>, I>>(base?: I): MsgFleetMoveResponse {
    return MsgFleetMoveResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MsgFleetMoveResponse>, I>>(object: I): MsgFleetMoveResponse {
    const message = createBaseMsgFleetMoveResponse();
    message.fleet = (object.fleet !== undefined && object.fleet !== null) ? Fleet.fromPartial(object.fleet) : undefined;
    return message;
  },
};

function createBaseMsgGuildBankMint(): MsgGuildBankMint {
  return { creator: "", amountAlpha: 0, amountToken: 0 };
}

export const MsgGuildBankMint: MessageFns<MsgGuildBankMint> = {
  encode(message: MsgGuildBankMint, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.creator !== "") {
      writer.uint32(10).string(message.creator);
    }
    if (message.amountAlpha !== 0) {
      writer.uint32(16).uint64(message.amountAlpha);
    }
    if (message.amountToken !== 0) {
      writer.uint32(24).uint64(message.amountToken);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MsgGuildBankMint {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgGuildBankMint();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.creator = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.amountAlpha = longToNumber(reader.uint64());
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.amountToken = longToNumber(reader.uint64());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MsgGuildBankMint {
    return {
      creator: isSet(object.creator) ? globalThis.String(object.creator) : "",
      amountAlpha: isSet(object.amountAlpha) ? globalThis.Number(object.amountAlpha) : 0,
      amountToken: isSet(object.amountToken) ? globalThis.Number(object.amountToken) : 0,
    };
  },

  toJSON(message: MsgGuildBankMint): unknown {
    const obj: any = {};
    if (message.creator !== "") {
      obj.creator = message.creator;
    }
    if (message.amountAlpha !== 0) {
      obj.amountAlpha = Math.round(message.amountAlpha);
    }
    if (message.amountToken !== 0) {
      obj.amountToken = Math.round(message.amountToken);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<MsgGuildBankMint>, I>>(base?: I): MsgGuildBankMint {
    return MsgGuildBankMint.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MsgGuildBankMint>, I>>(object: I): MsgGuildBankMint {
    const message = createBaseMsgGuildBankMint();
    message.creator = object.creator ?? "";
    message.amountAlpha = object.amountAlpha ?? 0;
    message.amountToken = object.amountToken ?? 0;
    return message;
  },
};

function createBaseMsgGuildBankMintResponse(): MsgGuildBankMintResponse {
  return {};
}

export const MsgGuildBankMintResponse: MessageFns<MsgGuildBankMintResponse> = {
  encode(_: MsgGuildBankMintResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MsgGuildBankMintResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgGuildBankMintResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): MsgGuildBankMintResponse {
    return {};
  },

  toJSON(_: MsgGuildBankMintResponse): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<MsgGuildBankMintResponse>, I>>(base?: I): MsgGuildBankMintResponse {
    return MsgGuildBankMintResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MsgGuildBankMintResponse>, I>>(_: I): MsgGuildBankMintResponse {
    const message = createBaseMsgGuildBankMintResponse();
    return message;
  },
};

function createBaseMsgGuildBankRedeem(): MsgGuildBankRedeem {
  return { creator: "", amountToken: undefined };
}

export const MsgGuildBankRedeem: MessageFns<MsgGuildBankRedeem> = {
  encode(message: MsgGuildBankRedeem, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.creator !== "") {
      writer.uint32(10).string(message.creator);
    }
    if (message.amountToken !== undefined) {
      Coin.encode(message.amountToken, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MsgGuildBankRedeem {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgGuildBankRedeem();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.creator = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.amountToken = Coin.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MsgGuildBankRedeem {
    return {
      creator: isSet(object.creator) ? globalThis.String(object.creator) : "",
      amountToken: isSet(object.amountToken) ? Coin.fromJSON(object.amountToken) : undefined,
    };
  },

  toJSON(message: MsgGuildBankRedeem): unknown {
    const obj: any = {};
    if (message.creator !== "") {
      obj.creator = message.creator;
    }
    if (message.amountToken !== undefined) {
      obj.amountToken = Coin.toJSON(message.amountToken);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<MsgGuildBankRedeem>, I>>(base?: I): MsgGuildBankRedeem {
    return MsgGuildBankRedeem.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MsgGuildBankRedeem>, I>>(object: I): MsgGuildBankRedeem {
    const message = createBaseMsgGuildBankRedeem();
    message.creator = object.creator ?? "";
    message.amountToken = (object.amountToken !== undefined && object.amountToken !== null)
      ? Coin.fromPartial(object.amountToken)
      : undefined;
    return message;
  },
};

function createBaseMsgGuildBankRedeemResponse(): MsgGuildBankRedeemResponse {
  return {};
}

export const MsgGuildBankRedeemResponse: MessageFns<MsgGuildBankRedeemResponse> = {
  encode(_: MsgGuildBankRedeemResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MsgGuildBankRedeemResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgGuildBankRedeemResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): MsgGuildBankRedeemResponse {
    return {};
  },

  toJSON(_: MsgGuildBankRedeemResponse): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<MsgGuildBankRedeemResponse>, I>>(base?: I): MsgGuildBankRedeemResponse {
    return MsgGuildBankRedeemResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MsgGuildBankRedeemResponse>, I>>(_: I): MsgGuildBankRedeemResponse {
    const message = createBaseMsgGuildBankRedeemResponse();
    return message;
  },
};

function createBaseMsgGuildBankConfiscateAndBurn(): MsgGuildBankConfiscateAndBurn {
  return { creator: "", address: "", amountToken: 0 };
}

export const MsgGuildBankConfiscateAndBurn: MessageFns<MsgGuildBankConfiscateAndBurn> = {
  encode(message: MsgGuildBankConfiscateAndBurn, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.creator !== "") {
      writer.uint32(10).string(message.creator);
    }
    if (message.address !== "") {
      writer.uint32(18).string(message.address);
    }
    if (message.amountToken !== 0) {
      writer.uint32(24).uint64(message.amountToken);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MsgGuildBankConfiscateAndBurn {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgGuildBankConfiscateAndBurn();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.creator = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.address = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.amountToken = longToNumber(reader.uint64());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MsgGuildBankConfiscateAndBurn {
    return {
      creator: isSet(object.creator) ? globalThis.String(object.creator) : "",
      address: isSet(object.address) ? globalThis.String(object.address) : "",
      amountToken: isSet(object.amountToken) ? globalThis.Number(object.amountToken) : 0,
    };
  },

  toJSON(message: MsgGuildBankConfiscateAndBurn): unknown {
    const obj: any = {};
    if (message.creator !== "") {
      obj.creator = message.creator;
    }
    if (message.address !== "") {
      obj.address = message.address;
    }
    if (message.amountToken !== 0) {
      obj.amountToken = Math.round(message.amountToken);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<MsgGuildBankConfiscateAndBurn>, I>>(base?: I): MsgGuildBankConfiscateAndBurn {
    return MsgGuildBankConfiscateAndBurn.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MsgGuildBankConfiscateAndBurn>, I>>(
    object: I,
  ): MsgGuildBankConfiscateAndBurn {
    const message = createBaseMsgGuildBankConfiscateAndBurn();
    message.creator = object.creator ?? "";
    message.address = object.address ?? "";
    message.amountToken = object.amountToken ?? 0;
    return message;
  },
};

function createBaseMsgGuildBankConfiscateAndBurnResponse(): MsgGuildBankConfiscateAndBurnResponse {
  return {};
}

export const MsgGuildBankConfiscateAndBurnResponse: MessageFns<MsgGuildBankConfiscateAndBurnResponse> = {
  encode(_: MsgGuildBankConfiscateAndBurnResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MsgGuildBankConfiscateAndBurnResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgGuildBankConfiscateAndBurnResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): MsgGuildBankConfiscateAndBurnResponse {
    return {};
  },

  toJSON(_: MsgGuildBankConfiscateAndBurnResponse): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<MsgGuildBankConfiscateAndBurnResponse>, I>>(
    base?: I,
  ): MsgGuildBankConfiscateAndBurnResponse {
    return MsgGuildBankConfiscateAndBurnResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MsgGuildBankConfiscateAndBurnResponse>, I>>(
    _: I,
  ): MsgGuildBankConfiscateAndBurnResponse {
    const message = createBaseMsgGuildBankConfiscateAndBurnResponse();
    return message;
  },
};

function createBaseMsgGuildCreate(): MsgGuildCreate {
  return { creator: "", endpoint: "", entrySubstationId: "" };
}

export const MsgGuildCreate: MessageFns<MsgGuildCreate> = {
  encode(message: MsgGuildCreate, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.creator !== "") {
      writer.uint32(10).string(message.creator);
    }
    if (message.endpoint !== "") {
      writer.uint32(18).string(message.endpoint);
    }
    if (message.entrySubstationId !== "") {
      writer.uint32(26).string(message.entrySubstationId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MsgGuildCreate {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgGuildCreate();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.creator = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.endpoint = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.entrySubstationId = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MsgGuildCreate {
    return {
      creator: isSet(object.creator) ? globalThis.String(object.creator) : "",
      endpoint: isSet(object.endpoint) ? globalThis.String(object.endpoint) : "",
      entrySubstationId: isSet(object.entrySubstationId) ? globalThis.String(object.entrySubstationId) : "",
    };
  },

  toJSON(message: MsgGuildCreate): unknown {
    const obj: any = {};
    if (message.creator !== "") {
      obj.creator = message.creator;
    }
    if (message.endpoint !== "") {
      obj.endpoint = message.endpoint;
    }
    if (message.entrySubstationId !== "") {
      obj.entrySubstationId = message.entrySubstationId;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<MsgGuildCreate>, I>>(base?: I): MsgGuildCreate {
    return MsgGuildCreate.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MsgGuildCreate>, I>>(object: I): MsgGuildCreate {
    const message = createBaseMsgGuildCreate();
    message.creator = object.creator ?? "";
    message.endpoint = object.endpoint ?? "";
    message.entrySubstationId = object.entrySubstationId ?? "";
    return message;
  },
};

function createBaseMsgGuildCreateResponse(): MsgGuildCreateResponse {
  return { guildId: "" };
}

export const MsgGuildCreateResponse: MessageFns<MsgGuildCreateResponse> = {
  encode(message: MsgGuildCreateResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.guildId !== "") {
      writer.uint32(10).string(message.guildId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MsgGuildCreateResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgGuildCreateResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.guildId = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MsgGuildCreateResponse {
    return { guildId: isSet(object.guildId) ? globalThis.String(object.guildId) : "" };
  },

  toJSON(message: MsgGuildCreateResponse): unknown {
    const obj: any = {};
    if (message.guildId !== "") {
      obj.guildId = message.guildId;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<MsgGuildCreateResponse>, I>>(base?: I): MsgGuildCreateResponse {
    return MsgGuildCreateResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MsgGuildCreateResponse>, I>>(object: I): MsgGuildCreateResponse {
    const message = createBaseMsgGuildCreateResponse();
    message.guildId = object.guildId ?? "";
    return message;
  },
};

function createBaseMsgGuildUpdateOwnerId(): MsgGuildUpdateOwnerId {
  return { creator: "", guildId: "", owner: "" };
}

export const MsgGuildUpdateOwnerId: MessageFns<MsgGuildUpdateOwnerId> = {
  encode(message: MsgGuildUpdateOwnerId, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.creator !== "") {
      writer.uint32(10).string(message.creator);
    }
    if (message.guildId !== "") {
      writer.uint32(18).string(message.guildId);
    }
    if (message.owner !== "") {
      writer.uint32(26).string(message.owner);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MsgGuildUpdateOwnerId {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgGuildUpdateOwnerId();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.creator = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.guildId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.owner = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MsgGuildUpdateOwnerId {
    return {
      creator: isSet(object.creator) ? globalThis.String(object.creator) : "",
      guildId: isSet(object.guildId) ? globalThis.String(object.guildId) : "",
      owner: isSet(object.owner) ? globalThis.String(object.owner) : "",
    };
  },

  toJSON(message: MsgGuildUpdateOwnerId): unknown {
    const obj: any = {};
    if (message.creator !== "") {
      obj.creator = message.creator;
    }
    if (message.guildId !== "") {
      obj.guildId = message.guildId;
    }
    if (message.owner !== "") {
      obj.owner = message.owner;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<MsgGuildUpdateOwnerId>, I>>(base?: I): MsgGuildUpdateOwnerId {
    return MsgGuildUpdateOwnerId.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MsgGuildUpdateOwnerId>, I>>(object: I): MsgGuildUpdateOwnerId {
    const message = createBaseMsgGuildUpdateOwnerId();
    message.creator = object.creator ?? "";
    message.guildId = object.guildId ?? "";
    message.owner = object.owner ?? "";
    return message;
  },
};

function createBaseMsgGuildUpdateEntrySubstationId(): MsgGuildUpdateEntrySubstationId {
  return { creator: "", guildId: "", entrySubstationId: "" };
}

export const MsgGuildUpdateEntrySubstationId: MessageFns<MsgGuildUpdateEntrySubstationId> = {
  encode(message: MsgGuildUpdateEntrySubstationId, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.creator !== "") {
      writer.uint32(10).string(message.creator);
    }
    if (message.guildId !== "") {
      writer.uint32(18).string(message.guildId);
    }
    if (message.entrySubstationId !== "") {
      writer.uint32(26).string(message.entrySubstationId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MsgGuildUpdateEntrySubstationId {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgGuildUpdateEntrySubstationId();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.creator = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.guildId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.entrySubstationId = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MsgGuildUpdateEntrySubstationId {
    return {
      creator: isSet(object.creator) ? globalThis.String(object.creator) : "",
      guildId: isSet(object.guildId) ? globalThis.String(object.guildId) : "",
      entrySubstationId: isSet(object.entrySubstationId) ? globalThis.String(object.entrySubstationId) : "",
    };
  },

  toJSON(message: MsgGuildUpdateEntrySubstationId): unknown {
    const obj: any = {};
    if (message.creator !== "") {
      obj.creator = message.creator;
    }
    if (message.guildId !== "") {
      obj.guildId = message.guildId;
    }
    if (message.entrySubstationId !== "") {
      obj.entrySubstationId = message.entrySubstationId;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<MsgGuildUpdateEntrySubstationId>, I>>(base?: I): MsgGuildUpdateEntrySubstationId {
    return MsgGuildUpdateEntrySubstationId.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MsgGuildUpdateEntrySubstationId>, I>>(
    object: I,
  ): MsgGuildUpdateEntrySubstationId {
    const message = createBaseMsgGuildUpdateEntrySubstationId();
    message.creator = object.creator ?? "";
    message.guildId = object.guildId ?? "";
    message.entrySubstationId = object.entrySubstationId ?? "";
    return message;
  },
};

function createBaseMsgGuildUpdateEndpoint(): MsgGuildUpdateEndpoint {
  return { creator: "", guildId: "", endpoint: "" };
}

export const MsgGuildUpdateEndpoint: MessageFns<MsgGuildUpdateEndpoint> = {
  encode(message: MsgGuildUpdateEndpoint, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.creator !== "") {
      writer.uint32(10).string(message.creator);
    }
    if (message.guildId !== "") {
      writer.uint32(18).string(message.guildId);
    }
    if (message.endpoint !== "") {
      writer.uint32(26).string(message.endpoint);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MsgGuildUpdateEndpoint {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgGuildUpdateEndpoint();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.creator = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.guildId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.endpoint = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MsgGuildUpdateEndpoint {
    return {
      creator: isSet(object.creator) ? globalThis.String(object.creator) : "",
      guildId: isSet(object.guildId) ? globalThis.String(object.guildId) : "",
      endpoint: isSet(object.endpoint) ? globalThis.String(object.endpoint) : "",
    };
  },

  toJSON(message: MsgGuildUpdateEndpoint): unknown {
    const obj: any = {};
    if (message.creator !== "") {
      obj.creator = message.creator;
    }
    if (message.guildId !== "") {
      obj.guildId = message.guildId;
    }
    if (message.endpoint !== "") {
      obj.endpoint = message.endpoint;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<MsgGuildUpdateEndpoint>, I>>(base?: I): MsgGuildUpdateEndpoint {
    return MsgGuildUpdateEndpoint.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MsgGuildUpdateEndpoint>, I>>(object: I): MsgGuildUpdateEndpoint {
    const message = createBaseMsgGuildUpdateEndpoint();
    message.creator = object.creator ?? "";
    message.guildId = object.guildId ?? "";
    message.endpoint = object.endpoint ?? "";
    return message;
  },
};

function createBaseMsgGuildUpdateJoinInfusionMinimum(): MsgGuildUpdateJoinInfusionMinimum {
  return { creator: "", guildId: "", joinInfusionMinimum: 0 };
}

export const MsgGuildUpdateJoinInfusionMinimum: MessageFns<MsgGuildUpdateJoinInfusionMinimum> = {
  encode(message: MsgGuildUpdateJoinInfusionMinimum, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.creator !== "") {
      writer.uint32(10).string(message.creator);
    }
    if (message.guildId !== "") {
      writer.uint32(18).string(message.guildId);
    }
    if (message.joinInfusionMinimum !== 0) {
      writer.uint32(24).uint64(message.joinInfusionMinimum);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MsgGuildUpdateJoinInfusionMinimum {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgGuildUpdateJoinInfusionMinimum();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.creator = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.guildId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.joinInfusionMinimum = longToNumber(reader.uint64());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MsgGuildUpdateJoinInfusionMinimum {
    return {
      creator: isSet(object.creator) ? globalThis.String(object.creator) : "",
      guildId: isSet(object.guildId) ? globalThis.String(object.guildId) : "",
      joinInfusionMinimum: isSet(object.joinInfusionMinimum) ? globalThis.Number(object.joinInfusionMinimum) : 0,
    };
  },

  toJSON(message: MsgGuildUpdateJoinInfusionMinimum): unknown {
    const obj: any = {};
    if (message.creator !== "") {
      obj.creator = message.creator;
    }
    if (message.guildId !== "") {
      obj.guildId = message.guildId;
    }
    if (message.joinInfusionMinimum !== 0) {
      obj.joinInfusionMinimum = Math.round(message.joinInfusionMinimum);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<MsgGuildUpdateJoinInfusionMinimum>, I>>(
    base?: I,
  ): MsgGuildUpdateJoinInfusionMinimum {
    return MsgGuildUpdateJoinInfusionMinimum.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MsgGuildUpdateJoinInfusionMinimum>, I>>(
    object: I,
  ): MsgGuildUpdateJoinInfusionMinimum {
    const message = createBaseMsgGuildUpdateJoinInfusionMinimum();
    message.creator = object.creator ?? "";
    message.guildId = object.guildId ?? "";
    message.joinInfusionMinimum = object.joinInfusionMinimum ?? 0;
    return message;
  },
};

function createBaseMsgGuildUpdateJoinInfusionMinimumBypassByRequest(): MsgGuildUpdateJoinInfusionMinimumBypassByRequest {
  return { creator: "", guildId: "", guildJoinBypassLevel: 0 };
}

export const MsgGuildUpdateJoinInfusionMinimumBypassByRequest: MessageFns<
  MsgGuildUpdateJoinInfusionMinimumBypassByRequest
> = {
  encode(
    message: MsgGuildUpdateJoinInfusionMinimumBypassByRequest,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.creator !== "") {
      writer.uint32(10).string(message.creator);
    }
    if (message.guildId !== "") {
      writer.uint32(18).string(message.guildId);
    }
    if (message.guildJoinBypassLevel !== 0) {
      writer.uint32(24).int32(message.guildJoinBypassLevel);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MsgGuildUpdateJoinInfusionMinimumBypassByRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgGuildUpdateJoinInfusionMinimumBypassByRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.creator = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.guildId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.guildJoinBypassLevel = reader.int32() as any;
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MsgGuildUpdateJoinInfusionMinimumBypassByRequest {
    return {
      creator: isSet(object.creator) ? globalThis.String(object.creator) : "",
      guildId: isSet(object.guildId) ? globalThis.String(object.guildId) : "",
      guildJoinBypassLevel: isSet(object.guildJoinBypassLevel)
        ? guildJoinBypassLevelFromJSON(object.guildJoinBypassLevel)
        : 0,
    };
  },

  toJSON(message: MsgGuildUpdateJoinInfusionMinimumBypassByRequest): unknown {
    const obj: any = {};
    if (message.creator !== "") {
      obj.creator = message.creator;
    }
    if (message.guildId !== "") {
      obj.guildId = message.guildId;
    }
    if (message.guildJoinBypassLevel !== 0) {
      obj.guildJoinBypassLevel = guildJoinBypassLevelToJSON(message.guildJoinBypassLevel);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<MsgGuildUpdateJoinInfusionMinimumBypassByRequest>, I>>(
    base?: I,
  ): MsgGuildUpdateJoinInfusionMinimumBypassByRequest {
    return MsgGuildUpdateJoinInfusionMinimumBypassByRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MsgGuildUpdateJoinInfusionMinimumBypassByRequest>, I>>(
    object: I,
  ): MsgGuildUpdateJoinInfusionMinimumBypassByRequest {
    const message = createBaseMsgGuildUpdateJoinInfusionMinimumBypassByRequest();
    message.creator = object.creator ?? "";
    message.guildId = object.guildId ?? "";
    message.guildJoinBypassLevel = object.guildJoinBypassLevel ?? 0;
    return message;
  },
};

function createBaseMsgGuildUpdateJoinInfusionMinimumBypassByInvite(): MsgGuildUpdateJoinInfusionMinimumBypassByInvite {
  return { creator: "", guildId: "", guildJoinBypassLevel: 0 };
}

export const MsgGuildUpdateJoinInfusionMinimumBypassByInvite: MessageFns<
  MsgGuildUpdateJoinInfusionMinimumBypassByInvite
> = {
  encode(
    message: MsgGuildUpdateJoinInfusionMinimumBypassByInvite,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.creator !== "") {
      writer.uint32(10).string(message.creator);
    }
    if (message.guildId !== "") {
      writer.uint32(18).string(message.guildId);
    }
    if (message.guildJoinBypassLevel !== 0) {
      writer.uint32(24).int32(message.guildJoinBypassLevel);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MsgGuildUpdateJoinInfusionMinimumBypassByInvite {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgGuildUpdateJoinInfusionMinimumBypassByInvite();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.creator = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.guildId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.guildJoinBypassLevel = reader.int32() as any;
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MsgGuildUpdateJoinInfusionMinimumBypassByInvite {
    return {
      creator: isSet(object.creator) ? globalThis.String(object.creator) : "",
      guildId: isSet(object.guildId) ? globalThis.String(object.guildId) : "",
      guildJoinBypassLevel: isSet(object.guildJoinBypassLevel)
        ? guildJoinBypassLevelFromJSON(object.guildJoinBypassLevel)
        : 0,
    };
  },

  toJSON(message: MsgGuildUpdateJoinInfusionMinimumBypassByInvite): unknown {
    const obj: any = {};
    if (message.creator !== "") {
      obj.creator = message.creator;
    }
    if (message.guildId !== "") {
      obj.guildId = message.guildId;
    }
    if (message.guildJoinBypassLevel !== 0) {
      obj.guildJoinBypassLevel = guildJoinBypassLevelToJSON(message.guildJoinBypassLevel);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<MsgGuildUpdateJoinInfusionMinimumBypassByInvite>, I>>(
    base?: I,
  ): MsgGuildUpdateJoinInfusionMinimumBypassByInvite {
    return MsgGuildUpdateJoinInfusionMinimumBypassByInvite.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MsgGuildUpdateJoinInfusionMinimumBypassByInvite>, I>>(
    object: I,
  ): MsgGuildUpdateJoinInfusionMinimumBypassByInvite {
    const message = createBaseMsgGuildUpdateJoinInfusionMinimumBypassByInvite();
    message.creator = object.creator ?? "";
    message.guildId = object.guildId ?? "";
    message.guildJoinBypassLevel = object.guildJoinBypassLevel ?? 0;
    return message;
  },
};

function createBaseMsgGuildUpdateResponse(): MsgGuildUpdateResponse {
  return {};
}

export const MsgGuildUpdateResponse: MessageFns<MsgGuildUpdateResponse> = {
  encode(_: MsgGuildUpdateResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MsgGuildUpdateResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgGuildUpdateResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): MsgGuildUpdateResponse {
    return {};
  },

  toJSON(_: MsgGuildUpdateResponse): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<MsgGuildUpdateResponse>, I>>(base?: I): MsgGuildUpdateResponse {
    return MsgGuildUpdateResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MsgGuildUpdateResponse>, I>>(_: I): MsgGuildUpdateResponse {
    const message = createBaseMsgGuildUpdateResponse();
    return message;
  },
};

function createBaseMsgGuildMembershipInvite(): MsgGuildMembershipInvite {
  return { creator: "", guildId: "", playerId: "", substationId: "" };
}

export const MsgGuildMembershipInvite: MessageFns<MsgGuildMembershipInvite> = {
  encode(message: MsgGuildMembershipInvite, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.creator !== "") {
      writer.uint32(10).string(message.creator);
    }
    if (message.guildId !== "") {
      writer.uint32(18).string(message.guildId);
    }
    if (message.playerId !== "") {
      writer.uint32(26).string(message.playerId);
    }
    if (message.substationId !== "") {
      writer.uint32(34).string(message.substationId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MsgGuildMembershipInvite {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgGuildMembershipInvite();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.creator = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.guildId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.playerId = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.substationId = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MsgGuildMembershipInvite {
    return {
      creator: isSet(object.creator) ? globalThis.String(object.creator) : "",
      guildId: isSet(object.guildId) ? globalThis.String(object.guildId) : "",
      playerId: isSet(object.playerId) ? globalThis.String(object.playerId) : "",
      substationId: isSet(object.substationId) ? globalThis.String(object.substationId) : "",
    };
  },

  toJSON(message: MsgGuildMembershipInvite): unknown {
    const obj: any = {};
    if (message.creator !== "") {
      obj.creator = message.creator;
    }
    if (message.guildId !== "") {
      obj.guildId = message.guildId;
    }
    if (message.playerId !== "") {
      obj.playerId = message.playerId;
    }
    if (message.substationId !== "") {
      obj.substationId = message.substationId;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<MsgGuildMembershipInvite>, I>>(base?: I): MsgGuildMembershipInvite {
    return MsgGuildMembershipInvite.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MsgGuildMembershipInvite>, I>>(object: I): MsgGuildMembershipInvite {
    const message = createBaseMsgGuildMembershipInvite();
    message.creator = object.creator ?? "";
    message.guildId = object.guildId ?? "";
    message.playerId = object.playerId ?? "";
    message.substationId = object.substationId ?? "";
    return message;
  },
};

function createBaseMsgGuildMembershipInviteApprove(): MsgGuildMembershipInviteApprove {
  return { creator: "", guildId: "", playerId: "", substationId: "" };
}

export const MsgGuildMembershipInviteApprove: MessageFns<MsgGuildMembershipInviteApprove> = {
  encode(message: MsgGuildMembershipInviteApprove, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.creator !== "") {
      writer.uint32(10).string(message.creator);
    }
    if (message.guildId !== "") {
      writer.uint32(18).string(message.guildId);
    }
    if (message.playerId !== "") {
      writer.uint32(26).string(message.playerId);
    }
    if (message.substationId !== "") {
      writer.uint32(34).string(message.substationId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MsgGuildMembershipInviteApprove {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgGuildMembershipInviteApprove();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.creator = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.guildId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.playerId = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.substationId = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MsgGuildMembershipInviteApprove {
    return {
      creator: isSet(object.creator) ? globalThis.String(object.creator) : "",
      guildId: isSet(object.guildId) ? globalThis.String(object.guildId) : "",
      playerId: isSet(object.playerId) ? globalThis.String(object.playerId) : "",
      substationId: isSet(object.substationId) ? globalThis.String(object.substationId) : "",
    };
  },

  toJSON(message: MsgGuildMembershipInviteApprove): unknown {
    const obj: any = {};
    if (message.creator !== "") {
      obj.creator = message.creator;
    }
    if (message.guildId !== "") {
      obj.guildId = message.guildId;
    }
    if (message.playerId !== "") {
      obj.playerId = message.playerId;
    }
    if (message.substationId !== "") {
      obj.substationId = message.substationId;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<MsgGuildMembershipInviteApprove>, I>>(base?: I): MsgGuildMembershipInviteApprove {
    return MsgGuildMembershipInviteApprove.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MsgGuildMembershipInviteApprove>, I>>(
    object: I,
  ): MsgGuildMembershipInviteApprove {
    const message = createBaseMsgGuildMembershipInviteApprove();
    message.creator = object.creator ?? "";
    message.guildId = object.guildId ?? "";
    message.playerId = object.playerId ?? "";
    message.substationId = object.substationId ?? "";
    return message;
  },
};

function createBaseMsgGuildMembershipInviteDeny(): MsgGuildMembershipInviteDeny {
  return { creator: "", guildId: "", playerId: "" };
}

export const MsgGuildMembershipInviteDeny: MessageFns<MsgGuildMembershipInviteDeny> = {
  encode(message: MsgGuildMembershipInviteDeny, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.creator !== "") {
      writer.uint32(10).string(message.creator);
    }
    if (message.guildId !== "") {
      writer.uint32(18).string(message.guildId);
    }
    if (message.playerId !== "") {
      writer.uint32(26).string(message.playerId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MsgGuildMembershipInviteDeny {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgGuildMembershipInviteDeny();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.creator = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.guildId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.playerId = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MsgGuildMembershipInviteDeny {
    return {
      creator: isSet(object.creator) ? globalThis.String(object.creator) : "",
      guildId: isSet(object.guildId) ? globalThis.String(object.guildId) : "",
      playerId: isSet(object.playerId) ? globalThis.String(object.playerId) : "",
    };
  },

  toJSON(message: MsgGuildMembershipInviteDeny): unknown {
    const obj: any = {};
    if (message.creator !== "") {
      obj.creator = message.creator;
    }
    if (message.guildId !== "") {
      obj.guildId = message.guildId;
    }
    if (message.playerId !== "") {
      obj.playerId = message.playerId;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<MsgGuildMembershipInviteDeny>, I>>(base?: I): MsgGuildMembershipInviteDeny {
    return MsgGuildMembershipInviteDeny.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MsgGuildMembershipInviteDeny>, I>>(object: I): MsgGuildMembershipInviteDeny {
    const message = createBaseMsgGuildMembershipInviteDeny();
    message.creator = object.creator ?? "";
    message.guildId = object.guildId ?? "";
    message.playerId = object.playerId ?? "";
    return message;
  },
};

function createBaseMsgGuildMembershipInviteRevoke(): MsgGuildMembershipInviteRevoke {
  return { creator: "", guildId: "", playerId: "" };
}

export const MsgGuildMembershipInviteRevoke: MessageFns<MsgGuildMembershipInviteRevoke> = {
  encode(message: MsgGuildMembershipInviteRevoke, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.creator !== "") {
      writer.uint32(10).string(message.creator);
    }
    if (message.guildId !== "") {
      writer.uint32(18).string(message.guildId);
    }
    if (message.playerId !== "") {
      writer.uint32(26).string(message.playerId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MsgGuildMembershipInviteRevoke {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgGuildMembershipInviteRevoke();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.creator = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.guildId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.playerId = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MsgGuildMembershipInviteRevoke {
    return {
      creator: isSet(object.creator) ? globalThis.String(object.creator) : "",
      guildId: isSet(object.guildId) ? globalThis.String(object.guildId) : "",
      playerId: isSet(object.playerId) ? globalThis.String(object.playerId) : "",
    };
  },

  toJSON(message: MsgGuildMembershipInviteRevoke): unknown {
    const obj: any = {};
    if (message.creator !== "") {
      obj.creator = message.creator;
    }
    if (message.guildId !== "") {
      obj.guildId = message.guildId;
    }
    if (message.playerId !== "") {
      obj.playerId = message.playerId;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<MsgGuildMembershipInviteRevoke>, I>>(base?: I): MsgGuildMembershipInviteRevoke {
    return MsgGuildMembershipInviteRevoke.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MsgGuildMembershipInviteRevoke>, I>>(
    object: I,
  ): MsgGuildMembershipInviteRevoke {
    const message = createBaseMsgGuildMembershipInviteRevoke();
    message.creator = object.creator ?? "";
    message.guildId = object.guildId ?? "";
    message.playerId = object.playerId ?? "";
    return message;
  },
};

function createBaseMsgGuildMembershipJoin(): MsgGuildMembershipJoin {
  return { creator: "", guildId: "", playerId: "", substationId: "", infusionId: [] };
}

export const MsgGuildMembershipJoin: MessageFns<MsgGuildMembershipJoin> = {
  encode(message: MsgGuildMembershipJoin, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.creator !== "") {
      writer.uint32(10).string(message.creator);
    }
    if (message.guildId !== "") {
      writer.uint32(18).string(message.guildId);
    }
    if (message.playerId !== "") {
      writer.uint32(26).string(message.playerId);
    }
    if (message.substationId !== "") {
      writer.uint32(34).string(message.substationId);
    }
    for (const v of message.infusionId) {
      writer.uint32(42).string(v!);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MsgGuildMembershipJoin {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgGuildMembershipJoin();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.creator = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.guildId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.playerId = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.substationId = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.infusionId.push(reader.string());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MsgGuildMembershipJoin {
    return {
      creator: isSet(object.creator) ? globalThis.String(object.creator) : "",
      guildId: isSet(object.guildId) ? globalThis.String(object.guildId) : "",
      playerId: isSet(object.playerId) ? globalThis.String(object.playerId) : "",
      substationId: isSet(object.substationId) ? globalThis.String(object.substationId) : "",
      infusionId: globalThis.Array.isArray(object?.infusionId)
        ? object.infusionId.map((e: any) => globalThis.String(e))
        : [],
    };
  },

  toJSON(message: MsgGuildMembershipJoin): unknown {
    const obj: any = {};
    if (message.creator !== "") {
      obj.creator = message.creator;
    }
    if (message.guildId !== "") {
      obj.guildId = message.guildId;
    }
    if (message.playerId !== "") {
      obj.playerId = message.playerId;
    }
    if (message.substationId !== "") {
      obj.substationId = message.substationId;
    }
    if (message.infusionId?.length) {
      obj.infusionId = message.infusionId;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<MsgGuildMembershipJoin>, I>>(base?: I): MsgGuildMembershipJoin {
    return MsgGuildMembershipJoin.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MsgGuildMembershipJoin>, I>>(object: I): MsgGuildMembershipJoin {
    const message = createBaseMsgGuildMembershipJoin();
    message.creator = object.creator ?? "";
    message.guildId = object.guildId ?? "";
    message.playerId = object.playerId ?? "";
    message.substationId = object.substationId ?? "";
    message.infusionId = object.infusionId?.map((e) => e) || [];
    return message;
  },
};

function createBaseMsgGuildMembershipJoinProxy(): MsgGuildMembershipJoinProxy {
  return { creator: "", address: "", substationId: "", proofPubKey: "", proofSignature: "" };
}

export const MsgGuildMembershipJoinProxy: MessageFns<MsgGuildMembershipJoinProxy> = {
  encode(message: MsgGuildMembershipJoinProxy, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.creator !== "") {
      writer.uint32(10).string(message.creator);
    }
    if (message.address !== "") {
      writer.uint32(18).string(message.address);
    }
    if (message.substationId !== "") {
      writer.uint32(26).string(message.substationId);
    }
    if (message.proofPubKey !== "") {
      writer.uint32(34).string(message.proofPubKey);
    }
    if (message.proofSignature !== "") {
      writer.uint32(42).string(message.proofSignature);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MsgGuildMembershipJoinProxy {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgGuildMembershipJoinProxy();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.creator = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.address = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.substationId = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.proofPubKey = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.proofSignature = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MsgGuildMembershipJoinProxy {
    return {
      creator: isSet(object.creator) ? globalThis.String(object.creator) : "",
      address: isSet(object.address) ? globalThis.String(object.address) : "",
      substationId: isSet(object.substationId) ? globalThis.String(object.substationId) : "",
      proofPubKey: isSet(object.proofPubKey) ? globalThis.String(object.proofPubKey) : "",
      proofSignature: isSet(object.proofSignature) ? globalThis.String(object.proofSignature) : "",
    };
  },

  toJSON(message: MsgGuildMembershipJoinProxy): unknown {
    const obj: any = {};
    if (message.creator !== "") {
      obj.creator = message.creator;
    }
    if (message.address !== "") {
      obj.address = message.address;
    }
    if (message.substationId !== "") {
      obj.substationId = message.substationId;
    }
    if (message.proofPubKey !== "") {
      obj.proofPubKey = message.proofPubKey;
    }
    if (message.proofSignature !== "") {
      obj.proofSignature = message.proofSignature;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<MsgGuildMembershipJoinProxy>, I>>(base?: I): MsgGuildMembershipJoinProxy {
    return MsgGuildMembershipJoinProxy.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MsgGuildMembershipJoinProxy>, I>>(object: I): MsgGuildMembershipJoinProxy {
    const message = createBaseMsgGuildMembershipJoinProxy();
    message.creator = object.creator ?? "";
    message.address = object.address ?? "";
    message.substationId = object.substationId ?? "";
    message.proofPubKey = object.proofPubKey ?? "";
    message.proofSignature = object.proofSignature ?? "";
    return message;
  },
};

function createBaseMsgGuildMembershipKick(): MsgGuildMembershipKick {
  return { creator: "", guildId: "", playerId: "" };
}

export const MsgGuildMembershipKick: MessageFns<MsgGuildMembershipKick> = {
  encode(message: MsgGuildMembershipKick, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.creator !== "") {
      writer.uint32(10).string(message.creator);
    }
    if (message.guildId !== "") {
      writer.uint32(18).string(message.guildId);
    }
    if (message.playerId !== "") {
      writer.uint32(26).string(message.playerId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MsgGuildMembershipKick {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgGuildMembershipKick();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.creator = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.guildId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.playerId = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MsgGuildMembershipKick {
    return {
      creator: isSet(object.creator) ? globalThis.String(object.creator) : "",
      guildId: isSet(object.guildId) ? globalThis.String(object.guildId) : "",
      playerId: isSet(object.playerId) ? globalThis.String(object.playerId) : "",
    };
  },

  toJSON(message: MsgGuildMembershipKick): unknown {
    const obj: any = {};
    if (message.creator !== "") {
      obj.creator = message.creator;
    }
    if (message.guildId !== "") {
      obj.guildId = message.guildId;
    }
    if (message.playerId !== "") {
      obj.playerId = message.playerId;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<MsgGuildMembershipKick>, I>>(base?: I): MsgGuildMembershipKick {
    return MsgGuildMembershipKick.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MsgGuildMembershipKick>, I>>(object: I): MsgGuildMembershipKick {
    const message = createBaseMsgGuildMembershipKick();
    message.creator = object.creator ?? "";
    message.guildId = object.guildId ?? "";
    message.playerId = object.playerId ?? "";
    return message;
  },
};

function createBaseMsgGuildMembershipRequest(): MsgGuildMembershipRequest {
  return { creator: "", guildId: "", playerId: "", substationId: "" };
}

export const MsgGuildMembershipRequest: MessageFns<MsgGuildMembershipRequest> = {
  encode(message: MsgGuildMembershipRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.creator !== "") {
      writer.uint32(10).string(message.creator);
    }
    if (message.guildId !== "") {
      writer.uint32(18).string(message.guildId);
    }
    if (message.playerId !== "") {
      writer.uint32(26).string(message.playerId);
    }
    if (message.substationId !== "") {
      writer.uint32(34).string(message.substationId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MsgGuildMembershipRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgGuildMembershipRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.creator = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.guildId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.playerId = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.substationId = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MsgGuildMembershipRequest {
    return {
      creator: isSet(object.creator) ? globalThis.String(object.creator) : "",
      guildId: isSet(object.guildId) ? globalThis.String(object.guildId) : "",
      playerId: isSet(object.playerId) ? globalThis.String(object.playerId) : "",
      substationId: isSet(object.substationId) ? globalThis.String(object.substationId) : "",
    };
  },

  toJSON(message: MsgGuildMembershipRequest): unknown {
    const obj: any = {};
    if (message.creator !== "") {
      obj.creator = message.creator;
    }
    if (message.guildId !== "") {
      obj.guildId = message.guildId;
    }
    if (message.playerId !== "") {
      obj.playerId = message.playerId;
    }
    if (message.substationId !== "") {
      obj.substationId = message.substationId;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<MsgGuildMembershipRequest>, I>>(base?: I): MsgGuildMembershipRequest {
    return MsgGuildMembershipRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MsgGuildMembershipRequest>, I>>(object: I): MsgGuildMembershipRequest {
    const message = createBaseMsgGuildMembershipRequest();
    message.creator = object.creator ?? "";
    message.guildId = object.guildId ?? "";
    message.playerId = object.playerId ?? "";
    message.substationId = object.substationId ?? "";
    return message;
  },
};

function createBaseMsgGuildMembershipRequestApprove(): MsgGuildMembershipRequestApprove {
  return { creator: "", guildId: "", playerId: "", substationId: "" };
}

export const MsgGuildMembershipRequestApprove: MessageFns<MsgGuildMembershipRequestApprove> = {
  encode(message: MsgGuildMembershipRequestApprove, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.creator !== "") {
      writer.uint32(10).string(message.creator);
    }
    if (message.guildId !== "") {
      writer.uint32(18).string(message.guildId);
    }
    if (message.playerId !== "") {
      writer.uint32(26).string(message.playerId);
    }
    if (message.substationId !== "") {
      writer.uint32(34).string(message.substationId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MsgGuildMembershipRequestApprove {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgGuildMembershipRequestApprove();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.creator = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.guildId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.playerId = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.substationId = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MsgGuildMembershipRequestApprove {
    return {
      creator: isSet(object.creator) ? globalThis.String(object.creator) : "",
      guildId: isSet(object.guildId) ? globalThis.String(object.guildId) : "",
      playerId: isSet(object.playerId) ? globalThis.String(object.playerId) : "",
      substationId: isSet(object.substationId) ? globalThis.String(object.substationId) : "",
    };
  },

  toJSON(message: MsgGuildMembershipRequestApprove): unknown {
    const obj: any = {};
    if (message.creator !== "") {
      obj.creator = message.creator;
    }
    if (message.guildId !== "") {
      obj.guildId = message.guildId;
    }
    if (message.playerId !== "") {
      obj.playerId = message.playerId;
    }
    if (message.substationId !== "") {
      obj.substationId = message.substationId;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<MsgGuildMembershipRequestApprove>, I>>(
    base?: I,
  ): MsgGuildMembershipRequestApprove {
    return MsgGuildMembershipRequestApprove.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MsgGuildMembershipRequestApprove>, I>>(
    object: I,
  ): MsgGuildMembershipRequestApprove {
    const message = createBaseMsgGuildMembershipRequestApprove();
    message.creator = object.creator ?? "";
    message.guildId = object.guildId ?? "";
    message.playerId = object.playerId ?? "";
    message.substationId = object.substationId ?? "";
    return message;
  },
};

function createBaseMsgGuildMembershipRequestDeny(): MsgGuildMembershipRequestDeny {
  return { creator: "", guildId: "", playerId: "" };
}

export const MsgGuildMembershipRequestDeny: MessageFns<MsgGuildMembershipRequestDeny> = {
  encode(message: MsgGuildMembershipRequestDeny, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.creator !== "") {
      writer.uint32(10).string(message.creator);
    }
    if (message.guildId !== "") {
      writer.uint32(18).string(message.guildId);
    }
    if (message.playerId !== "") {
      writer.uint32(26).string(message.playerId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MsgGuildMembershipRequestDeny {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgGuildMembershipRequestDeny();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.creator = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.guildId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.playerId = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MsgGuildMembershipRequestDeny {
    return {
      creator: isSet(object.creator) ? globalThis.String(object.creator) : "",
      guildId: isSet(object.guildId) ? globalThis.String(object.guildId) : "",
      playerId: isSet(object.playerId) ? globalThis.String(object.playerId) : "",
    };
  },

  toJSON(message: MsgGuildMembershipRequestDeny): unknown {
    const obj: any = {};
    if (message.creator !== "") {
      obj.creator = message.creator;
    }
    if (message.guildId !== "") {
      obj.guildId = message.guildId;
    }
    if (message.playerId !== "") {
      obj.playerId = message.playerId;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<MsgGuildMembershipRequestDeny>, I>>(base?: I): MsgGuildMembershipRequestDeny {
    return MsgGuildMembershipRequestDeny.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MsgGuildMembershipRequestDeny>, I>>(
    object: I,
  ): MsgGuildMembershipRequestDeny {
    const message = createBaseMsgGuildMembershipRequestDeny();
    message.creator = object.creator ?? "";
    message.guildId = object.guildId ?? "";
    message.playerId = object.playerId ?? "";
    return message;
  },
};

function createBaseMsgGuildMembershipRequestRevoke(): MsgGuildMembershipRequestRevoke {
  return { creator: "", guildId: "", playerId: "" };
}

export const MsgGuildMembershipRequestRevoke: MessageFns<MsgGuildMembershipRequestRevoke> = {
  encode(message: MsgGuildMembershipRequestRevoke, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.creator !== "") {
      writer.uint32(10).string(message.creator);
    }
    if (message.guildId !== "") {
      writer.uint32(18).string(message.guildId);
    }
    if (message.playerId !== "") {
      writer.uint32(26).string(message.playerId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MsgGuildMembershipRequestRevoke {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgGuildMembershipRequestRevoke();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.creator = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.guildId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.playerId = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MsgGuildMembershipRequestRevoke {
    return {
      creator: isSet(object.creator) ? globalThis.String(object.creator) : "",
      guildId: isSet(object.guildId) ? globalThis.String(object.guildId) : "",
      playerId: isSet(object.playerId) ? globalThis.String(object.playerId) : "",
    };
  },

  toJSON(message: MsgGuildMembershipRequestRevoke): unknown {
    const obj: any = {};
    if (message.creator !== "") {
      obj.creator = message.creator;
    }
    if (message.guildId !== "") {
      obj.guildId = message.guildId;
    }
    if (message.playerId !== "") {
      obj.playerId = message.playerId;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<MsgGuildMembershipRequestRevoke>, I>>(base?: I): MsgGuildMembershipRequestRevoke {
    return MsgGuildMembershipRequestRevoke.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MsgGuildMembershipRequestRevoke>, I>>(
    object: I,
  ): MsgGuildMembershipRequestRevoke {
    const message = createBaseMsgGuildMembershipRequestRevoke();
    message.creator = object.creator ?? "";
    message.guildId = object.guildId ?? "";
    message.playerId = object.playerId ?? "";
    return message;
  },
};

function createBaseMsgGuildMembershipResponse(): MsgGuildMembershipResponse {
  return { guildMembershipApplication: undefined };
}

export const MsgGuildMembershipResponse: MessageFns<MsgGuildMembershipResponse> = {
  encode(message: MsgGuildMembershipResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.guildMembershipApplication !== undefined) {
      GuildMembershipApplication.encode(message.guildMembershipApplication, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MsgGuildMembershipResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgGuildMembershipResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.guildMembershipApplication = GuildMembershipApplication.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MsgGuildMembershipResponse {
    return {
      guildMembershipApplication: isSet(object.guildMembershipApplication)
        ? GuildMembershipApplication.fromJSON(object.guildMembershipApplication)
        : undefined,
    };
  },

  toJSON(message: MsgGuildMembershipResponse): unknown {
    const obj: any = {};
    if (message.guildMembershipApplication !== undefined) {
      obj.guildMembershipApplication = GuildMembershipApplication.toJSON(message.guildMembershipApplication);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<MsgGuildMembershipResponse>, I>>(base?: I): MsgGuildMembershipResponse {
    return MsgGuildMembershipResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MsgGuildMembershipResponse>, I>>(object: I): MsgGuildMembershipResponse {
    const message = createBaseMsgGuildMembershipResponse();
    message.guildMembershipApplication =
      (object.guildMembershipApplication !== undefined && object.guildMembershipApplication !== null)
        ? GuildMembershipApplication.fromPartial(object.guildMembershipApplication)
        : undefined;
    return message;
  },
};

function createBaseMsgPermissionGrantOnObject(): MsgPermissionGrantOnObject {
  return { creator: "", objectId: "", playerId: "", permissions: 0 };
}

export const MsgPermissionGrantOnObject: MessageFns<MsgPermissionGrantOnObject> = {
  encode(message: MsgPermissionGrantOnObject, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.creator !== "") {
      writer.uint32(10).string(message.creator);
    }
    if (message.objectId !== "") {
      writer.uint32(18).string(message.objectId);
    }
    if (message.playerId !== "") {
      writer.uint32(26).string(message.playerId);
    }
    if (message.permissions !== 0) {
      writer.uint32(32).uint64(message.permissions);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MsgPermissionGrantOnObject {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgPermissionGrantOnObject();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.creator = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.objectId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.playerId = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.permissions = longToNumber(reader.uint64());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MsgPermissionGrantOnObject {
    return {
      creator: isSet(object.creator) ? globalThis.String(object.creator) : "",
      objectId: isSet(object.objectId) ? globalThis.String(object.objectId) : "",
      playerId: isSet(object.playerId) ? globalThis.String(object.playerId) : "",
      permissions: isSet(object.permissions) ? globalThis.Number(object.permissions) : 0,
    };
  },

  toJSON(message: MsgPermissionGrantOnObject): unknown {
    const obj: any = {};
    if (message.creator !== "") {
      obj.creator = message.creator;
    }
    if (message.objectId !== "") {
      obj.objectId = message.objectId;
    }
    if (message.playerId !== "") {
      obj.playerId = message.playerId;
    }
    if (message.permissions !== 0) {
      obj.permissions = Math.round(message.permissions);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<MsgPermissionGrantOnObject>, I>>(base?: I): MsgPermissionGrantOnObject {
    return MsgPermissionGrantOnObject.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MsgPermissionGrantOnObject>, I>>(object: I): MsgPermissionGrantOnObject {
    const message = createBaseMsgPermissionGrantOnObject();
    message.creator = object.creator ?? "";
    message.objectId = object.objectId ?? "";
    message.playerId = object.playerId ?? "";
    message.permissions = object.permissions ?? 0;
    return message;
  },
};

function createBaseMsgPermissionGrantOnAddress(): MsgPermissionGrantOnAddress {
  return { creator: "", address: "", permissions: 0 };
}

export const MsgPermissionGrantOnAddress: MessageFns<MsgPermissionGrantOnAddress> = {
  encode(message: MsgPermissionGrantOnAddress, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.creator !== "") {
      writer.uint32(10).string(message.creator);
    }
    if (message.address !== "") {
      writer.uint32(18).string(message.address);
    }
    if (message.permissions !== 0) {
      writer.uint32(24).uint64(message.permissions);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MsgPermissionGrantOnAddress {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgPermissionGrantOnAddress();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.creator = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.address = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.permissions = longToNumber(reader.uint64());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MsgPermissionGrantOnAddress {
    return {
      creator: isSet(object.creator) ? globalThis.String(object.creator) : "",
      address: isSet(object.address) ? globalThis.String(object.address) : "",
      permissions: isSet(object.permissions) ? globalThis.Number(object.permissions) : 0,
    };
  },

  toJSON(message: MsgPermissionGrantOnAddress): unknown {
    const obj: any = {};
    if (message.creator !== "") {
      obj.creator = message.creator;
    }
    if (message.address !== "") {
      obj.address = message.address;
    }
    if (message.permissions !== 0) {
      obj.permissions = Math.round(message.permissions);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<MsgPermissionGrantOnAddress>, I>>(base?: I): MsgPermissionGrantOnAddress {
    return MsgPermissionGrantOnAddress.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MsgPermissionGrantOnAddress>, I>>(object: I): MsgPermissionGrantOnAddress {
    const message = createBaseMsgPermissionGrantOnAddress();
    message.creator = object.creator ?? "";
    message.address = object.address ?? "";
    message.permissions = object.permissions ?? 0;
    return message;
  },
};

function createBaseMsgPermissionRevokeOnObject(): MsgPermissionRevokeOnObject {
  return { creator: "", objectId: "", playerId: "", permissions: 0 };
}

export const MsgPermissionRevokeOnObject: MessageFns<MsgPermissionRevokeOnObject> = {
  encode(message: MsgPermissionRevokeOnObject, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.creator !== "") {
      writer.uint32(10).string(message.creator);
    }
    if (message.objectId !== "") {
      writer.uint32(18).string(message.objectId);
    }
    if (message.playerId !== "") {
      writer.uint32(26).string(message.playerId);
    }
    if (message.permissions !== 0) {
      writer.uint32(32).uint64(message.permissions);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MsgPermissionRevokeOnObject {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgPermissionRevokeOnObject();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.creator = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.objectId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.playerId = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.permissions = longToNumber(reader.uint64());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MsgPermissionRevokeOnObject {
    return {
      creator: isSet(object.creator) ? globalThis.String(object.creator) : "",
      objectId: isSet(object.objectId) ? globalThis.String(object.objectId) : "",
      playerId: isSet(object.playerId) ? globalThis.String(object.playerId) : "",
      permissions: isSet(object.permissions) ? globalThis.Number(object.permissions) : 0,
    };
  },

  toJSON(message: MsgPermissionRevokeOnObject): unknown {
    const obj: any = {};
    if (message.creator !== "") {
      obj.creator = message.creator;
    }
    if (message.objectId !== "") {
      obj.objectId = message.objectId;
    }
    if (message.playerId !== "") {
      obj.playerId = message.playerId;
    }
    if (message.permissions !== 0) {
      obj.permissions = Math.round(message.permissions);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<MsgPermissionRevokeOnObject>, I>>(base?: I): MsgPermissionRevokeOnObject {
    return MsgPermissionRevokeOnObject.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MsgPermissionRevokeOnObject>, I>>(object: I): MsgPermissionRevokeOnObject {
    const message = createBaseMsgPermissionRevokeOnObject();
    message.creator = object.creator ?? "";
    message.objectId = object.objectId ?? "";
    message.playerId = object.playerId ?? "";
    message.permissions = object.permissions ?? 0;
    return message;
  },
};

function createBaseMsgPermissionRevokeOnAddress(): MsgPermissionRevokeOnAddress {
  return { creator: "", address: "", permissions: 0 };
}

export const MsgPermissionRevokeOnAddress: MessageFns<MsgPermissionRevokeOnAddress> = {
  encode(message: MsgPermissionRevokeOnAddress, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.creator !== "") {
      writer.uint32(10).string(message.creator);
    }
    if (message.address !== "") {
      writer.uint32(18).string(message.address);
    }
    if (message.permissions !== 0) {
      writer.uint32(24).uint64(message.permissions);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MsgPermissionRevokeOnAddress {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgPermissionRevokeOnAddress();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.creator = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.address = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.permissions = longToNumber(reader.uint64());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MsgPermissionRevokeOnAddress {
    return {
      creator: isSet(object.creator) ? globalThis.String(object.creator) : "",
      address: isSet(object.address) ? globalThis.String(object.address) : "",
      permissions: isSet(object.permissions) ? globalThis.Number(object.permissions) : 0,
    };
  },

  toJSON(message: MsgPermissionRevokeOnAddress): unknown {
    const obj: any = {};
    if (message.creator !== "") {
      obj.creator = message.creator;
    }
    if (message.address !== "") {
      obj.address = message.address;
    }
    if (message.permissions !== 0) {
      obj.permissions = Math.round(message.permissions);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<MsgPermissionRevokeOnAddress>, I>>(base?: I): MsgPermissionRevokeOnAddress {
    return MsgPermissionRevokeOnAddress.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MsgPermissionRevokeOnAddress>, I>>(object: I): MsgPermissionRevokeOnAddress {
    const message = createBaseMsgPermissionRevokeOnAddress();
    message.creator = object.creator ?? "";
    message.address = object.address ?? "";
    message.permissions = object.permissions ?? 0;
    return message;
  },
};

function createBaseMsgPermissionSetOnObject(): MsgPermissionSetOnObject {
  return { creator: "", objectId: "", playerId: "", permissions: 0 };
}

export const MsgPermissionSetOnObject: MessageFns<MsgPermissionSetOnObject> = {
  encode(message: MsgPermissionSetOnObject, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.creator !== "") {
      writer.uint32(10).string(message.creator);
    }
    if (message.objectId !== "") {
      writer.uint32(18).string(message.objectId);
    }
    if (message.playerId !== "") {
      writer.uint32(26).string(message.playerId);
    }
    if (message.permissions !== 0) {
      writer.uint32(32).uint64(message.permissions);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MsgPermissionSetOnObject {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgPermissionSetOnObject();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.creator = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.objectId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.playerId = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.permissions = longToNumber(reader.uint64());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MsgPermissionSetOnObject {
    return {
      creator: isSet(object.creator) ? globalThis.String(object.creator) : "",
      objectId: isSet(object.objectId) ? globalThis.String(object.objectId) : "",
      playerId: isSet(object.playerId) ? globalThis.String(object.playerId) : "",
      permissions: isSet(object.permissions) ? globalThis.Number(object.permissions) : 0,
    };
  },

  toJSON(message: MsgPermissionSetOnObject): unknown {
    const obj: any = {};
    if (message.creator !== "") {
      obj.creator = message.creator;
    }
    if (message.objectId !== "") {
      obj.objectId = message.objectId;
    }
    if (message.playerId !== "") {
      obj.playerId = message.playerId;
    }
    if (message.permissions !== 0) {
      obj.permissions = Math.round(message.permissions);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<MsgPermissionSetOnObject>, I>>(base?: I): MsgPermissionSetOnObject {
    return MsgPermissionSetOnObject.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MsgPermissionSetOnObject>, I>>(object: I): MsgPermissionSetOnObject {
    const message = createBaseMsgPermissionSetOnObject();
    message.creator = object.creator ?? "";
    message.objectId = object.objectId ?? "";
    message.playerId = object.playerId ?? "";
    message.permissions = object.permissions ?? 0;
    return message;
  },
};

function createBaseMsgPermissionSetOnAddress(): MsgPermissionSetOnAddress {
  return { creator: "", address: "", permissions: 0 };
}

export const MsgPermissionSetOnAddress: MessageFns<MsgPermissionSetOnAddress> = {
  encode(message: MsgPermissionSetOnAddress, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.creator !== "") {
      writer.uint32(10).string(message.creator);
    }
    if (message.address !== "") {
      writer.uint32(18).string(message.address);
    }
    if (message.permissions !== 0) {
      writer.uint32(24).uint64(message.permissions);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MsgPermissionSetOnAddress {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgPermissionSetOnAddress();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.creator = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.address = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.permissions = longToNumber(reader.uint64());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MsgPermissionSetOnAddress {
    return {
      creator: isSet(object.creator) ? globalThis.String(object.creator) : "",
      address: isSet(object.address) ? globalThis.String(object.address) : "",
      permissions: isSet(object.permissions) ? globalThis.Number(object.permissions) : 0,
    };
  },

  toJSON(message: MsgPermissionSetOnAddress): unknown {
    const obj: any = {};
    if (message.creator !== "") {
      obj.creator = message.creator;
    }
    if (message.address !== "") {
      obj.address = message.address;
    }
    if (message.permissions !== 0) {
      obj.permissions = Math.round(message.permissions);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<MsgPermissionSetOnAddress>, I>>(base?: I): MsgPermissionSetOnAddress {
    return MsgPermissionSetOnAddress.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MsgPermissionSetOnAddress>, I>>(object: I): MsgPermissionSetOnAddress {
    const message = createBaseMsgPermissionSetOnAddress();
    message.creator = object.creator ?? "";
    message.address = object.address ?? "";
    message.permissions = object.permissions ?? 0;
    return message;
  },
};

function createBaseMsgPermissionResponse(): MsgPermissionResponse {
  return {};
}

export const MsgPermissionResponse: MessageFns<MsgPermissionResponse> = {
  encode(_: MsgPermissionResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MsgPermissionResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgPermissionResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): MsgPermissionResponse {
    return {};
  },

  toJSON(_: MsgPermissionResponse): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<MsgPermissionResponse>, I>>(base?: I): MsgPermissionResponse {
    return MsgPermissionResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MsgPermissionResponse>, I>>(_: I): MsgPermissionResponse {
    const message = createBaseMsgPermissionResponse();
    return message;
  },
};

function createBaseMsgPlanetExplore(): MsgPlanetExplore {
  return { creator: "", playerId: "" };
}

export const MsgPlanetExplore: MessageFns<MsgPlanetExplore> = {
  encode(message: MsgPlanetExplore, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.creator !== "") {
      writer.uint32(10).string(message.creator);
    }
    if (message.playerId !== "") {
      writer.uint32(18).string(message.playerId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MsgPlanetExplore {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgPlanetExplore();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.creator = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.playerId = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MsgPlanetExplore {
    return {
      creator: isSet(object.creator) ? globalThis.String(object.creator) : "",
      playerId: isSet(object.playerId) ? globalThis.String(object.playerId) : "",
    };
  },

  toJSON(message: MsgPlanetExplore): unknown {
    const obj: any = {};
    if (message.creator !== "") {
      obj.creator = message.creator;
    }
    if (message.playerId !== "") {
      obj.playerId = message.playerId;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<MsgPlanetExplore>, I>>(base?: I): MsgPlanetExplore {
    return MsgPlanetExplore.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MsgPlanetExplore>, I>>(object: I): MsgPlanetExplore {
    const message = createBaseMsgPlanetExplore();
    message.creator = object.creator ?? "";
    message.playerId = object.playerId ?? "";
    return message;
  },
};

function createBaseMsgPlanetExploreResponse(): MsgPlanetExploreResponse {
  return { planet: undefined };
}

export const MsgPlanetExploreResponse: MessageFns<MsgPlanetExploreResponse> = {
  encode(message: MsgPlanetExploreResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.planet !== undefined) {
      Planet.encode(message.planet, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MsgPlanetExploreResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgPlanetExploreResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.planet = Planet.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MsgPlanetExploreResponse {
    return { planet: isSet(object.planet) ? Planet.fromJSON(object.planet) : undefined };
  },

  toJSON(message: MsgPlanetExploreResponse): unknown {
    const obj: any = {};
    if (message.planet !== undefined) {
      obj.planet = Planet.toJSON(message.planet);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<MsgPlanetExploreResponse>, I>>(base?: I): MsgPlanetExploreResponse {
    return MsgPlanetExploreResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MsgPlanetExploreResponse>, I>>(object: I): MsgPlanetExploreResponse {
    const message = createBaseMsgPlanetExploreResponse();
    message.planet = (object.planet !== undefined && object.planet !== null)
      ? Planet.fromPartial(object.planet)
      : undefined;
    return message;
  },
};

function createBaseMsgPlanetRaidComplete(): MsgPlanetRaidComplete {
  return { creator: "", fleetId: "", proof: "", nonce: "" };
}

export const MsgPlanetRaidComplete: MessageFns<MsgPlanetRaidComplete> = {
  encode(message: MsgPlanetRaidComplete, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.creator !== "") {
      writer.uint32(10).string(message.creator);
    }
    if (message.fleetId !== "") {
      writer.uint32(18).string(message.fleetId);
    }
    if (message.proof !== "") {
      writer.uint32(26).string(message.proof);
    }
    if (message.nonce !== "") {
      writer.uint32(34).string(message.nonce);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MsgPlanetRaidComplete {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgPlanetRaidComplete();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.creator = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.fleetId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.proof = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.nonce = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MsgPlanetRaidComplete {
    return {
      creator: isSet(object.creator) ? globalThis.String(object.creator) : "",
      fleetId: isSet(object.fleetId) ? globalThis.String(object.fleetId) : "",
      proof: isSet(object.proof) ? globalThis.String(object.proof) : "",
      nonce: isSet(object.nonce) ? globalThis.String(object.nonce) : "",
    };
  },

  toJSON(message: MsgPlanetRaidComplete): unknown {
    const obj: any = {};
    if (message.creator !== "") {
      obj.creator = message.creator;
    }
    if (message.fleetId !== "") {
      obj.fleetId = message.fleetId;
    }
    if (message.proof !== "") {
      obj.proof = message.proof;
    }
    if (message.nonce !== "") {
      obj.nonce = message.nonce;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<MsgPlanetRaidComplete>, I>>(base?: I): MsgPlanetRaidComplete {
    return MsgPlanetRaidComplete.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MsgPlanetRaidComplete>, I>>(object: I): MsgPlanetRaidComplete {
    const message = createBaseMsgPlanetRaidComplete();
    message.creator = object.creator ?? "";
    message.fleetId = object.fleetId ?? "";
    message.proof = object.proof ?? "";
    message.nonce = object.nonce ?? "";
    return message;
  },
};

function createBaseMsgPlanetRaidCompleteResponse(): MsgPlanetRaidCompleteResponse {
  return { fleet: undefined, planet: undefined, oreStolen: 0 };
}

export const MsgPlanetRaidCompleteResponse: MessageFns<MsgPlanetRaidCompleteResponse> = {
  encode(message: MsgPlanetRaidCompleteResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.fleet !== undefined) {
      Fleet.encode(message.fleet, writer.uint32(10).fork()).join();
    }
    if (message.planet !== undefined) {
      Planet.encode(message.planet, writer.uint32(18).fork()).join();
    }
    if (message.oreStolen !== 0) {
      writer.uint32(24).uint64(message.oreStolen);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MsgPlanetRaidCompleteResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgPlanetRaidCompleteResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.fleet = Fleet.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.planet = Planet.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.oreStolen = longToNumber(reader.uint64());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MsgPlanetRaidCompleteResponse {
    return {
      fleet: isSet(object.fleet) ? Fleet.fromJSON(object.fleet) : undefined,
      planet: isSet(object.planet) ? Planet.fromJSON(object.planet) : undefined,
      oreStolen: isSet(object.oreStolen) ? globalThis.Number(object.oreStolen) : 0,
    };
  },

  toJSON(message: MsgPlanetRaidCompleteResponse): unknown {
    const obj: any = {};
    if (message.fleet !== undefined) {
      obj.fleet = Fleet.toJSON(message.fleet);
    }
    if (message.planet !== undefined) {
      obj.planet = Planet.toJSON(message.planet);
    }
    if (message.oreStolen !== 0) {
      obj.oreStolen = Math.round(message.oreStolen);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<MsgPlanetRaidCompleteResponse>, I>>(base?: I): MsgPlanetRaidCompleteResponse {
    return MsgPlanetRaidCompleteResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MsgPlanetRaidCompleteResponse>, I>>(
    object: I,
  ): MsgPlanetRaidCompleteResponse {
    const message = createBaseMsgPlanetRaidCompleteResponse();
    message.fleet = (object.fleet !== undefined && object.fleet !== null) ? Fleet.fromPartial(object.fleet) : undefined;
    message.planet = (object.planet !== undefined && object.planet !== null)
      ? Planet.fromPartial(object.planet)
      : undefined;
    message.oreStolen = object.oreStolen ?? 0;
    return message;
  },
};

function createBaseMsgPlayerUpdatePrimaryAddress(): MsgPlayerUpdatePrimaryAddress {
  return { creator: "", playerId: "", primaryAddress: "" };
}

export const MsgPlayerUpdatePrimaryAddress: MessageFns<MsgPlayerUpdatePrimaryAddress> = {
  encode(message: MsgPlayerUpdatePrimaryAddress, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.creator !== "") {
      writer.uint32(10).string(message.creator);
    }
    if (message.playerId !== "") {
      writer.uint32(18).string(message.playerId);
    }
    if (message.primaryAddress !== "") {
      writer.uint32(26).string(message.primaryAddress);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MsgPlayerUpdatePrimaryAddress {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgPlayerUpdatePrimaryAddress();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.creator = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.playerId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.primaryAddress = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MsgPlayerUpdatePrimaryAddress {
    return {
      creator: isSet(object.creator) ? globalThis.String(object.creator) : "",
      playerId: isSet(object.playerId) ? globalThis.String(object.playerId) : "",
      primaryAddress: isSet(object.primaryAddress) ? globalThis.String(object.primaryAddress) : "",
    };
  },

  toJSON(message: MsgPlayerUpdatePrimaryAddress): unknown {
    const obj: any = {};
    if (message.creator !== "") {
      obj.creator = message.creator;
    }
    if (message.playerId !== "") {
      obj.playerId = message.playerId;
    }
    if (message.primaryAddress !== "") {
      obj.primaryAddress = message.primaryAddress;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<MsgPlayerUpdatePrimaryAddress>, I>>(base?: I): MsgPlayerUpdatePrimaryAddress {
    return MsgPlayerUpdatePrimaryAddress.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MsgPlayerUpdatePrimaryAddress>, I>>(
    object: I,
  ): MsgPlayerUpdatePrimaryAddress {
    const message = createBaseMsgPlayerUpdatePrimaryAddress();
    message.creator = object.creator ?? "";
    message.playerId = object.playerId ?? "";
    message.primaryAddress = object.primaryAddress ?? "";
    return message;
  },
};

function createBaseMsgPlayerUpdatePrimaryAddressResponse(): MsgPlayerUpdatePrimaryAddressResponse {
  return {};
}

export const MsgPlayerUpdatePrimaryAddressResponse: MessageFns<MsgPlayerUpdatePrimaryAddressResponse> = {
  encode(_: MsgPlayerUpdatePrimaryAddressResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MsgPlayerUpdatePrimaryAddressResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgPlayerUpdatePrimaryAddressResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): MsgPlayerUpdatePrimaryAddressResponse {
    return {};
  },

  toJSON(_: MsgPlayerUpdatePrimaryAddressResponse): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<MsgPlayerUpdatePrimaryAddressResponse>, I>>(
    base?: I,
  ): MsgPlayerUpdatePrimaryAddressResponse {
    return MsgPlayerUpdatePrimaryAddressResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MsgPlayerUpdatePrimaryAddressResponse>, I>>(
    _: I,
  ): MsgPlayerUpdatePrimaryAddressResponse {
    const message = createBaseMsgPlayerUpdatePrimaryAddressResponse();
    return message;
  },
};

function createBaseMsgPlayerResume(): MsgPlayerResume {
  return { creator: "", playerId: "" };
}

export const MsgPlayerResume: MessageFns<MsgPlayerResume> = {
  encode(message: MsgPlayerResume, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.creator !== "") {
      writer.uint32(10).string(message.creator);
    }
    if (message.playerId !== "") {
      writer.uint32(18).string(message.playerId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MsgPlayerResume {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgPlayerResume();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.creator = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.playerId = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MsgPlayerResume {
    return {
      creator: isSet(object.creator) ? globalThis.String(object.creator) : "",
      playerId: isSet(object.playerId) ? globalThis.String(object.playerId) : "",
    };
  },

  toJSON(message: MsgPlayerResume): unknown {
    const obj: any = {};
    if (message.creator !== "") {
      obj.creator = message.creator;
    }
    if (message.playerId !== "") {
      obj.playerId = message.playerId;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<MsgPlayerResume>, I>>(base?: I): MsgPlayerResume {
    return MsgPlayerResume.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MsgPlayerResume>, I>>(object: I): MsgPlayerResume {
    const message = createBaseMsgPlayerResume();
    message.creator = object.creator ?? "";
    message.playerId = object.playerId ?? "";
    return message;
  },
};

function createBaseMsgPlayerResumeResponse(): MsgPlayerResumeResponse {
  return {};
}

export const MsgPlayerResumeResponse: MessageFns<MsgPlayerResumeResponse> = {
  encode(_: MsgPlayerResumeResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MsgPlayerResumeResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgPlayerResumeResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): MsgPlayerResumeResponse {
    return {};
  },

  toJSON(_: MsgPlayerResumeResponse): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<MsgPlayerResumeResponse>, I>>(base?: I): MsgPlayerResumeResponse {
    return MsgPlayerResumeResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MsgPlayerResumeResponse>, I>>(_: I): MsgPlayerResumeResponse {
    const message = createBaseMsgPlayerResumeResponse();
    return message;
  },
};

function createBaseMsgStructStatusResponse(): MsgStructStatusResponse {
  return { struct: undefined };
}

export const MsgStructStatusResponse: MessageFns<MsgStructStatusResponse> = {
  encode(message: MsgStructStatusResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.struct !== undefined) {
      Struct.encode(message.struct, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MsgStructStatusResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgStructStatusResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.struct = Struct.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MsgStructStatusResponse {
    return { struct: isSet(object.struct) ? Struct.fromJSON(object.struct) : undefined };
  },

  toJSON(message: MsgStructStatusResponse): unknown {
    const obj: any = {};
    if (message.struct !== undefined) {
      obj.struct = Struct.toJSON(message.struct);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<MsgStructStatusResponse>, I>>(base?: I): MsgStructStatusResponse {
    return MsgStructStatusResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MsgStructStatusResponse>, I>>(object: I): MsgStructStatusResponse {
    const message = createBaseMsgStructStatusResponse();
    message.struct = (object.struct !== undefined && object.struct !== null)
      ? Struct.fromPartial(object.struct)
      : undefined;
    return message;
  },
};

function createBaseMsgStructActivate(): MsgStructActivate {
  return { creator: "", structId: "" };
}

export const MsgStructActivate: MessageFns<MsgStructActivate> = {
  encode(message: MsgStructActivate, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.creator !== "") {
      writer.uint32(10).string(message.creator);
    }
    if (message.structId !== "") {
      writer.uint32(18).string(message.structId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MsgStructActivate {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgStructActivate();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.creator = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.structId = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MsgStructActivate {
    return {
      creator: isSet(object.creator) ? globalThis.String(object.creator) : "",
      structId: isSet(object.structId) ? globalThis.String(object.structId) : "",
    };
  },

  toJSON(message: MsgStructActivate): unknown {
    const obj: any = {};
    if (message.creator !== "") {
      obj.creator = message.creator;
    }
    if (message.structId !== "") {
      obj.structId = message.structId;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<MsgStructActivate>, I>>(base?: I): MsgStructActivate {
    return MsgStructActivate.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MsgStructActivate>, I>>(object: I): MsgStructActivate {
    const message = createBaseMsgStructActivate();
    message.creator = object.creator ?? "";
    message.structId = object.structId ?? "";
    return message;
  },
};

function createBaseMsgStructDeactivate(): MsgStructDeactivate {
  return { creator: "", structId: "" };
}

export const MsgStructDeactivate: MessageFns<MsgStructDeactivate> = {
  encode(message: MsgStructDeactivate, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.creator !== "") {
      writer.uint32(10).string(message.creator);
    }
    if (message.structId !== "") {
      writer.uint32(18).string(message.structId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MsgStructDeactivate {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgStructDeactivate();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.creator = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.structId = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MsgStructDeactivate {
    return {
      creator: isSet(object.creator) ? globalThis.String(object.creator) : "",
      structId: isSet(object.structId) ? globalThis.String(object.structId) : "",
    };
  },

  toJSON(message: MsgStructDeactivate): unknown {
    const obj: any = {};
    if (message.creator !== "") {
      obj.creator = message.creator;
    }
    if (message.structId !== "") {
      obj.structId = message.structId;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<MsgStructDeactivate>, I>>(base?: I): MsgStructDeactivate {
    return MsgStructDeactivate.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MsgStructDeactivate>, I>>(object: I): MsgStructDeactivate {
    const message = createBaseMsgStructDeactivate();
    message.creator = object.creator ?? "";
    message.structId = object.structId ?? "";
    return message;
  },
};

function createBaseMsgStructBuildInitiate(): MsgStructBuildInitiate {
  return { creator: "", playerId: "", structTypeId: 0, operatingAmbit: 0, slot: 0 };
}

export const MsgStructBuildInitiate: MessageFns<MsgStructBuildInitiate> = {
  encode(message: MsgStructBuildInitiate, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.creator !== "") {
      writer.uint32(10).string(message.creator);
    }
    if (message.playerId !== "") {
      writer.uint32(18).string(message.playerId);
    }
    if (message.structTypeId !== 0) {
      writer.uint32(24).uint64(message.structTypeId);
    }
    if (message.operatingAmbit !== 0) {
      writer.uint32(32).int32(message.operatingAmbit);
    }
    if (message.slot !== 0) {
      writer.uint32(40).uint64(message.slot);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MsgStructBuildInitiate {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgStructBuildInitiate();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.creator = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.playerId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.structTypeId = longToNumber(reader.uint64());
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.operatingAmbit = reader.int32() as any;
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.slot = longToNumber(reader.uint64());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MsgStructBuildInitiate {
    return {
      creator: isSet(object.creator) ? globalThis.String(object.creator) : "",
      playerId: isSet(object.playerId) ? globalThis.String(object.playerId) : "",
      structTypeId: isSet(object.structTypeId) ? globalThis.Number(object.structTypeId) : 0,
      operatingAmbit: isSet(object.operatingAmbit) ? ambitFromJSON(object.operatingAmbit) : 0,
      slot: isSet(object.slot) ? globalThis.Number(object.slot) : 0,
    };
  },

  toJSON(message: MsgStructBuildInitiate): unknown {
    const obj: any = {};
    if (message.creator !== "") {
      obj.creator = message.creator;
    }
    if (message.playerId !== "") {
      obj.playerId = message.playerId;
    }
    if (message.structTypeId !== 0) {
      obj.structTypeId = Math.round(message.structTypeId);
    }
    if (message.operatingAmbit !== 0) {
      obj.operatingAmbit = ambitToJSON(message.operatingAmbit);
    }
    if (message.slot !== 0) {
      obj.slot = Math.round(message.slot);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<MsgStructBuildInitiate>, I>>(base?: I): MsgStructBuildInitiate {
    return MsgStructBuildInitiate.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MsgStructBuildInitiate>, I>>(object: I): MsgStructBuildInitiate {
    const message = createBaseMsgStructBuildInitiate();
    message.creator = object.creator ?? "";
    message.playerId = object.playerId ?? "";
    message.structTypeId = object.structTypeId ?? 0;
    message.operatingAmbit = object.operatingAmbit ?? 0;
    message.slot = object.slot ?? 0;
    return message;
  },
};

function createBaseMsgStructBuildComplete(): MsgStructBuildComplete {
  return { creator: "", structId: "", proof: "", nonce: "" };
}

export const MsgStructBuildComplete: MessageFns<MsgStructBuildComplete> = {
  encode(message: MsgStructBuildComplete, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.creator !== "") {
      writer.uint32(10).string(message.creator);
    }
    if (message.structId !== "") {
      writer.uint32(18).string(message.structId);
    }
    if (message.proof !== "") {
      writer.uint32(26).string(message.proof);
    }
    if (message.nonce !== "") {
      writer.uint32(34).string(message.nonce);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MsgStructBuildComplete {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgStructBuildComplete();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.creator = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.structId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.proof = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.nonce = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MsgStructBuildComplete {
    return {
      creator: isSet(object.creator) ? globalThis.String(object.creator) : "",
      structId: isSet(object.structId) ? globalThis.String(object.structId) : "",
      proof: isSet(object.proof) ? globalThis.String(object.proof) : "",
      nonce: isSet(object.nonce) ? globalThis.String(object.nonce) : "",
    };
  },

  toJSON(message: MsgStructBuildComplete): unknown {
    const obj: any = {};
    if (message.creator !== "") {
      obj.creator = message.creator;
    }
    if (message.structId !== "") {
      obj.structId = message.structId;
    }
    if (message.proof !== "") {
      obj.proof = message.proof;
    }
    if (message.nonce !== "") {
      obj.nonce = message.nonce;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<MsgStructBuildComplete>, I>>(base?: I): MsgStructBuildComplete {
    return MsgStructBuildComplete.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MsgStructBuildComplete>, I>>(object: I): MsgStructBuildComplete {
    const message = createBaseMsgStructBuildComplete();
    message.creator = object.creator ?? "";
    message.structId = object.structId ?? "";
    message.proof = object.proof ?? "";
    message.nonce = object.nonce ?? "";
    return message;
  },
};

function createBaseMsgStructBuildCancel(): MsgStructBuildCancel {
  return { creator: "", structId: "" };
}

export const MsgStructBuildCancel: MessageFns<MsgStructBuildCancel> = {
  encode(message: MsgStructBuildCancel, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.creator !== "") {
      writer.uint32(10).string(message.creator);
    }
    if (message.structId !== "") {
      writer.uint32(18).string(message.structId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MsgStructBuildCancel {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgStructBuildCancel();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.creator = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.structId = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MsgStructBuildCancel {
    return {
      creator: isSet(object.creator) ? globalThis.String(object.creator) : "",
      structId: isSet(object.structId) ? globalThis.String(object.structId) : "",
    };
  },

  toJSON(message: MsgStructBuildCancel): unknown {
    const obj: any = {};
    if (message.creator !== "") {
      obj.creator = message.creator;
    }
    if (message.structId !== "") {
      obj.structId = message.structId;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<MsgStructBuildCancel>, I>>(base?: I): MsgStructBuildCancel {
    return MsgStructBuildCancel.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MsgStructBuildCancel>, I>>(object: I): MsgStructBuildCancel {
    const message = createBaseMsgStructBuildCancel();
    message.creator = object.creator ?? "";
    message.structId = object.structId ?? "";
    return message;
  },
};

function createBaseMsgStructBuildCompleteAndStash(): MsgStructBuildCompleteAndStash {
  return { creator: "", structId: "", proof: "", nonce: "", storageDestinationId: "", storageAmbit: 0, storageSlot: 0 };
}

export const MsgStructBuildCompleteAndStash: MessageFns<MsgStructBuildCompleteAndStash> = {
  encode(message: MsgStructBuildCompleteAndStash, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.creator !== "") {
      writer.uint32(10).string(message.creator);
    }
    if (message.structId !== "") {
      writer.uint32(18).string(message.structId);
    }
    if (message.proof !== "") {
      writer.uint32(26).string(message.proof);
    }
    if (message.nonce !== "") {
      writer.uint32(34).string(message.nonce);
    }
    if (message.storageDestinationId !== "") {
      writer.uint32(42).string(message.storageDestinationId);
    }
    if (message.storageAmbit !== 0) {
      writer.uint32(48).int32(message.storageAmbit);
    }
    if (message.storageSlot !== 0) {
      writer.uint32(56).uint64(message.storageSlot);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MsgStructBuildCompleteAndStash {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgStructBuildCompleteAndStash();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.creator = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.structId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.proof = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.nonce = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.storageDestinationId = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.storageAmbit = reader.int32() as any;
          continue;
        }
        case 7: {
          if (tag !== 56) {
            break;
          }

          message.storageSlot = longToNumber(reader.uint64());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MsgStructBuildCompleteAndStash {
    return {
      creator: isSet(object.creator) ? globalThis.String(object.creator) : "",
      structId: isSet(object.structId) ? globalThis.String(object.structId) : "",
      proof: isSet(object.proof) ? globalThis.String(object.proof) : "",
      nonce: isSet(object.nonce) ? globalThis.String(object.nonce) : "",
      storageDestinationId: isSet(object.storageDestinationId) ? globalThis.String(object.storageDestinationId) : "",
      storageAmbit: isSet(object.storageAmbit) ? ambitFromJSON(object.storageAmbit) : 0,
      storageSlot: isSet(object.storageSlot) ? globalThis.Number(object.storageSlot) : 0,
    };
  },

  toJSON(message: MsgStructBuildCompleteAndStash): unknown {
    const obj: any = {};
    if (message.creator !== "") {
      obj.creator = message.creator;
    }
    if (message.structId !== "") {
      obj.structId = message.structId;
    }
    if (message.proof !== "") {
      obj.proof = message.proof;
    }
    if (message.nonce !== "") {
      obj.nonce = message.nonce;
    }
    if (message.storageDestinationId !== "") {
      obj.storageDestinationId = message.storageDestinationId;
    }
    if (message.storageAmbit !== 0) {
      obj.storageAmbit = ambitToJSON(message.storageAmbit);
    }
    if (message.storageSlot !== 0) {
      obj.storageSlot = Math.round(message.storageSlot);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<MsgStructBuildCompleteAndStash>, I>>(base?: I): MsgStructBuildCompleteAndStash {
    return MsgStructBuildCompleteAndStash.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MsgStructBuildCompleteAndStash>, I>>(
    object: I,
  ): MsgStructBuildCompleteAndStash {
    const message = createBaseMsgStructBuildCompleteAndStash();
    message.creator = object.creator ?? "";
    message.structId = object.structId ?? "";
    message.proof = object.proof ?? "";
    message.nonce = object.nonce ?? "";
    message.storageDestinationId = object.storageDestinationId ?? "";
    message.storageAmbit = object.storageAmbit ?? 0;
    message.storageSlot = object.storageSlot ?? 0;
    return message;
  },
};

function createBaseMsgStructDefenseSet(): MsgStructDefenseSet {
  return { creator: "", defenderStructId: "", protectedStructId: "" };
}

export const MsgStructDefenseSet: MessageFns<MsgStructDefenseSet> = {
  encode(message: MsgStructDefenseSet, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.creator !== "") {
      writer.uint32(10).string(message.creator);
    }
    if (message.defenderStructId !== "") {
      writer.uint32(18).string(message.defenderStructId);
    }
    if (message.protectedStructId !== "") {
      writer.uint32(26).string(message.protectedStructId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MsgStructDefenseSet {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgStructDefenseSet();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.creator = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.defenderStructId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.protectedStructId = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MsgStructDefenseSet {
    return {
      creator: isSet(object.creator) ? globalThis.String(object.creator) : "",
      defenderStructId: isSet(object.defenderStructId) ? globalThis.String(object.defenderStructId) : "",
      protectedStructId: isSet(object.protectedStructId) ? globalThis.String(object.protectedStructId) : "",
    };
  },

  toJSON(message: MsgStructDefenseSet): unknown {
    const obj: any = {};
    if (message.creator !== "") {
      obj.creator = message.creator;
    }
    if (message.defenderStructId !== "") {
      obj.defenderStructId = message.defenderStructId;
    }
    if (message.protectedStructId !== "") {
      obj.protectedStructId = message.protectedStructId;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<MsgStructDefenseSet>, I>>(base?: I): MsgStructDefenseSet {
    return MsgStructDefenseSet.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MsgStructDefenseSet>, I>>(object: I): MsgStructDefenseSet {
    const message = createBaseMsgStructDefenseSet();
    message.creator = object.creator ?? "";
    message.defenderStructId = object.defenderStructId ?? "";
    message.protectedStructId = object.protectedStructId ?? "";
    return message;
  },
};

function createBaseMsgStructDefenseClear(): MsgStructDefenseClear {
  return { creator: "", defenderStructId: "" };
}

export const MsgStructDefenseClear: MessageFns<MsgStructDefenseClear> = {
  encode(message: MsgStructDefenseClear, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.creator !== "") {
      writer.uint32(10).string(message.creator);
    }
    if (message.defenderStructId !== "") {
      writer.uint32(18).string(message.defenderStructId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MsgStructDefenseClear {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgStructDefenseClear();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.creator = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.defenderStructId = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MsgStructDefenseClear {
    return {
      creator: isSet(object.creator) ? globalThis.String(object.creator) : "",
      defenderStructId: isSet(object.defenderStructId) ? globalThis.String(object.defenderStructId) : "",
    };
  },

  toJSON(message: MsgStructDefenseClear): unknown {
    const obj: any = {};
    if (message.creator !== "") {
      obj.creator = message.creator;
    }
    if (message.defenderStructId !== "") {
      obj.defenderStructId = message.defenderStructId;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<MsgStructDefenseClear>, I>>(base?: I): MsgStructDefenseClear {
    return MsgStructDefenseClear.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MsgStructDefenseClear>, I>>(object: I): MsgStructDefenseClear {
    const message = createBaseMsgStructDefenseClear();
    message.creator = object.creator ?? "";
    message.defenderStructId = object.defenderStructId ?? "";
    return message;
  },
};

function createBaseMsgStructMove(): MsgStructMove {
  return { creator: "", structId: "", locationType: 0, ambit: 0, slot: 0 };
}

export const MsgStructMove: MessageFns<MsgStructMove> = {
  encode(message: MsgStructMove, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.creator !== "") {
      writer.uint32(10).string(message.creator);
    }
    if (message.structId !== "") {
      writer.uint32(18).string(message.structId);
    }
    if (message.locationType !== 0) {
      writer.uint32(32).int32(message.locationType);
    }
    if (message.ambit !== 0) {
      writer.uint32(40).int32(message.ambit);
    }
    if (message.slot !== 0) {
      writer.uint32(48).uint64(message.slot);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MsgStructMove {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgStructMove();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.creator = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.structId = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.locationType = reader.int32() as any;
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.ambit = reader.int32() as any;
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.slot = longToNumber(reader.uint64());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MsgStructMove {
    return {
      creator: isSet(object.creator) ? globalThis.String(object.creator) : "",
      structId: isSet(object.structId) ? globalThis.String(object.structId) : "",
      locationType: isSet(object.locationType) ? objectTypeFromJSON(object.locationType) : 0,
      ambit: isSet(object.ambit) ? ambitFromJSON(object.ambit) : 0,
      slot: isSet(object.slot) ? globalThis.Number(object.slot) : 0,
    };
  },

  toJSON(message: MsgStructMove): unknown {
    const obj: any = {};
    if (message.creator !== "") {
      obj.creator = message.creator;
    }
    if (message.structId !== "") {
      obj.structId = message.structId;
    }
    if (message.locationType !== 0) {
      obj.locationType = objectTypeToJSON(message.locationType);
    }
    if (message.ambit !== 0) {
      obj.ambit = ambitToJSON(message.ambit);
    }
    if (message.slot !== 0) {
      obj.slot = Math.round(message.slot);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<MsgStructMove>, I>>(base?: I): MsgStructMove {
    return MsgStructMove.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MsgStructMove>, I>>(object: I): MsgStructMove {
    const message = createBaseMsgStructMove();
    message.creator = object.creator ?? "";
    message.structId = object.structId ?? "";
    message.locationType = object.locationType ?? 0;
    message.ambit = object.ambit ?? 0;
    message.slot = object.slot ?? 0;
    return message;
  },
};

function createBaseMsgStructAttack(): MsgStructAttack {
  return { creator: "", operatingStructId: "", targetStructId: [], weaponSystem: "" };
}

export const MsgStructAttack: MessageFns<MsgStructAttack> = {
  encode(message: MsgStructAttack, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.creator !== "") {
      writer.uint32(10).string(message.creator);
    }
    if (message.operatingStructId !== "") {
      writer.uint32(18).string(message.operatingStructId);
    }
    for (const v of message.targetStructId) {
      writer.uint32(26).string(v!);
    }
    if (message.weaponSystem !== "") {
      writer.uint32(34).string(message.weaponSystem);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MsgStructAttack {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgStructAttack();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.creator = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.operatingStructId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.targetStructId.push(reader.string());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.weaponSystem = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MsgStructAttack {
    return {
      creator: isSet(object.creator) ? globalThis.String(object.creator) : "",
      operatingStructId: isSet(object.operatingStructId) ? globalThis.String(object.operatingStructId) : "",
      targetStructId: globalThis.Array.isArray(object?.targetStructId)
        ? object.targetStructId.map((e: any) => globalThis.String(e))
        : [],
      weaponSystem: isSet(object.weaponSystem) ? globalThis.String(object.weaponSystem) : "",
    };
  },

  toJSON(message: MsgStructAttack): unknown {
    const obj: any = {};
    if (message.creator !== "") {
      obj.creator = message.creator;
    }
    if (message.operatingStructId !== "") {
      obj.operatingStructId = message.operatingStructId;
    }
    if (message.targetStructId?.length) {
      obj.targetStructId = message.targetStructId;
    }
    if (message.weaponSystem !== "") {
      obj.weaponSystem = message.weaponSystem;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<MsgStructAttack>, I>>(base?: I): MsgStructAttack {
    return MsgStructAttack.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MsgStructAttack>, I>>(object: I): MsgStructAttack {
    const message = createBaseMsgStructAttack();
    message.creator = object.creator ?? "";
    message.operatingStructId = object.operatingStructId ?? "";
    message.targetStructId = object.targetStructId?.map((e) => e) || [];
    message.weaponSystem = object.weaponSystem ?? "";
    return message;
  },
};

function createBaseMsgStructAttackResponse(): MsgStructAttackResponse {
  return {};
}

export const MsgStructAttackResponse: MessageFns<MsgStructAttackResponse> = {
  encode(_: MsgStructAttackResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MsgStructAttackResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgStructAttackResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): MsgStructAttackResponse {
    return {};
  },

  toJSON(_: MsgStructAttackResponse): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<MsgStructAttackResponse>, I>>(base?: I): MsgStructAttackResponse {
    return MsgStructAttackResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MsgStructAttackResponse>, I>>(_: I): MsgStructAttackResponse {
    const message = createBaseMsgStructAttackResponse();
    return message;
  },
};

function createBaseMsgStructStealthActivate(): MsgStructStealthActivate {
  return { creator: "", structId: "" };
}

export const MsgStructStealthActivate: MessageFns<MsgStructStealthActivate> = {
  encode(message: MsgStructStealthActivate, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.creator !== "") {
      writer.uint32(10).string(message.creator);
    }
    if (message.structId !== "") {
      writer.uint32(18).string(message.structId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MsgStructStealthActivate {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgStructStealthActivate();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.creator = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.structId = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MsgStructStealthActivate {
    return {
      creator: isSet(object.creator) ? globalThis.String(object.creator) : "",
      structId: isSet(object.structId) ? globalThis.String(object.structId) : "",
    };
  },

  toJSON(message: MsgStructStealthActivate): unknown {
    const obj: any = {};
    if (message.creator !== "") {
      obj.creator = message.creator;
    }
    if (message.structId !== "") {
      obj.structId = message.structId;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<MsgStructStealthActivate>, I>>(base?: I): MsgStructStealthActivate {
    return MsgStructStealthActivate.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MsgStructStealthActivate>, I>>(object: I): MsgStructStealthActivate {
    const message = createBaseMsgStructStealthActivate();
    message.creator = object.creator ?? "";
    message.structId = object.structId ?? "";
    return message;
  },
};

function createBaseMsgStructStealthDeactivate(): MsgStructStealthDeactivate {
  return { creator: "", structId: "" };
}

export const MsgStructStealthDeactivate: MessageFns<MsgStructStealthDeactivate> = {
  encode(message: MsgStructStealthDeactivate, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.creator !== "") {
      writer.uint32(10).string(message.creator);
    }
    if (message.structId !== "") {
      writer.uint32(18).string(message.structId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MsgStructStealthDeactivate {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgStructStealthDeactivate();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.creator = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.structId = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MsgStructStealthDeactivate {
    return {
      creator: isSet(object.creator) ? globalThis.String(object.creator) : "",
      structId: isSet(object.structId) ? globalThis.String(object.structId) : "",
    };
  },

  toJSON(message: MsgStructStealthDeactivate): unknown {
    const obj: any = {};
    if (message.creator !== "") {
      obj.creator = message.creator;
    }
    if (message.structId !== "") {
      obj.structId = message.structId;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<MsgStructStealthDeactivate>, I>>(base?: I): MsgStructStealthDeactivate {
    return MsgStructStealthDeactivate.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MsgStructStealthDeactivate>, I>>(object: I): MsgStructStealthDeactivate {
    const message = createBaseMsgStructStealthDeactivate();
    message.creator = object.creator ?? "";
    message.structId = object.structId ?? "";
    return message;
  },
};

function createBaseMsgStructGeneratorInfuse(): MsgStructGeneratorInfuse {
  return { creator: "", structId: "", infuseAmount: "" };
}

export const MsgStructGeneratorInfuse: MessageFns<MsgStructGeneratorInfuse> = {
  encode(message: MsgStructGeneratorInfuse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.creator !== "") {
      writer.uint32(10).string(message.creator);
    }
    if (message.structId !== "") {
      writer.uint32(18).string(message.structId);
    }
    if (message.infuseAmount !== "") {
      writer.uint32(26).string(message.infuseAmount);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MsgStructGeneratorInfuse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgStructGeneratorInfuse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.creator = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.structId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.infuseAmount = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MsgStructGeneratorInfuse {
    return {
      creator: isSet(object.creator) ? globalThis.String(object.creator) : "",
      structId: isSet(object.structId) ? globalThis.String(object.structId) : "",
      infuseAmount: isSet(object.infuseAmount) ? globalThis.String(object.infuseAmount) : "",
    };
  },

  toJSON(message: MsgStructGeneratorInfuse): unknown {
    const obj: any = {};
    if (message.creator !== "") {
      obj.creator = message.creator;
    }
    if (message.structId !== "") {
      obj.structId = message.structId;
    }
    if (message.infuseAmount !== "") {
      obj.infuseAmount = message.infuseAmount;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<MsgStructGeneratorInfuse>, I>>(base?: I): MsgStructGeneratorInfuse {
    return MsgStructGeneratorInfuse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MsgStructGeneratorInfuse>, I>>(object: I): MsgStructGeneratorInfuse {
    const message = createBaseMsgStructGeneratorInfuse();
    message.creator = object.creator ?? "";
    message.structId = object.structId ?? "";
    message.infuseAmount = object.infuseAmount ?? "";
    return message;
  },
};

function createBaseMsgStructGeneratorStatusResponse(): MsgStructGeneratorStatusResponse {
  return {};
}

export const MsgStructGeneratorStatusResponse: MessageFns<MsgStructGeneratorStatusResponse> = {
  encode(_: MsgStructGeneratorStatusResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MsgStructGeneratorStatusResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgStructGeneratorStatusResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): MsgStructGeneratorStatusResponse {
    return {};
  },

  toJSON(_: MsgStructGeneratorStatusResponse): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<MsgStructGeneratorStatusResponse>, I>>(
    base?: I,
  ): MsgStructGeneratorStatusResponse {
    return MsgStructGeneratorStatusResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MsgStructGeneratorStatusResponse>, I>>(
    _: I,
  ): MsgStructGeneratorStatusResponse {
    const message = createBaseMsgStructGeneratorStatusResponse();
    return message;
  },
};

function createBaseMsgStructOreMinerComplete(): MsgStructOreMinerComplete {
  return { creator: "", structId: "", proof: "", nonce: "" };
}

export const MsgStructOreMinerComplete: MessageFns<MsgStructOreMinerComplete> = {
  encode(message: MsgStructOreMinerComplete, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.creator !== "") {
      writer.uint32(10).string(message.creator);
    }
    if (message.structId !== "") {
      writer.uint32(18).string(message.structId);
    }
    if (message.proof !== "") {
      writer.uint32(26).string(message.proof);
    }
    if (message.nonce !== "") {
      writer.uint32(34).string(message.nonce);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MsgStructOreMinerComplete {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgStructOreMinerComplete();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.creator = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.structId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.proof = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.nonce = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MsgStructOreMinerComplete {
    return {
      creator: isSet(object.creator) ? globalThis.String(object.creator) : "",
      structId: isSet(object.structId) ? globalThis.String(object.structId) : "",
      proof: isSet(object.proof) ? globalThis.String(object.proof) : "",
      nonce: isSet(object.nonce) ? globalThis.String(object.nonce) : "",
    };
  },

  toJSON(message: MsgStructOreMinerComplete): unknown {
    const obj: any = {};
    if (message.creator !== "") {
      obj.creator = message.creator;
    }
    if (message.structId !== "") {
      obj.structId = message.structId;
    }
    if (message.proof !== "") {
      obj.proof = message.proof;
    }
    if (message.nonce !== "") {
      obj.nonce = message.nonce;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<MsgStructOreMinerComplete>, I>>(base?: I): MsgStructOreMinerComplete {
    return MsgStructOreMinerComplete.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MsgStructOreMinerComplete>, I>>(object: I): MsgStructOreMinerComplete {
    const message = createBaseMsgStructOreMinerComplete();
    message.creator = object.creator ?? "";
    message.structId = object.structId ?? "";
    message.proof = object.proof ?? "";
    message.nonce = object.nonce ?? "";
    return message;
  },
};

function createBaseMsgStructOreMinerStatusResponse(): MsgStructOreMinerStatusResponse {
  return { struct: undefined };
}

export const MsgStructOreMinerStatusResponse: MessageFns<MsgStructOreMinerStatusResponse> = {
  encode(message: MsgStructOreMinerStatusResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.struct !== undefined) {
      Struct.encode(message.struct, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MsgStructOreMinerStatusResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgStructOreMinerStatusResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.struct = Struct.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MsgStructOreMinerStatusResponse {
    return { struct: isSet(object.struct) ? Struct.fromJSON(object.struct) : undefined };
  },

  toJSON(message: MsgStructOreMinerStatusResponse): unknown {
    const obj: any = {};
    if (message.struct !== undefined) {
      obj.struct = Struct.toJSON(message.struct);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<MsgStructOreMinerStatusResponse>, I>>(base?: I): MsgStructOreMinerStatusResponse {
    return MsgStructOreMinerStatusResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MsgStructOreMinerStatusResponse>, I>>(
    object: I,
  ): MsgStructOreMinerStatusResponse {
    const message = createBaseMsgStructOreMinerStatusResponse();
    message.struct = (object.struct !== undefined && object.struct !== null)
      ? Struct.fromPartial(object.struct)
      : undefined;
    return message;
  },
};

function createBaseMsgStructOreRefineryComplete(): MsgStructOreRefineryComplete {
  return { creator: "", structId: "", proof: "", nonce: "" };
}

export const MsgStructOreRefineryComplete: MessageFns<MsgStructOreRefineryComplete> = {
  encode(message: MsgStructOreRefineryComplete, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.creator !== "") {
      writer.uint32(10).string(message.creator);
    }
    if (message.structId !== "") {
      writer.uint32(18).string(message.structId);
    }
    if (message.proof !== "") {
      writer.uint32(26).string(message.proof);
    }
    if (message.nonce !== "") {
      writer.uint32(34).string(message.nonce);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MsgStructOreRefineryComplete {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgStructOreRefineryComplete();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.creator = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.structId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.proof = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.nonce = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MsgStructOreRefineryComplete {
    return {
      creator: isSet(object.creator) ? globalThis.String(object.creator) : "",
      structId: isSet(object.structId) ? globalThis.String(object.structId) : "",
      proof: isSet(object.proof) ? globalThis.String(object.proof) : "",
      nonce: isSet(object.nonce) ? globalThis.String(object.nonce) : "",
    };
  },

  toJSON(message: MsgStructOreRefineryComplete): unknown {
    const obj: any = {};
    if (message.creator !== "") {
      obj.creator = message.creator;
    }
    if (message.structId !== "") {
      obj.structId = message.structId;
    }
    if (message.proof !== "") {
      obj.proof = message.proof;
    }
    if (message.nonce !== "") {
      obj.nonce = message.nonce;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<MsgStructOreRefineryComplete>, I>>(base?: I): MsgStructOreRefineryComplete {
    return MsgStructOreRefineryComplete.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MsgStructOreRefineryComplete>, I>>(object: I): MsgStructOreRefineryComplete {
    const message = createBaseMsgStructOreRefineryComplete();
    message.creator = object.creator ?? "";
    message.structId = object.structId ?? "";
    message.proof = object.proof ?? "";
    message.nonce = object.nonce ?? "";
    return message;
  },
};

function createBaseMsgStructOreRefineryStatusResponse(): MsgStructOreRefineryStatusResponse {
  return { struct: undefined };
}

export const MsgStructOreRefineryStatusResponse: MessageFns<MsgStructOreRefineryStatusResponse> = {
  encode(message: MsgStructOreRefineryStatusResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.struct !== undefined) {
      Struct.encode(message.struct, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MsgStructOreRefineryStatusResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgStructOreRefineryStatusResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.struct = Struct.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MsgStructOreRefineryStatusResponse {
    return { struct: isSet(object.struct) ? Struct.fromJSON(object.struct) : undefined };
  },

  toJSON(message: MsgStructOreRefineryStatusResponse): unknown {
    const obj: any = {};
    if (message.struct !== undefined) {
      obj.struct = Struct.toJSON(message.struct);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<MsgStructOreRefineryStatusResponse>, I>>(
    base?: I,
  ): MsgStructOreRefineryStatusResponse {
    return MsgStructOreRefineryStatusResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MsgStructOreRefineryStatusResponse>, I>>(
    object: I,
  ): MsgStructOreRefineryStatusResponse {
    const message = createBaseMsgStructOreRefineryStatusResponse();
    message.struct = (object.struct !== undefined && object.struct !== null)
      ? Struct.fromPartial(object.struct)
      : undefined;
    return message;
  },
};

function createBaseMsgStructStorageStash(): MsgStructStorageStash {
  return { creator: "", structId: "", locationId: "", ambit: 0, slot: 0 };
}

export const MsgStructStorageStash: MessageFns<MsgStructStorageStash> = {
  encode(message: MsgStructStorageStash, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.creator !== "") {
      writer.uint32(10).string(message.creator);
    }
    if (message.structId !== "") {
      writer.uint32(18).string(message.structId);
    }
    if (message.locationId !== "") {
      writer.uint32(26).string(message.locationId);
    }
    if (message.ambit !== 0) {
      writer.uint32(32).int32(message.ambit);
    }
    if (message.slot !== 0) {
      writer.uint32(40).uint64(message.slot);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MsgStructStorageStash {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgStructStorageStash();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.creator = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.structId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.locationId = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.ambit = reader.int32() as any;
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.slot = longToNumber(reader.uint64());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MsgStructStorageStash {
    return {
      creator: isSet(object.creator) ? globalThis.String(object.creator) : "",
      structId: isSet(object.structId) ? globalThis.String(object.structId) : "",
      locationId: isSet(object.locationId) ? globalThis.String(object.locationId) : "",
      ambit: isSet(object.ambit) ? ambitFromJSON(object.ambit) : 0,
      slot: isSet(object.slot) ? globalThis.Number(object.slot) : 0,
    };
  },

  toJSON(message: MsgStructStorageStash): unknown {
    const obj: any = {};
    if (message.creator !== "") {
      obj.creator = message.creator;
    }
    if (message.structId !== "") {
      obj.structId = message.structId;
    }
    if (message.locationId !== "") {
      obj.locationId = message.locationId;
    }
    if (message.ambit !== 0) {
      obj.ambit = ambitToJSON(message.ambit);
    }
    if (message.slot !== 0) {
      obj.slot = Math.round(message.slot);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<MsgStructStorageStash>, I>>(base?: I): MsgStructStorageStash {
    return MsgStructStorageStash.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MsgStructStorageStash>, I>>(object: I): MsgStructStorageStash {
    const message = createBaseMsgStructStorageStash();
    message.creator = object.creator ?? "";
    message.structId = object.structId ?? "";
    message.locationId = object.locationId ?? "";
    message.ambit = object.ambit ?? 0;
    message.slot = object.slot ?? 0;
    return message;
  },
};

function createBaseMsgStructStorageRecall(): MsgStructStorageRecall {
  return { creator: "", structId: "", locationId: "", ambit: 0, slot: 0, activate: false };
}

export const MsgStructStorageRecall: MessageFns<MsgStructStorageRecall> = {
  encode(message: MsgStructStorageRecall, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.creator !== "") {
      writer.uint32(10).string(message.creator);
    }
    if (message.structId !== "") {
      writer.uint32(18).string(message.structId);
    }
    if (message.locationId !== "") {
      writer.uint32(26).string(message.locationId);
    }
    if (message.ambit !== 0) {
      writer.uint32(32).int32(message.ambit);
    }
    if (message.slot !== 0) {
      writer.uint32(40).uint64(message.slot);
    }
    if (message.activate !== false) {
      writer.uint32(48).bool(message.activate);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MsgStructStorageRecall {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgStructStorageRecall();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.creator = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.structId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.locationId = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.ambit = reader.int32() as any;
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.slot = longToNumber(reader.uint64());
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.activate = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MsgStructStorageRecall {
    return {
      creator: isSet(object.creator) ? globalThis.String(object.creator) : "",
      structId: isSet(object.structId) ? globalThis.String(object.structId) : "",
      locationId: isSet(object.locationId) ? globalThis.String(object.locationId) : "",
      ambit: isSet(object.ambit) ? ambitFromJSON(object.ambit) : 0,
      slot: isSet(object.slot) ? globalThis.Number(object.slot) : 0,
      activate: isSet(object.activate) ? globalThis.Boolean(object.activate) : false,
    };
  },

  toJSON(message: MsgStructStorageRecall): unknown {
    const obj: any = {};
    if (message.creator !== "") {
      obj.creator = message.creator;
    }
    if (message.structId !== "") {
      obj.structId = message.structId;
    }
    if (message.locationId !== "") {
      obj.locationId = message.locationId;
    }
    if (message.ambit !== 0) {
      obj.ambit = ambitToJSON(message.ambit);
    }
    if (message.slot !== 0) {
      obj.slot = Math.round(message.slot);
    }
    if (message.activate !== false) {
      obj.activate = message.activate;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<MsgStructStorageRecall>, I>>(base?: I): MsgStructStorageRecall {
    return MsgStructStorageRecall.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MsgStructStorageRecall>, I>>(object: I): MsgStructStorageRecall {
    const message = createBaseMsgStructStorageRecall();
    message.creator = object.creator ?? "";
    message.structId = object.structId ?? "";
    message.locationId = object.locationId ?? "";
    message.ambit = object.ambit ?? 0;
    message.slot = object.slot ?? 0;
    message.activate = object.activate ?? false;
    return message;
  },
};

function createBaseMsgSubstationCreate(): MsgSubstationCreate {
  return { creator: "", owner: "", allocationId: "" };
}

export const MsgSubstationCreate: MessageFns<MsgSubstationCreate> = {
  encode(message: MsgSubstationCreate, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.creator !== "") {
      writer.uint32(10).string(message.creator);
    }
    if (message.owner !== "") {
      writer.uint32(18).string(message.owner);
    }
    if (message.allocationId !== "") {
      writer.uint32(26).string(message.allocationId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MsgSubstationCreate {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgSubstationCreate();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.creator = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.owner = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.allocationId = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MsgSubstationCreate {
    return {
      creator: isSet(object.creator) ? globalThis.String(object.creator) : "",
      owner: isSet(object.owner) ? globalThis.String(object.owner) : "",
      allocationId: isSet(object.allocationId) ? globalThis.String(object.allocationId) : "",
    };
  },

  toJSON(message: MsgSubstationCreate): unknown {
    const obj: any = {};
    if (message.creator !== "") {
      obj.creator = message.creator;
    }
    if (message.owner !== "") {
      obj.owner = message.owner;
    }
    if (message.allocationId !== "") {
      obj.allocationId = message.allocationId;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<MsgSubstationCreate>, I>>(base?: I): MsgSubstationCreate {
    return MsgSubstationCreate.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MsgSubstationCreate>, I>>(object: I): MsgSubstationCreate {
    const message = createBaseMsgSubstationCreate();
    message.creator = object.creator ?? "";
    message.owner = object.owner ?? "";
    message.allocationId = object.allocationId ?? "";
    return message;
  },
};

function createBaseMsgSubstationCreateResponse(): MsgSubstationCreateResponse {
  return { substationId: "" };
}

export const MsgSubstationCreateResponse: MessageFns<MsgSubstationCreateResponse> = {
  encode(message: MsgSubstationCreateResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.substationId !== "") {
      writer.uint32(10).string(message.substationId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MsgSubstationCreateResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgSubstationCreateResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.substationId = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MsgSubstationCreateResponse {
    return { substationId: isSet(object.substationId) ? globalThis.String(object.substationId) : "" };
  },

  toJSON(message: MsgSubstationCreateResponse): unknown {
    const obj: any = {};
    if (message.substationId !== "") {
      obj.substationId = message.substationId;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<MsgSubstationCreateResponse>, I>>(base?: I): MsgSubstationCreateResponse {
    return MsgSubstationCreateResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MsgSubstationCreateResponse>, I>>(object: I): MsgSubstationCreateResponse {
    const message = createBaseMsgSubstationCreateResponse();
    message.substationId = object.substationId ?? "";
    return message;
  },
};

function createBaseMsgSubstationDelete(): MsgSubstationDelete {
  return { creator: "", substationId: "", migrationSubstationId: "" };
}

export const MsgSubstationDelete: MessageFns<MsgSubstationDelete> = {
  encode(message: MsgSubstationDelete, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.creator !== "") {
      writer.uint32(10).string(message.creator);
    }
    if (message.substationId !== "") {
      writer.uint32(18).string(message.substationId);
    }
    if (message.migrationSubstationId !== "") {
      writer.uint32(26).string(message.migrationSubstationId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MsgSubstationDelete {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgSubstationDelete();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.creator = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.substationId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.migrationSubstationId = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MsgSubstationDelete {
    return {
      creator: isSet(object.creator) ? globalThis.String(object.creator) : "",
      substationId: isSet(object.substationId) ? globalThis.String(object.substationId) : "",
      migrationSubstationId: isSet(object.migrationSubstationId) ? globalThis.String(object.migrationSubstationId) : "",
    };
  },

  toJSON(message: MsgSubstationDelete): unknown {
    const obj: any = {};
    if (message.creator !== "") {
      obj.creator = message.creator;
    }
    if (message.substationId !== "") {
      obj.substationId = message.substationId;
    }
    if (message.migrationSubstationId !== "") {
      obj.migrationSubstationId = message.migrationSubstationId;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<MsgSubstationDelete>, I>>(base?: I): MsgSubstationDelete {
    return MsgSubstationDelete.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MsgSubstationDelete>, I>>(object: I): MsgSubstationDelete {
    const message = createBaseMsgSubstationDelete();
    message.creator = object.creator ?? "";
    message.substationId = object.substationId ?? "";
    message.migrationSubstationId = object.migrationSubstationId ?? "";
    return message;
  },
};

function createBaseMsgSubstationDeleteResponse(): MsgSubstationDeleteResponse {
  return {};
}

export const MsgSubstationDeleteResponse: MessageFns<MsgSubstationDeleteResponse> = {
  encode(_: MsgSubstationDeleteResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MsgSubstationDeleteResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgSubstationDeleteResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): MsgSubstationDeleteResponse {
    return {};
  },

  toJSON(_: MsgSubstationDeleteResponse): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<MsgSubstationDeleteResponse>, I>>(base?: I): MsgSubstationDeleteResponse {
    return MsgSubstationDeleteResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MsgSubstationDeleteResponse>, I>>(_: I): MsgSubstationDeleteResponse {
    const message = createBaseMsgSubstationDeleteResponse();
    return message;
  },
};

function createBaseMsgSubstationAllocationConnect(): MsgSubstationAllocationConnect {
  return { creator: "", allocationId: "", destinationId: "" };
}

export const MsgSubstationAllocationConnect: MessageFns<MsgSubstationAllocationConnect> = {
  encode(message: MsgSubstationAllocationConnect, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.creator !== "") {
      writer.uint32(10).string(message.creator);
    }
    if (message.allocationId !== "") {
      writer.uint32(18).string(message.allocationId);
    }
    if (message.destinationId !== "") {
      writer.uint32(26).string(message.destinationId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MsgSubstationAllocationConnect {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgSubstationAllocationConnect();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.creator = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.allocationId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.destinationId = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MsgSubstationAllocationConnect {
    return {
      creator: isSet(object.creator) ? globalThis.String(object.creator) : "",
      allocationId: isSet(object.allocationId) ? globalThis.String(object.allocationId) : "",
      destinationId: isSet(object.destinationId) ? globalThis.String(object.destinationId) : "",
    };
  },

  toJSON(message: MsgSubstationAllocationConnect): unknown {
    const obj: any = {};
    if (message.creator !== "") {
      obj.creator = message.creator;
    }
    if (message.allocationId !== "") {
      obj.allocationId = message.allocationId;
    }
    if (message.destinationId !== "") {
      obj.destinationId = message.destinationId;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<MsgSubstationAllocationConnect>, I>>(base?: I): MsgSubstationAllocationConnect {
    return MsgSubstationAllocationConnect.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MsgSubstationAllocationConnect>, I>>(
    object: I,
  ): MsgSubstationAllocationConnect {
    const message = createBaseMsgSubstationAllocationConnect();
    message.creator = object.creator ?? "";
    message.allocationId = object.allocationId ?? "";
    message.destinationId = object.destinationId ?? "";
    return message;
  },
};

function createBaseMsgSubstationAllocationConnectResponse(): MsgSubstationAllocationConnectResponse {
  return {};
}

export const MsgSubstationAllocationConnectResponse: MessageFns<MsgSubstationAllocationConnectResponse> = {
  encode(_: MsgSubstationAllocationConnectResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MsgSubstationAllocationConnectResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgSubstationAllocationConnectResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): MsgSubstationAllocationConnectResponse {
    return {};
  },

  toJSON(_: MsgSubstationAllocationConnectResponse): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<MsgSubstationAllocationConnectResponse>, I>>(
    base?: I,
  ): MsgSubstationAllocationConnectResponse {
    return MsgSubstationAllocationConnectResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MsgSubstationAllocationConnectResponse>, I>>(
    _: I,
  ): MsgSubstationAllocationConnectResponse {
    const message = createBaseMsgSubstationAllocationConnectResponse();
    return message;
  },
};

function createBaseMsgSubstationAllocationDisconnect(): MsgSubstationAllocationDisconnect {
  return { creator: "", allocationId: "" };
}

export const MsgSubstationAllocationDisconnect: MessageFns<MsgSubstationAllocationDisconnect> = {
  encode(message: MsgSubstationAllocationDisconnect, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.creator !== "") {
      writer.uint32(10).string(message.creator);
    }
    if (message.allocationId !== "") {
      writer.uint32(18).string(message.allocationId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MsgSubstationAllocationDisconnect {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgSubstationAllocationDisconnect();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.creator = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.allocationId = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MsgSubstationAllocationDisconnect {
    return {
      creator: isSet(object.creator) ? globalThis.String(object.creator) : "",
      allocationId: isSet(object.allocationId) ? globalThis.String(object.allocationId) : "",
    };
  },

  toJSON(message: MsgSubstationAllocationDisconnect): unknown {
    const obj: any = {};
    if (message.creator !== "") {
      obj.creator = message.creator;
    }
    if (message.allocationId !== "") {
      obj.allocationId = message.allocationId;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<MsgSubstationAllocationDisconnect>, I>>(
    base?: I,
  ): MsgSubstationAllocationDisconnect {
    return MsgSubstationAllocationDisconnect.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MsgSubstationAllocationDisconnect>, I>>(
    object: I,
  ): MsgSubstationAllocationDisconnect {
    const message = createBaseMsgSubstationAllocationDisconnect();
    message.creator = object.creator ?? "";
    message.allocationId = object.allocationId ?? "";
    return message;
  },
};

function createBaseMsgSubstationAllocationDisconnectResponse(): MsgSubstationAllocationDisconnectResponse {
  return {};
}

export const MsgSubstationAllocationDisconnectResponse: MessageFns<MsgSubstationAllocationDisconnectResponse> = {
  encode(_: MsgSubstationAllocationDisconnectResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MsgSubstationAllocationDisconnectResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgSubstationAllocationDisconnectResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): MsgSubstationAllocationDisconnectResponse {
    return {};
  },

  toJSON(_: MsgSubstationAllocationDisconnectResponse): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<MsgSubstationAllocationDisconnectResponse>, I>>(
    base?: I,
  ): MsgSubstationAllocationDisconnectResponse {
    return MsgSubstationAllocationDisconnectResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MsgSubstationAllocationDisconnectResponse>, I>>(
    _: I,
  ): MsgSubstationAllocationDisconnectResponse {
    const message = createBaseMsgSubstationAllocationDisconnectResponse();
    return message;
  },
};

function createBaseMsgSubstationPlayerConnect(): MsgSubstationPlayerConnect {
  return { creator: "", substationId: "", playerId: "" };
}

export const MsgSubstationPlayerConnect: MessageFns<MsgSubstationPlayerConnect> = {
  encode(message: MsgSubstationPlayerConnect, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.creator !== "") {
      writer.uint32(10).string(message.creator);
    }
    if (message.substationId !== "") {
      writer.uint32(18).string(message.substationId);
    }
    if (message.playerId !== "") {
      writer.uint32(26).string(message.playerId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MsgSubstationPlayerConnect {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgSubstationPlayerConnect();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.creator = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.substationId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.playerId = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MsgSubstationPlayerConnect {
    return {
      creator: isSet(object.creator) ? globalThis.String(object.creator) : "",
      substationId: isSet(object.substationId) ? globalThis.String(object.substationId) : "",
      playerId: isSet(object.playerId) ? globalThis.String(object.playerId) : "",
    };
  },

  toJSON(message: MsgSubstationPlayerConnect): unknown {
    const obj: any = {};
    if (message.creator !== "") {
      obj.creator = message.creator;
    }
    if (message.substationId !== "") {
      obj.substationId = message.substationId;
    }
    if (message.playerId !== "") {
      obj.playerId = message.playerId;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<MsgSubstationPlayerConnect>, I>>(base?: I): MsgSubstationPlayerConnect {
    return MsgSubstationPlayerConnect.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MsgSubstationPlayerConnect>, I>>(object: I): MsgSubstationPlayerConnect {
    const message = createBaseMsgSubstationPlayerConnect();
    message.creator = object.creator ?? "";
    message.substationId = object.substationId ?? "";
    message.playerId = object.playerId ?? "";
    return message;
  },
};

function createBaseMsgSubstationPlayerConnectResponse(): MsgSubstationPlayerConnectResponse {
  return {};
}

export const MsgSubstationPlayerConnectResponse: MessageFns<MsgSubstationPlayerConnectResponse> = {
  encode(_: MsgSubstationPlayerConnectResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MsgSubstationPlayerConnectResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgSubstationPlayerConnectResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): MsgSubstationPlayerConnectResponse {
    return {};
  },

  toJSON(_: MsgSubstationPlayerConnectResponse): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<MsgSubstationPlayerConnectResponse>, I>>(
    base?: I,
  ): MsgSubstationPlayerConnectResponse {
    return MsgSubstationPlayerConnectResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MsgSubstationPlayerConnectResponse>, I>>(
    _: I,
  ): MsgSubstationPlayerConnectResponse {
    const message = createBaseMsgSubstationPlayerConnectResponse();
    return message;
  },
};

function createBaseMsgSubstationPlayerDisconnect(): MsgSubstationPlayerDisconnect {
  return { creator: "", playerId: "" };
}

export const MsgSubstationPlayerDisconnect: MessageFns<MsgSubstationPlayerDisconnect> = {
  encode(message: MsgSubstationPlayerDisconnect, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.creator !== "") {
      writer.uint32(10).string(message.creator);
    }
    if (message.playerId !== "") {
      writer.uint32(18).string(message.playerId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MsgSubstationPlayerDisconnect {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgSubstationPlayerDisconnect();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.creator = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.playerId = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MsgSubstationPlayerDisconnect {
    return {
      creator: isSet(object.creator) ? globalThis.String(object.creator) : "",
      playerId: isSet(object.playerId) ? globalThis.String(object.playerId) : "",
    };
  },

  toJSON(message: MsgSubstationPlayerDisconnect): unknown {
    const obj: any = {};
    if (message.creator !== "") {
      obj.creator = message.creator;
    }
    if (message.playerId !== "") {
      obj.playerId = message.playerId;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<MsgSubstationPlayerDisconnect>, I>>(base?: I): MsgSubstationPlayerDisconnect {
    return MsgSubstationPlayerDisconnect.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MsgSubstationPlayerDisconnect>, I>>(
    object: I,
  ): MsgSubstationPlayerDisconnect {
    const message = createBaseMsgSubstationPlayerDisconnect();
    message.creator = object.creator ?? "";
    message.playerId = object.playerId ?? "";
    return message;
  },
};

function createBaseMsgSubstationPlayerDisconnectResponse(): MsgSubstationPlayerDisconnectResponse {
  return {};
}

export const MsgSubstationPlayerDisconnectResponse: MessageFns<MsgSubstationPlayerDisconnectResponse> = {
  encode(_: MsgSubstationPlayerDisconnectResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MsgSubstationPlayerDisconnectResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgSubstationPlayerDisconnectResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): MsgSubstationPlayerDisconnectResponse {
    return {};
  },

  toJSON(_: MsgSubstationPlayerDisconnectResponse): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<MsgSubstationPlayerDisconnectResponse>, I>>(
    base?: I,
  ): MsgSubstationPlayerDisconnectResponse {
    return MsgSubstationPlayerDisconnectResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MsgSubstationPlayerDisconnectResponse>, I>>(
    _: I,
  ): MsgSubstationPlayerDisconnectResponse {
    const message = createBaseMsgSubstationPlayerDisconnectResponse();
    return message;
  },
};

function createBaseMsgSubstationPlayerMigrate(): MsgSubstationPlayerMigrate {
  return { creator: "", substationId: "", playerId: [] };
}

export const MsgSubstationPlayerMigrate: MessageFns<MsgSubstationPlayerMigrate> = {
  encode(message: MsgSubstationPlayerMigrate, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.creator !== "") {
      writer.uint32(10).string(message.creator);
    }
    if (message.substationId !== "") {
      writer.uint32(18).string(message.substationId);
    }
    for (const v of message.playerId) {
      writer.uint32(26).string(v!);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MsgSubstationPlayerMigrate {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgSubstationPlayerMigrate();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.creator = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.substationId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.playerId.push(reader.string());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MsgSubstationPlayerMigrate {
    return {
      creator: isSet(object.creator) ? globalThis.String(object.creator) : "",
      substationId: isSet(object.substationId) ? globalThis.String(object.substationId) : "",
      playerId: globalThis.Array.isArray(object?.playerId) ? object.playerId.map((e: any) => globalThis.String(e)) : [],
    };
  },

  toJSON(message: MsgSubstationPlayerMigrate): unknown {
    const obj: any = {};
    if (message.creator !== "") {
      obj.creator = message.creator;
    }
    if (message.substationId !== "") {
      obj.substationId = message.substationId;
    }
    if (message.playerId?.length) {
      obj.playerId = message.playerId;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<MsgSubstationPlayerMigrate>, I>>(base?: I): MsgSubstationPlayerMigrate {
    return MsgSubstationPlayerMigrate.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MsgSubstationPlayerMigrate>, I>>(object: I): MsgSubstationPlayerMigrate {
    const message = createBaseMsgSubstationPlayerMigrate();
    message.creator = object.creator ?? "";
    message.substationId = object.substationId ?? "";
    message.playerId = object.playerId?.map((e) => e) || [];
    return message;
  },
};

function createBaseMsgSubstationPlayerMigrateResponse(): MsgSubstationPlayerMigrateResponse {
  return {};
}

export const MsgSubstationPlayerMigrateResponse: MessageFns<MsgSubstationPlayerMigrateResponse> = {
  encode(_: MsgSubstationPlayerMigrateResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MsgSubstationPlayerMigrateResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgSubstationPlayerMigrateResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): MsgSubstationPlayerMigrateResponse {
    return {};
  },

  toJSON(_: MsgSubstationPlayerMigrateResponse): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<MsgSubstationPlayerMigrateResponse>, I>>(
    base?: I,
  ): MsgSubstationPlayerMigrateResponse {
    return MsgSubstationPlayerMigrateResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MsgSubstationPlayerMigrateResponse>, I>>(
    _: I,
  ): MsgSubstationPlayerMigrateResponse {
    const message = createBaseMsgSubstationPlayerMigrateResponse();
    return message;
  },
};

function createBaseMsgAgreementOpen(): MsgAgreementOpen {
  return { creator: "", providerId: "", duration: 0, capacity: 0 };
}

export const MsgAgreementOpen: MessageFns<MsgAgreementOpen> = {
  encode(message: MsgAgreementOpen, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.creator !== "") {
      writer.uint32(10).string(message.creator);
    }
    if (message.providerId !== "") {
      writer.uint32(18).string(message.providerId);
    }
    if (message.duration !== 0) {
      writer.uint32(24).uint64(message.duration);
    }
    if (message.capacity !== 0) {
      writer.uint32(32).uint64(message.capacity);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MsgAgreementOpen {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgAgreementOpen();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.creator = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.providerId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.duration = longToNumber(reader.uint64());
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.capacity = longToNumber(reader.uint64());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MsgAgreementOpen {
    return {
      creator: isSet(object.creator) ? globalThis.String(object.creator) : "",
      providerId: isSet(object.providerId) ? globalThis.String(object.providerId) : "",
      duration: isSet(object.duration) ? globalThis.Number(object.duration) : 0,
      capacity: isSet(object.capacity) ? globalThis.Number(object.capacity) : 0,
    };
  },

  toJSON(message: MsgAgreementOpen): unknown {
    const obj: any = {};
    if (message.creator !== "") {
      obj.creator = message.creator;
    }
    if (message.providerId !== "") {
      obj.providerId = message.providerId;
    }
    if (message.duration !== 0) {
      obj.duration = Math.round(message.duration);
    }
    if (message.capacity !== 0) {
      obj.capacity = Math.round(message.capacity);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<MsgAgreementOpen>, I>>(base?: I): MsgAgreementOpen {
    return MsgAgreementOpen.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MsgAgreementOpen>, I>>(object: I): MsgAgreementOpen {
    const message = createBaseMsgAgreementOpen();
    message.creator = object.creator ?? "";
    message.providerId = object.providerId ?? "";
    message.duration = object.duration ?? 0;
    message.capacity = object.capacity ?? 0;
    return message;
  },
};

function createBaseMsgAgreementClose(): MsgAgreementClose {
  return { creator: "", agreementId: "" };
}

export const MsgAgreementClose: MessageFns<MsgAgreementClose> = {
  encode(message: MsgAgreementClose, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.creator !== "") {
      writer.uint32(10).string(message.creator);
    }
    if (message.agreementId !== "") {
      writer.uint32(18).string(message.agreementId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MsgAgreementClose {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgAgreementClose();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.creator = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.agreementId = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MsgAgreementClose {
    return {
      creator: isSet(object.creator) ? globalThis.String(object.creator) : "",
      agreementId: isSet(object.agreementId) ? globalThis.String(object.agreementId) : "",
    };
  },

  toJSON(message: MsgAgreementClose): unknown {
    const obj: any = {};
    if (message.creator !== "") {
      obj.creator = message.creator;
    }
    if (message.agreementId !== "") {
      obj.agreementId = message.agreementId;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<MsgAgreementClose>, I>>(base?: I): MsgAgreementClose {
    return MsgAgreementClose.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MsgAgreementClose>, I>>(object: I): MsgAgreementClose {
    const message = createBaseMsgAgreementClose();
    message.creator = object.creator ?? "";
    message.agreementId = object.agreementId ?? "";
    return message;
  },
};

function createBaseMsgAgreementCapacityIncrease(): MsgAgreementCapacityIncrease {
  return { creator: "", agreementId: "", capacityIncrease: 0 };
}

export const MsgAgreementCapacityIncrease: MessageFns<MsgAgreementCapacityIncrease> = {
  encode(message: MsgAgreementCapacityIncrease, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.creator !== "") {
      writer.uint32(10).string(message.creator);
    }
    if (message.agreementId !== "") {
      writer.uint32(18).string(message.agreementId);
    }
    if (message.capacityIncrease !== 0) {
      writer.uint32(24).uint64(message.capacityIncrease);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MsgAgreementCapacityIncrease {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgAgreementCapacityIncrease();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.creator = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.agreementId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.capacityIncrease = longToNumber(reader.uint64());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MsgAgreementCapacityIncrease {
    return {
      creator: isSet(object.creator) ? globalThis.String(object.creator) : "",
      agreementId: isSet(object.agreementId) ? globalThis.String(object.agreementId) : "",
      capacityIncrease: isSet(object.capacityIncrease) ? globalThis.Number(object.capacityIncrease) : 0,
    };
  },

  toJSON(message: MsgAgreementCapacityIncrease): unknown {
    const obj: any = {};
    if (message.creator !== "") {
      obj.creator = message.creator;
    }
    if (message.agreementId !== "") {
      obj.agreementId = message.agreementId;
    }
    if (message.capacityIncrease !== 0) {
      obj.capacityIncrease = Math.round(message.capacityIncrease);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<MsgAgreementCapacityIncrease>, I>>(base?: I): MsgAgreementCapacityIncrease {
    return MsgAgreementCapacityIncrease.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MsgAgreementCapacityIncrease>, I>>(object: I): MsgAgreementCapacityIncrease {
    const message = createBaseMsgAgreementCapacityIncrease();
    message.creator = object.creator ?? "";
    message.agreementId = object.agreementId ?? "";
    message.capacityIncrease = object.capacityIncrease ?? 0;
    return message;
  },
};

function createBaseMsgAgreementCapacityDecrease(): MsgAgreementCapacityDecrease {
  return { creator: "", agreementId: "", capacityDecrease: 0 };
}

export const MsgAgreementCapacityDecrease: MessageFns<MsgAgreementCapacityDecrease> = {
  encode(message: MsgAgreementCapacityDecrease, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.creator !== "") {
      writer.uint32(10).string(message.creator);
    }
    if (message.agreementId !== "") {
      writer.uint32(18).string(message.agreementId);
    }
    if (message.capacityDecrease !== 0) {
      writer.uint32(24).uint64(message.capacityDecrease);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MsgAgreementCapacityDecrease {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgAgreementCapacityDecrease();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.creator = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.agreementId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.capacityDecrease = longToNumber(reader.uint64());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MsgAgreementCapacityDecrease {
    return {
      creator: isSet(object.creator) ? globalThis.String(object.creator) : "",
      agreementId: isSet(object.agreementId) ? globalThis.String(object.agreementId) : "",
      capacityDecrease: isSet(object.capacityDecrease) ? globalThis.Number(object.capacityDecrease) : 0,
    };
  },

  toJSON(message: MsgAgreementCapacityDecrease): unknown {
    const obj: any = {};
    if (message.creator !== "") {
      obj.creator = message.creator;
    }
    if (message.agreementId !== "") {
      obj.agreementId = message.agreementId;
    }
    if (message.capacityDecrease !== 0) {
      obj.capacityDecrease = Math.round(message.capacityDecrease);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<MsgAgreementCapacityDecrease>, I>>(base?: I): MsgAgreementCapacityDecrease {
    return MsgAgreementCapacityDecrease.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MsgAgreementCapacityDecrease>, I>>(object: I): MsgAgreementCapacityDecrease {
    const message = createBaseMsgAgreementCapacityDecrease();
    message.creator = object.creator ?? "";
    message.agreementId = object.agreementId ?? "";
    message.capacityDecrease = object.capacityDecrease ?? 0;
    return message;
  },
};

function createBaseMsgAgreementDurationIncrease(): MsgAgreementDurationIncrease {
  return { creator: "", agreementId: "", durationIncrease: 0 };
}

export const MsgAgreementDurationIncrease: MessageFns<MsgAgreementDurationIncrease> = {
  encode(message: MsgAgreementDurationIncrease, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.creator !== "") {
      writer.uint32(10).string(message.creator);
    }
    if (message.agreementId !== "") {
      writer.uint32(18).string(message.agreementId);
    }
    if (message.durationIncrease !== 0) {
      writer.uint32(24).uint64(message.durationIncrease);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MsgAgreementDurationIncrease {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgAgreementDurationIncrease();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.creator = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.agreementId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.durationIncrease = longToNumber(reader.uint64());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MsgAgreementDurationIncrease {
    return {
      creator: isSet(object.creator) ? globalThis.String(object.creator) : "",
      agreementId: isSet(object.agreementId) ? globalThis.String(object.agreementId) : "",
      durationIncrease: isSet(object.durationIncrease) ? globalThis.Number(object.durationIncrease) : 0,
    };
  },

  toJSON(message: MsgAgreementDurationIncrease): unknown {
    const obj: any = {};
    if (message.creator !== "") {
      obj.creator = message.creator;
    }
    if (message.agreementId !== "") {
      obj.agreementId = message.agreementId;
    }
    if (message.durationIncrease !== 0) {
      obj.durationIncrease = Math.round(message.durationIncrease);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<MsgAgreementDurationIncrease>, I>>(base?: I): MsgAgreementDurationIncrease {
    return MsgAgreementDurationIncrease.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MsgAgreementDurationIncrease>, I>>(object: I): MsgAgreementDurationIncrease {
    const message = createBaseMsgAgreementDurationIncrease();
    message.creator = object.creator ?? "";
    message.agreementId = object.agreementId ?? "";
    message.durationIncrease = object.durationIncrease ?? 0;
    return message;
  },
};

function createBaseMsgAgreementResponse(): MsgAgreementResponse {
  return {};
}

export const MsgAgreementResponse: MessageFns<MsgAgreementResponse> = {
  encode(_: MsgAgreementResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MsgAgreementResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgAgreementResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): MsgAgreementResponse {
    return {};
  },

  toJSON(_: MsgAgreementResponse): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<MsgAgreementResponse>, I>>(base?: I): MsgAgreementResponse {
    return MsgAgreementResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MsgAgreementResponse>, I>>(_: I): MsgAgreementResponse {
    const message = createBaseMsgAgreementResponse();
    return message;
  },
};

function createBaseMsgProviderCreate(): MsgProviderCreate {
  return {
    creator: "",
    substationId: "",
    rate: undefined,
    accessPolicy: 0,
    providerCancellationPenalty: "",
    consumerCancellationPenalty: "",
    capacityMinimum: 0,
    capacityMaximum: 0,
    durationMinimum: 0,
    durationMaximum: 0,
  };
}

export const MsgProviderCreate: MessageFns<MsgProviderCreate> = {
  encode(message: MsgProviderCreate, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.creator !== "") {
      writer.uint32(10).string(message.creator);
    }
    if (message.substationId !== "") {
      writer.uint32(18).string(message.substationId);
    }
    if (message.rate !== undefined) {
      Coin.encode(message.rate, writer.uint32(26).fork()).join();
    }
    if (message.accessPolicy !== 0) {
      writer.uint32(32).int32(message.accessPolicy);
    }
    if (message.providerCancellationPenalty !== "") {
      writer.uint32(42).string(message.providerCancellationPenalty);
    }
    if (message.consumerCancellationPenalty !== "") {
      writer.uint32(50).string(message.consumerCancellationPenalty);
    }
    if (message.capacityMinimum !== 0) {
      writer.uint32(56).uint64(message.capacityMinimum);
    }
    if (message.capacityMaximum !== 0) {
      writer.uint32(64).uint64(message.capacityMaximum);
    }
    if (message.durationMinimum !== 0) {
      writer.uint32(72).uint64(message.durationMinimum);
    }
    if (message.durationMaximum !== 0) {
      writer.uint32(80).uint64(message.durationMaximum);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MsgProviderCreate {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgProviderCreate();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.creator = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.substationId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.rate = Coin.decode(reader, reader.uint32());
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.accessPolicy = reader.int32() as any;
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.providerCancellationPenalty = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.consumerCancellationPenalty = reader.string();
          continue;
        }
        case 7: {
          if (tag !== 56) {
            break;
          }

          message.capacityMinimum = longToNumber(reader.uint64());
          continue;
        }
        case 8: {
          if (tag !== 64) {
            break;
          }

          message.capacityMaximum = longToNumber(reader.uint64());
          continue;
        }
        case 9: {
          if (tag !== 72) {
            break;
          }

          message.durationMinimum = longToNumber(reader.uint64());
          continue;
        }
        case 10: {
          if (tag !== 80) {
            break;
          }

          message.durationMaximum = longToNumber(reader.uint64());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MsgProviderCreate {
    return {
      creator: isSet(object.creator) ? globalThis.String(object.creator) : "",
      substationId: isSet(object.substationId) ? globalThis.String(object.substationId) : "",
      rate: isSet(object.rate) ? Coin.fromJSON(object.rate) : undefined,
      accessPolicy: isSet(object.accessPolicy) ? providerAccessPolicyFromJSON(object.accessPolicy) : 0,
      providerCancellationPenalty: isSet(object.providerCancellationPenalty)
        ? globalThis.String(object.providerCancellationPenalty)
        : "",
      consumerCancellationPenalty: isSet(object.consumerCancellationPenalty)
        ? globalThis.String(object.consumerCancellationPenalty)
        : "",
      capacityMinimum: isSet(object.capacityMinimum) ? globalThis.Number(object.capacityMinimum) : 0,
      capacityMaximum: isSet(object.capacityMaximum) ? globalThis.Number(object.capacityMaximum) : 0,
      durationMinimum: isSet(object.durationMinimum) ? globalThis.Number(object.durationMinimum) : 0,
      durationMaximum: isSet(object.durationMaximum) ? globalThis.Number(object.durationMaximum) : 0,
    };
  },

  toJSON(message: MsgProviderCreate): unknown {
    const obj: any = {};
    if (message.creator !== "") {
      obj.creator = message.creator;
    }
    if (message.substationId !== "") {
      obj.substationId = message.substationId;
    }
    if (message.rate !== undefined) {
      obj.rate = Coin.toJSON(message.rate);
    }
    if (message.accessPolicy !== 0) {
      obj.accessPolicy = providerAccessPolicyToJSON(message.accessPolicy);
    }
    if (message.providerCancellationPenalty !== "") {
      obj.providerCancellationPenalty = message.providerCancellationPenalty;
    }
    if (message.consumerCancellationPenalty !== "") {
      obj.consumerCancellationPenalty = message.consumerCancellationPenalty;
    }
    if (message.capacityMinimum !== 0) {
      obj.capacityMinimum = Math.round(message.capacityMinimum);
    }
    if (message.capacityMaximum !== 0) {
      obj.capacityMaximum = Math.round(message.capacityMaximum);
    }
    if (message.durationMinimum !== 0) {
      obj.durationMinimum = Math.round(message.durationMinimum);
    }
    if (message.durationMaximum !== 0) {
      obj.durationMaximum = Math.round(message.durationMaximum);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<MsgProviderCreate>, I>>(base?: I): MsgProviderCreate {
    return MsgProviderCreate.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MsgProviderCreate>, I>>(object: I): MsgProviderCreate {
    const message = createBaseMsgProviderCreate();
    message.creator = object.creator ?? "";
    message.substationId = object.substationId ?? "";
    message.rate = (object.rate !== undefined && object.rate !== null) ? Coin.fromPartial(object.rate) : undefined;
    message.accessPolicy = object.accessPolicy ?? 0;
    message.providerCancellationPenalty = object.providerCancellationPenalty ?? "";
    message.consumerCancellationPenalty = object.consumerCancellationPenalty ?? "";
    message.capacityMinimum = object.capacityMinimum ?? 0;
    message.capacityMaximum = object.capacityMaximum ?? 0;
    message.durationMinimum = object.durationMinimum ?? 0;
    message.durationMaximum = object.durationMaximum ?? 0;
    return message;
  },
};

function createBaseMsgProviderWithdrawBalance(): MsgProviderWithdrawBalance {
  return { creator: "", providerId: "", destinationAddress: "" };
}

export const MsgProviderWithdrawBalance: MessageFns<MsgProviderWithdrawBalance> = {
  encode(message: MsgProviderWithdrawBalance, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.creator !== "") {
      writer.uint32(10).string(message.creator);
    }
    if (message.providerId !== "") {
      writer.uint32(18).string(message.providerId);
    }
    if (message.destinationAddress !== "") {
      writer.uint32(26).string(message.destinationAddress);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MsgProviderWithdrawBalance {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgProviderWithdrawBalance();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.creator = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.providerId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.destinationAddress = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MsgProviderWithdrawBalance {
    return {
      creator: isSet(object.creator) ? globalThis.String(object.creator) : "",
      providerId: isSet(object.providerId) ? globalThis.String(object.providerId) : "",
      destinationAddress: isSet(object.destinationAddress) ? globalThis.String(object.destinationAddress) : "",
    };
  },

  toJSON(message: MsgProviderWithdrawBalance): unknown {
    const obj: any = {};
    if (message.creator !== "") {
      obj.creator = message.creator;
    }
    if (message.providerId !== "") {
      obj.providerId = message.providerId;
    }
    if (message.destinationAddress !== "") {
      obj.destinationAddress = message.destinationAddress;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<MsgProviderWithdrawBalance>, I>>(base?: I): MsgProviderWithdrawBalance {
    return MsgProviderWithdrawBalance.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MsgProviderWithdrawBalance>, I>>(object: I): MsgProviderWithdrawBalance {
    const message = createBaseMsgProviderWithdrawBalance();
    message.creator = object.creator ?? "";
    message.providerId = object.providerId ?? "";
    message.destinationAddress = object.destinationAddress ?? "";
    return message;
  },
};

function createBaseMsgProviderUpdateCapacityMinimum(): MsgProviderUpdateCapacityMinimum {
  return { creator: "", providerId: "", newMinimumCapacity: 0 };
}

export const MsgProviderUpdateCapacityMinimum: MessageFns<MsgProviderUpdateCapacityMinimum> = {
  encode(message: MsgProviderUpdateCapacityMinimum, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.creator !== "") {
      writer.uint32(10).string(message.creator);
    }
    if (message.providerId !== "") {
      writer.uint32(18).string(message.providerId);
    }
    if (message.newMinimumCapacity !== 0) {
      writer.uint32(24).uint64(message.newMinimumCapacity);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MsgProviderUpdateCapacityMinimum {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgProviderUpdateCapacityMinimum();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.creator = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.providerId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.newMinimumCapacity = longToNumber(reader.uint64());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MsgProviderUpdateCapacityMinimum {
    return {
      creator: isSet(object.creator) ? globalThis.String(object.creator) : "",
      providerId: isSet(object.providerId) ? globalThis.String(object.providerId) : "",
      newMinimumCapacity: isSet(object.newMinimumCapacity) ? globalThis.Number(object.newMinimumCapacity) : 0,
    };
  },

  toJSON(message: MsgProviderUpdateCapacityMinimum): unknown {
    const obj: any = {};
    if (message.creator !== "") {
      obj.creator = message.creator;
    }
    if (message.providerId !== "") {
      obj.providerId = message.providerId;
    }
    if (message.newMinimumCapacity !== 0) {
      obj.newMinimumCapacity = Math.round(message.newMinimumCapacity);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<MsgProviderUpdateCapacityMinimum>, I>>(
    base?: I,
  ): MsgProviderUpdateCapacityMinimum {
    return MsgProviderUpdateCapacityMinimum.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MsgProviderUpdateCapacityMinimum>, I>>(
    object: I,
  ): MsgProviderUpdateCapacityMinimum {
    const message = createBaseMsgProviderUpdateCapacityMinimum();
    message.creator = object.creator ?? "";
    message.providerId = object.providerId ?? "";
    message.newMinimumCapacity = object.newMinimumCapacity ?? 0;
    return message;
  },
};

function createBaseMsgProviderUpdateCapacityMaximum(): MsgProviderUpdateCapacityMaximum {
  return { creator: "", providerId: "", newMaximumCapacity: 0 };
}

export const MsgProviderUpdateCapacityMaximum: MessageFns<MsgProviderUpdateCapacityMaximum> = {
  encode(message: MsgProviderUpdateCapacityMaximum, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.creator !== "") {
      writer.uint32(10).string(message.creator);
    }
    if (message.providerId !== "") {
      writer.uint32(18).string(message.providerId);
    }
    if (message.newMaximumCapacity !== 0) {
      writer.uint32(24).uint64(message.newMaximumCapacity);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MsgProviderUpdateCapacityMaximum {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgProviderUpdateCapacityMaximum();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.creator = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.providerId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.newMaximumCapacity = longToNumber(reader.uint64());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MsgProviderUpdateCapacityMaximum {
    return {
      creator: isSet(object.creator) ? globalThis.String(object.creator) : "",
      providerId: isSet(object.providerId) ? globalThis.String(object.providerId) : "",
      newMaximumCapacity: isSet(object.newMaximumCapacity) ? globalThis.Number(object.newMaximumCapacity) : 0,
    };
  },

  toJSON(message: MsgProviderUpdateCapacityMaximum): unknown {
    const obj: any = {};
    if (message.creator !== "") {
      obj.creator = message.creator;
    }
    if (message.providerId !== "") {
      obj.providerId = message.providerId;
    }
    if (message.newMaximumCapacity !== 0) {
      obj.newMaximumCapacity = Math.round(message.newMaximumCapacity);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<MsgProviderUpdateCapacityMaximum>, I>>(
    base?: I,
  ): MsgProviderUpdateCapacityMaximum {
    return MsgProviderUpdateCapacityMaximum.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MsgProviderUpdateCapacityMaximum>, I>>(
    object: I,
  ): MsgProviderUpdateCapacityMaximum {
    const message = createBaseMsgProviderUpdateCapacityMaximum();
    message.creator = object.creator ?? "";
    message.providerId = object.providerId ?? "";
    message.newMaximumCapacity = object.newMaximumCapacity ?? 0;
    return message;
  },
};

function createBaseMsgProviderUpdateDurationMinimum(): MsgProviderUpdateDurationMinimum {
  return { creator: "", providerId: "", newMinimumDuration: 0 };
}

export const MsgProviderUpdateDurationMinimum: MessageFns<MsgProviderUpdateDurationMinimum> = {
  encode(message: MsgProviderUpdateDurationMinimum, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.creator !== "") {
      writer.uint32(10).string(message.creator);
    }
    if (message.providerId !== "") {
      writer.uint32(18).string(message.providerId);
    }
    if (message.newMinimumDuration !== 0) {
      writer.uint32(24).uint64(message.newMinimumDuration);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MsgProviderUpdateDurationMinimum {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgProviderUpdateDurationMinimum();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.creator = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.providerId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.newMinimumDuration = longToNumber(reader.uint64());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MsgProviderUpdateDurationMinimum {
    return {
      creator: isSet(object.creator) ? globalThis.String(object.creator) : "",
      providerId: isSet(object.providerId) ? globalThis.String(object.providerId) : "",
      newMinimumDuration: isSet(object.newMinimumDuration) ? globalThis.Number(object.newMinimumDuration) : 0,
    };
  },

  toJSON(message: MsgProviderUpdateDurationMinimum): unknown {
    const obj: any = {};
    if (message.creator !== "") {
      obj.creator = message.creator;
    }
    if (message.providerId !== "") {
      obj.providerId = message.providerId;
    }
    if (message.newMinimumDuration !== 0) {
      obj.newMinimumDuration = Math.round(message.newMinimumDuration);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<MsgProviderUpdateDurationMinimum>, I>>(
    base?: I,
  ): MsgProviderUpdateDurationMinimum {
    return MsgProviderUpdateDurationMinimum.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MsgProviderUpdateDurationMinimum>, I>>(
    object: I,
  ): MsgProviderUpdateDurationMinimum {
    const message = createBaseMsgProviderUpdateDurationMinimum();
    message.creator = object.creator ?? "";
    message.providerId = object.providerId ?? "";
    message.newMinimumDuration = object.newMinimumDuration ?? 0;
    return message;
  },
};

function createBaseMsgProviderUpdateDurationMaximum(): MsgProviderUpdateDurationMaximum {
  return { creator: "", providerId: "", newMaximumDuration: 0 };
}

export const MsgProviderUpdateDurationMaximum: MessageFns<MsgProviderUpdateDurationMaximum> = {
  encode(message: MsgProviderUpdateDurationMaximum, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.creator !== "") {
      writer.uint32(10).string(message.creator);
    }
    if (message.providerId !== "") {
      writer.uint32(18).string(message.providerId);
    }
    if (message.newMaximumDuration !== 0) {
      writer.uint32(24).uint64(message.newMaximumDuration);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MsgProviderUpdateDurationMaximum {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgProviderUpdateDurationMaximum();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.creator = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.providerId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.newMaximumDuration = longToNumber(reader.uint64());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MsgProviderUpdateDurationMaximum {
    return {
      creator: isSet(object.creator) ? globalThis.String(object.creator) : "",
      providerId: isSet(object.providerId) ? globalThis.String(object.providerId) : "",
      newMaximumDuration: isSet(object.newMaximumDuration) ? globalThis.Number(object.newMaximumDuration) : 0,
    };
  },

  toJSON(message: MsgProviderUpdateDurationMaximum): unknown {
    const obj: any = {};
    if (message.creator !== "") {
      obj.creator = message.creator;
    }
    if (message.providerId !== "") {
      obj.providerId = message.providerId;
    }
    if (message.newMaximumDuration !== 0) {
      obj.newMaximumDuration = Math.round(message.newMaximumDuration);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<MsgProviderUpdateDurationMaximum>, I>>(
    base?: I,
  ): MsgProviderUpdateDurationMaximum {
    return MsgProviderUpdateDurationMaximum.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MsgProviderUpdateDurationMaximum>, I>>(
    object: I,
  ): MsgProviderUpdateDurationMaximum {
    const message = createBaseMsgProviderUpdateDurationMaximum();
    message.creator = object.creator ?? "";
    message.providerId = object.providerId ?? "";
    message.newMaximumDuration = object.newMaximumDuration ?? 0;
    return message;
  },
};

function createBaseMsgProviderUpdateAccessPolicy(): MsgProviderUpdateAccessPolicy {
  return { creator: "", providerId: "", accessPolicy: 0 };
}

export const MsgProviderUpdateAccessPolicy: MessageFns<MsgProviderUpdateAccessPolicy> = {
  encode(message: MsgProviderUpdateAccessPolicy, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.creator !== "") {
      writer.uint32(10).string(message.creator);
    }
    if (message.providerId !== "") {
      writer.uint32(18).string(message.providerId);
    }
    if (message.accessPolicy !== 0) {
      writer.uint32(24).int32(message.accessPolicy);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MsgProviderUpdateAccessPolicy {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgProviderUpdateAccessPolicy();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.creator = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.providerId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.accessPolicy = reader.int32() as any;
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MsgProviderUpdateAccessPolicy {
    return {
      creator: isSet(object.creator) ? globalThis.String(object.creator) : "",
      providerId: isSet(object.providerId) ? globalThis.String(object.providerId) : "",
      accessPolicy: isSet(object.accessPolicy) ? providerAccessPolicyFromJSON(object.accessPolicy) : 0,
    };
  },

  toJSON(message: MsgProviderUpdateAccessPolicy): unknown {
    const obj: any = {};
    if (message.creator !== "") {
      obj.creator = message.creator;
    }
    if (message.providerId !== "") {
      obj.providerId = message.providerId;
    }
    if (message.accessPolicy !== 0) {
      obj.accessPolicy = providerAccessPolicyToJSON(message.accessPolicy);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<MsgProviderUpdateAccessPolicy>, I>>(base?: I): MsgProviderUpdateAccessPolicy {
    return MsgProviderUpdateAccessPolicy.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MsgProviderUpdateAccessPolicy>, I>>(
    object: I,
  ): MsgProviderUpdateAccessPolicy {
    const message = createBaseMsgProviderUpdateAccessPolicy();
    message.creator = object.creator ?? "";
    message.providerId = object.providerId ?? "";
    message.accessPolicy = object.accessPolicy ?? 0;
    return message;
  },
};

function createBaseMsgProviderGuildGrant(): MsgProviderGuildGrant {
  return { creator: "", providerId: "", guildId: [] };
}

export const MsgProviderGuildGrant: MessageFns<MsgProviderGuildGrant> = {
  encode(message: MsgProviderGuildGrant, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.creator !== "") {
      writer.uint32(10).string(message.creator);
    }
    if (message.providerId !== "") {
      writer.uint32(18).string(message.providerId);
    }
    for (const v of message.guildId) {
      writer.uint32(26).string(v!);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MsgProviderGuildGrant {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgProviderGuildGrant();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.creator = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.providerId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.guildId.push(reader.string());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MsgProviderGuildGrant {
    return {
      creator: isSet(object.creator) ? globalThis.String(object.creator) : "",
      providerId: isSet(object.providerId) ? globalThis.String(object.providerId) : "",
      guildId: globalThis.Array.isArray(object?.guildId) ? object.guildId.map((e: any) => globalThis.String(e)) : [],
    };
  },

  toJSON(message: MsgProviderGuildGrant): unknown {
    const obj: any = {};
    if (message.creator !== "") {
      obj.creator = message.creator;
    }
    if (message.providerId !== "") {
      obj.providerId = message.providerId;
    }
    if (message.guildId?.length) {
      obj.guildId = message.guildId;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<MsgProviderGuildGrant>, I>>(base?: I): MsgProviderGuildGrant {
    return MsgProviderGuildGrant.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MsgProviderGuildGrant>, I>>(object: I): MsgProviderGuildGrant {
    const message = createBaseMsgProviderGuildGrant();
    message.creator = object.creator ?? "";
    message.providerId = object.providerId ?? "";
    message.guildId = object.guildId?.map((e) => e) || [];
    return message;
  },
};

function createBaseMsgProviderGuildRevoke(): MsgProviderGuildRevoke {
  return { creator: "", providerId: "", guildId: [] };
}

export const MsgProviderGuildRevoke: MessageFns<MsgProviderGuildRevoke> = {
  encode(message: MsgProviderGuildRevoke, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.creator !== "") {
      writer.uint32(10).string(message.creator);
    }
    if (message.providerId !== "") {
      writer.uint32(18).string(message.providerId);
    }
    for (const v of message.guildId) {
      writer.uint32(26).string(v!);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MsgProviderGuildRevoke {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgProviderGuildRevoke();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.creator = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.providerId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.guildId.push(reader.string());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MsgProviderGuildRevoke {
    return {
      creator: isSet(object.creator) ? globalThis.String(object.creator) : "",
      providerId: isSet(object.providerId) ? globalThis.String(object.providerId) : "",
      guildId: globalThis.Array.isArray(object?.guildId) ? object.guildId.map((e: any) => globalThis.String(e)) : [],
    };
  },

  toJSON(message: MsgProviderGuildRevoke): unknown {
    const obj: any = {};
    if (message.creator !== "") {
      obj.creator = message.creator;
    }
    if (message.providerId !== "") {
      obj.providerId = message.providerId;
    }
    if (message.guildId?.length) {
      obj.guildId = message.guildId;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<MsgProviderGuildRevoke>, I>>(base?: I): MsgProviderGuildRevoke {
    return MsgProviderGuildRevoke.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MsgProviderGuildRevoke>, I>>(object: I): MsgProviderGuildRevoke {
    const message = createBaseMsgProviderGuildRevoke();
    message.creator = object.creator ?? "";
    message.providerId = object.providerId ?? "";
    message.guildId = object.guildId?.map((e) => e) || [];
    return message;
  },
};

function createBaseMsgProviderDelete(): MsgProviderDelete {
  return { creator: "", providerId: "" };
}

export const MsgProviderDelete: MessageFns<MsgProviderDelete> = {
  encode(message: MsgProviderDelete, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.creator !== "") {
      writer.uint32(10).string(message.creator);
    }
    if (message.providerId !== "") {
      writer.uint32(18).string(message.providerId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MsgProviderDelete {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgProviderDelete();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.creator = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.providerId = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MsgProviderDelete {
    return {
      creator: isSet(object.creator) ? globalThis.String(object.creator) : "",
      providerId: isSet(object.providerId) ? globalThis.String(object.providerId) : "",
    };
  },

  toJSON(message: MsgProviderDelete): unknown {
    const obj: any = {};
    if (message.creator !== "") {
      obj.creator = message.creator;
    }
    if (message.providerId !== "") {
      obj.providerId = message.providerId;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<MsgProviderDelete>, I>>(base?: I): MsgProviderDelete {
    return MsgProviderDelete.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MsgProviderDelete>, I>>(object: I): MsgProviderDelete {
    const message = createBaseMsgProviderDelete();
    message.creator = object.creator ?? "";
    message.providerId = object.providerId ?? "";
    return message;
  },
};

function createBaseMsgProviderResponse(): MsgProviderResponse {
  return {};
}

export const MsgProviderResponse: MessageFns<MsgProviderResponse> = {
  encode(_: MsgProviderResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MsgProviderResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgProviderResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): MsgProviderResponse {
    return {};
  },

  toJSON(_: MsgProviderResponse): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<MsgProviderResponse>, I>>(base?: I): MsgProviderResponse {
    return MsgProviderResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MsgProviderResponse>, I>>(_: I): MsgProviderResponse {
    const message = createBaseMsgProviderResponse();
    return message;
  },
};

/** Msg defines the Msg service. */
export interface Msg {
  /**
   * UpdateParams defines a (governance) operation for updating the module
   * parameters. The authority defaults to the x/gov module account.
   */
  UpdateParams(request: MsgUpdateParams): Promise<MsgUpdateParamsResponse>;
  AddressRegister(request: MsgAddressRegister): Promise<MsgAddressRegisterResponse>;
  AddressRevoke(request: MsgAddressRevoke): Promise<MsgAddressRevokeResponse>;
  AgreementOpen(request: MsgAgreementOpen): Promise<MsgAgreementResponse>;
  AgreementClose(request: MsgAgreementClose): Promise<MsgAgreementResponse>;
  AgreementCapacityIncrease(request: MsgAgreementCapacityIncrease): Promise<MsgAgreementResponse>;
  AgreementCapacityDecrease(request: MsgAgreementCapacityDecrease): Promise<MsgAgreementResponse>;
  AgreementDurationIncrease(request: MsgAgreementDurationIncrease): Promise<MsgAgreementResponse>;
  AllocationCreate(request: MsgAllocationCreate): Promise<MsgAllocationCreateResponse>;
  AllocationDelete(request: MsgAllocationDelete): Promise<MsgAllocationDeleteResponse>;
  AllocationUpdate(request: MsgAllocationUpdate): Promise<MsgAllocationUpdateResponse>;
  AllocationTransfer(request: MsgAllocationTransfer): Promise<MsgAllocationTransferResponse>;
  FleetMove(request: MsgFleetMove): Promise<MsgFleetMoveResponse>;
  GuildCreate(request: MsgGuildCreate): Promise<MsgGuildCreateResponse>;
  GuildBankMint(request: MsgGuildBankMint): Promise<MsgGuildBankMintResponse>;
  GuildBankRedeem(request: MsgGuildBankRedeem): Promise<MsgGuildBankRedeemResponse>;
  GuildBankConfiscateAndBurn(request: MsgGuildBankConfiscateAndBurn): Promise<MsgGuildBankConfiscateAndBurnResponse>;
  GuildUpdateOwnerId(request: MsgGuildUpdateOwnerId): Promise<MsgGuildUpdateResponse>;
  GuildUpdateEntrySubstationId(request: MsgGuildUpdateEntrySubstationId): Promise<MsgGuildUpdateResponse>;
  GuildUpdateEndpoint(request: MsgGuildUpdateEndpoint): Promise<MsgGuildUpdateResponse>;
  GuildUpdateJoinInfusionMinimum(request: MsgGuildUpdateJoinInfusionMinimum): Promise<MsgGuildUpdateResponse>;
  GuildUpdateJoinInfusionMinimumBypassByInvite(
    request: MsgGuildUpdateJoinInfusionMinimumBypassByInvite,
  ): Promise<MsgGuildUpdateResponse>;
  GuildUpdateJoinInfusionMinimumBypassByRequest(
    request: MsgGuildUpdateJoinInfusionMinimumBypassByRequest,
  ): Promise<MsgGuildUpdateResponse>;
  GuildMembershipInvite(request: MsgGuildMembershipInvite): Promise<MsgGuildMembershipResponse>;
  GuildMembershipInviteApprove(request: MsgGuildMembershipInviteApprove): Promise<MsgGuildMembershipResponse>;
  GuildMembershipInviteDeny(request: MsgGuildMembershipInviteDeny): Promise<MsgGuildMembershipResponse>;
  GuildMembershipInviteRevoke(request: MsgGuildMembershipInviteRevoke): Promise<MsgGuildMembershipResponse>;
  GuildMembershipJoin(request: MsgGuildMembershipJoin): Promise<MsgGuildMembershipResponse>;
  GuildMembershipJoinProxy(request: MsgGuildMembershipJoinProxy): Promise<MsgGuildMembershipResponse>;
  GuildMembershipKick(request: MsgGuildMembershipKick): Promise<MsgGuildMembershipResponse>;
  GuildMembershipRequest(request: MsgGuildMembershipRequest): Promise<MsgGuildMembershipResponse>;
  GuildMembershipRequestApprove(request: MsgGuildMembershipRequestApprove): Promise<MsgGuildMembershipResponse>;
  GuildMembershipRequestDeny(request: MsgGuildMembershipRequestDeny): Promise<MsgGuildMembershipResponse>;
  GuildMembershipRequestRevoke(request: MsgGuildMembershipRequestRevoke): Promise<MsgGuildMembershipResponse>;
  PermissionGrantOnAddress(request: MsgPermissionGrantOnAddress): Promise<MsgPermissionResponse>;
  PermissionGrantOnObject(request: MsgPermissionGrantOnObject): Promise<MsgPermissionResponse>;
  PermissionRevokeOnAddress(request: MsgPermissionRevokeOnAddress): Promise<MsgPermissionResponse>;
  PermissionRevokeOnObject(request: MsgPermissionRevokeOnObject): Promise<MsgPermissionResponse>;
  PermissionSetOnAddress(request: MsgPermissionSetOnAddress): Promise<MsgPermissionResponse>;
  PermissionSetOnObject(request: MsgPermissionSetOnObject): Promise<MsgPermissionResponse>;
  PlanetExplore(request: MsgPlanetExplore): Promise<MsgPlanetExploreResponse>;
  PlanetRaidComplete(request: MsgPlanetRaidComplete): Promise<MsgPlanetRaidCompleteResponse>;
  PlayerUpdatePrimaryAddress(request: MsgPlayerUpdatePrimaryAddress): Promise<MsgPlayerUpdatePrimaryAddressResponse>;
  PlayerResume(request: MsgPlayerResume): Promise<MsgPlayerResumeResponse>;
  ProviderCreate(request: MsgProviderCreate): Promise<MsgProviderResponse>;
  ProviderWithdrawBalance(request: MsgProviderWithdrawBalance): Promise<MsgProviderResponse>;
  ProviderUpdateCapacityMinimum(request: MsgProviderUpdateCapacityMinimum): Promise<MsgProviderResponse>;
  ProviderUpdateCapacityMaximum(request: MsgProviderUpdateCapacityMaximum): Promise<MsgProviderResponse>;
  ProviderUpdateDurationMinimum(request: MsgProviderUpdateDurationMinimum): Promise<MsgProviderResponse>;
  ProviderUpdateDurationMaximum(request: MsgProviderUpdateDurationMaximum): Promise<MsgProviderResponse>;
  ProviderUpdateAccessPolicy(request: MsgProviderUpdateAccessPolicy): Promise<MsgProviderResponse>;
  ProviderGuildGrant(request: MsgProviderGuildGrant): Promise<MsgProviderResponse>;
  ProviderGuildRevoke(request: MsgProviderGuildRevoke): Promise<MsgProviderResponse>;
  ProviderDelete(request: MsgProviderDelete): Promise<MsgProviderResponse>;
  StructActivate(request: MsgStructActivate): Promise<MsgStructStatusResponse>;
  StructDeactivate(request: MsgStructDeactivate): Promise<MsgStructStatusResponse>;
  StructBuildInitiate(request: MsgStructBuildInitiate): Promise<MsgStructStatusResponse>;
  StructBuildComplete(request: MsgStructBuildComplete): Promise<MsgStructStatusResponse>;
  StructBuildCancel(request: MsgStructBuildCancel): Promise<MsgStructStatusResponse>;
  StructDefenseSet(request: MsgStructDefenseSet): Promise<MsgStructStatusResponse>;
  StructDefenseClear(request: MsgStructDefenseClear): Promise<MsgStructStatusResponse>;
  StructMove(request: MsgStructMove): Promise<MsgStructStatusResponse>;
  StructAttack(request: MsgStructAttack): Promise<MsgStructAttackResponse>;
  StructStealthActivate(request: MsgStructStealthActivate): Promise<MsgStructStatusResponse>;
  StructStealthDeactivate(request: MsgStructStealthDeactivate): Promise<MsgStructStatusResponse>;
  StructGeneratorInfuse(request: MsgStructGeneratorInfuse): Promise<MsgStructGeneratorStatusResponse>;
  StructOreMinerComplete(request: MsgStructOreMinerComplete): Promise<MsgStructOreMinerStatusResponse>;
  StructOreRefineryComplete(request: MsgStructOreRefineryComplete): Promise<MsgStructOreRefineryStatusResponse>;
  SubstationCreate(request: MsgSubstationCreate): Promise<MsgSubstationCreateResponse>;
  SubstationDelete(request: MsgSubstationDelete): Promise<MsgSubstationDeleteResponse>;
  SubstationAllocationConnect(request: MsgSubstationAllocationConnect): Promise<MsgSubstationAllocationConnectResponse>;
  SubstationAllocationDisconnect(
    request: MsgSubstationAllocationDisconnect,
  ): Promise<MsgSubstationAllocationDisconnectResponse>;
  SubstationPlayerConnect(request: MsgSubstationPlayerConnect): Promise<MsgSubstationPlayerConnectResponse>;
  SubstationPlayerDisconnect(request: MsgSubstationPlayerDisconnect): Promise<MsgSubstationPlayerDisconnectResponse>;
  SubstationPlayerMigrate(request: MsgSubstationPlayerMigrate): Promise<MsgSubstationPlayerMigrateResponse>;
}

export const MsgServiceName = "structs.structs.Msg";
export class MsgClientImpl implements Msg {
  private readonly rpc: Rpc;
  private readonly service: string;
  constructor(rpc: Rpc, opts?: { service?: string }) {
    this.service = opts?.service || MsgServiceName;
    this.rpc = rpc;
    this.UpdateParams = this.UpdateParams.bind(this);
    this.AddressRegister = this.AddressRegister.bind(this);
    this.AddressRevoke = this.AddressRevoke.bind(this);
    this.AgreementOpen = this.AgreementOpen.bind(this);
    this.AgreementClose = this.AgreementClose.bind(this);
    this.AgreementCapacityIncrease = this.AgreementCapacityIncrease.bind(this);
    this.AgreementCapacityDecrease = this.AgreementCapacityDecrease.bind(this);
    this.AgreementDurationIncrease = this.AgreementDurationIncrease.bind(this);
    this.AllocationCreate = this.AllocationCreate.bind(this);
    this.AllocationDelete = this.AllocationDelete.bind(this);
    this.AllocationUpdate = this.AllocationUpdate.bind(this);
    this.AllocationTransfer = this.AllocationTransfer.bind(this);
    this.FleetMove = this.FleetMove.bind(this);
    this.GuildCreate = this.GuildCreate.bind(this);
    this.GuildBankMint = this.GuildBankMint.bind(this);
    this.GuildBankRedeem = this.GuildBankRedeem.bind(this);
    this.GuildBankConfiscateAndBurn = this.GuildBankConfiscateAndBurn.bind(this);
    this.GuildUpdateOwnerId = this.GuildUpdateOwnerId.bind(this);
    this.GuildUpdateEntrySubstationId = this.GuildUpdateEntrySubstationId.bind(this);
    this.GuildUpdateEndpoint = this.GuildUpdateEndpoint.bind(this);
    this.GuildUpdateJoinInfusionMinimum = this.GuildUpdateJoinInfusionMinimum.bind(this);
    this.GuildUpdateJoinInfusionMinimumBypassByInvite = this.GuildUpdateJoinInfusionMinimumBypassByInvite.bind(this);
    this.GuildUpdateJoinInfusionMinimumBypassByRequest = this.GuildUpdateJoinInfusionMinimumBypassByRequest.bind(this);
    this.GuildMembershipInvite = this.GuildMembershipInvite.bind(this);
    this.GuildMembershipInviteApprove = this.GuildMembershipInviteApprove.bind(this);
    this.GuildMembershipInviteDeny = this.GuildMembershipInviteDeny.bind(this);
    this.GuildMembershipInviteRevoke = this.GuildMembershipInviteRevoke.bind(this);
    this.GuildMembershipJoin = this.GuildMembershipJoin.bind(this);
    this.GuildMembershipJoinProxy = this.GuildMembershipJoinProxy.bind(this);
    this.GuildMembershipKick = this.GuildMembershipKick.bind(this);
    this.GuildMembershipRequest = this.GuildMembershipRequest.bind(this);
    this.GuildMembershipRequestApprove = this.GuildMembershipRequestApprove.bind(this);
    this.GuildMembershipRequestDeny = this.GuildMembershipRequestDeny.bind(this);
    this.GuildMembershipRequestRevoke = this.GuildMembershipRequestRevoke.bind(this);
    this.PermissionGrantOnAddress = this.PermissionGrantOnAddress.bind(this);
    this.PermissionGrantOnObject = this.PermissionGrantOnObject.bind(this);
    this.PermissionRevokeOnAddress = this.PermissionRevokeOnAddress.bind(this);
    this.PermissionRevokeOnObject = this.PermissionRevokeOnObject.bind(this);
    this.PermissionSetOnAddress = this.PermissionSetOnAddress.bind(this);
    this.PermissionSetOnObject = this.PermissionSetOnObject.bind(this);
    this.PlanetExplore = this.PlanetExplore.bind(this);
    this.PlanetRaidComplete = this.PlanetRaidComplete.bind(this);
    this.PlayerUpdatePrimaryAddress = this.PlayerUpdatePrimaryAddress.bind(this);
    this.PlayerResume = this.PlayerResume.bind(this);
    this.ProviderCreate = this.ProviderCreate.bind(this);
    this.ProviderWithdrawBalance = this.ProviderWithdrawBalance.bind(this);
    this.ProviderUpdateCapacityMinimum = this.ProviderUpdateCapacityMinimum.bind(this);
    this.ProviderUpdateCapacityMaximum = this.ProviderUpdateCapacityMaximum.bind(this);
    this.ProviderUpdateDurationMinimum = this.ProviderUpdateDurationMinimum.bind(this);
    this.ProviderUpdateDurationMaximum = this.ProviderUpdateDurationMaximum.bind(this);
    this.ProviderUpdateAccessPolicy = this.ProviderUpdateAccessPolicy.bind(this);
    this.ProviderGuildGrant = this.ProviderGuildGrant.bind(this);
    this.ProviderGuildRevoke = this.ProviderGuildRevoke.bind(this);
    this.ProviderDelete = this.ProviderDelete.bind(this);
    this.StructActivate = this.StructActivate.bind(this);
    this.StructDeactivate = this.StructDeactivate.bind(this);
    this.StructBuildInitiate = this.StructBuildInitiate.bind(this);
    this.StructBuildComplete = this.StructBuildComplete.bind(this);
    this.StructBuildCancel = this.StructBuildCancel.bind(this);
    this.StructDefenseSet = this.StructDefenseSet.bind(this);
    this.StructDefenseClear = this.StructDefenseClear.bind(this);
    this.StructMove = this.StructMove.bind(this);
    this.StructAttack = this.StructAttack.bind(this);
    this.StructStealthActivate = this.StructStealthActivate.bind(this);
    this.StructStealthDeactivate = this.StructStealthDeactivate.bind(this);
    this.StructGeneratorInfuse = this.StructGeneratorInfuse.bind(this);
    this.StructOreMinerComplete = this.StructOreMinerComplete.bind(this);
    this.StructOreRefineryComplete = this.StructOreRefineryComplete.bind(this);
    this.SubstationCreate = this.SubstationCreate.bind(this);
    this.SubstationDelete = this.SubstationDelete.bind(this);
    this.SubstationAllocationConnect = this.SubstationAllocationConnect.bind(this);
    this.SubstationAllocationDisconnect = this.SubstationAllocationDisconnect.bind(this);
    this.SubstationPlayerConnect = this.SubstationPlayerConnect.bind(this);
    this.SubstationPlayerDisconnect = this.SubstationPlayerDisconnect.bind(this);
    this.SubstationPlayerMigrate = this.SubstationPlayerMigrate.bind(this);
  }
  UpdateParams(request: MsgUpdateParams): Promise<MsgUpdateParamsResponse> {
    const data = MsgUpdateParams.encode(request).finish();
    const promise = this.rpc.request(this.service, "UpdateParams", data);
    return promise.then((data) => MsgUpdateParamsResponse.decode(new BinaryReader(data)));
  }

  AddressRegister(request: MsgAddressRegister): Promise<MsgAddressRegisterResponse> {
    const data = MsgAddressRegister.encode(request).finish();
    const promise = this.rpc.request(this.service, "AddressRegister", data);
    return promise.then((data) => MsgAddressRegisterResponse.decode(new BinaryReader(data)));
  }

  AddressRevoke(request: MsgAddressRevoke): Promise<MsgAddressRevokeResponse> {
    const data = MsgAddressRevoke.encode(request).finish();
    const promise = this.rpc.request(this.service, "AddressRevoke", data);
    return promise.then((data) => MsgAddressRevokeResponse.decode(new BinaryReader(data)));
  }

  AgreementOpen(request: MsgAgreementOpen): Promise<MsgAgreementResponse> {
    const data = MsgAgreementOpen.encode(request).finish();
    const promise = this.rpc.request(this.service, "AgreementOpen", data);
    return promise.then((data) => MsgAgreementResponse.decode(new BinaryReader(data)));
  }

  AgreementClose(request: MsgAgreementClose): Promise<MsgAgreementResponse> {
    const data = MsgAgreementClose.encode(request).finish();
    const promise = this.rpc.request(this.service, "AgreementClose", data);
    return promise.then((data) => MsgAgreementResponse.decode(new BinaryReader(data)));
  }

  AgreementCapacityIncrease(request: MsgAgreementCapacityIncrease): Promise<MsgAgreementResponse> {
    const data = MsgAgreementCapacityIncrease.encode(request).finish();
    const promise = this.rpc.request(this.service, "AgreementCapacityIncrease", data);
    return promise.then((data) => MsgAgreementResponse.decode(new BinaryReader(data)));
  }

  AgreementCapacityDecrease(request: MsgAgreementCapacityDecrease): Promise<MsgAgreementResponse> {
    const data = MsgAgreementCapacityDecrease.encode(request).finish();
    const promise = this.rpc.request(this.service, "AgreementCapacityDecrease", data);
    return promise.then((data) => MsgAgreementResponse.decode(new BinaryReader(data)));
  }

  AgreementDurationIncrease(request: MsgAgreementDurationIncrease): Promise<MsgAgreementResponse> {
    const data = MsgAgreementDurationIncrease.encode(request).finish();
    const promise = this.rpc.request(this.service, "AgreementDurationIncrease", data);
    return promise.then((data) => MsgAgreementResponse.decode(new BinaryReader(data)));
  }

  AllocationCreate(request: MsgAllocationCreate): Promise<MsgAllocationCreateResponse> {
    const data = MsgAllocationCreate.encode(request).finish();
    const promise = this.rpc.request(this.service, "AllocationCreate", data);
    return promise.then((data) => MsgAllocationCreateResponse.decode(new BinaryReader(data)));
  }

  AllocationDelete(request: MsgAllocationDelete): Promise<MsgAllocationDeleteResponse> {
    const data = MsgAllocationDelete.encode(request).finish();
    const promise = this.rpc.request(this.service, "AllocationDelete", data);
    return promise.then((data) => MsgAllocationDeleteResponse.decode(new BinaryReader(data)));
  }

  AllocationUpdate(request: MsgAllocationUpdate): Promise<MsgAllocationUpdateResponse> {
    const data = MsgAllocationUpdate.encode(request).finish();
    const promise = this.rpc.request(this.service, "AllocationUpdate", data);
    return promise.then((data) => MsgAllocationUpdateResponse.decode(new BinaryReader(data)));
  }

  AllocationTransfer(request: MsgAllocationTransfer): Promise<MsgAllocationTransferResponse> {
    const data = MsgAllocationTransfer.encode(request).finish();
    const promise = this.rpc.request(this.service, "AllocationTransfer", data);
    return promise.then((data) => MsgAllocationTransferResponse.decode(new BinaryReader(data)));
  }

  FleetMove(request: MsgFleetMove): Promise<MsgFleetMoveResponse> {
    const data = MsgFleetMove.encode(request).finish();
    const promise = this.rpc.request(this.service, "FleetMove", data);
    return promise.then((data) => MsgFleetMoveResponse.decode(new BinaryReader(data)));
  }

  GuildCreate(request: MsgGuildCreate): Promise<MsgGuildCreateResponse> {
    const data = MsgGuildCreate.encode(request).finish();
    const promise = this.rpc.request(this.service, "GuildCreate", data);
    return promise.then((data) => MsgGuildCreateResponse.decode(new BinaryReader(data)));
  }

  GuildBankMint(request: MsgGuildBankMint): Promise<MsgGuildBankMintResponse> {
    const data = MsgGuildBankMint.encode(request).finish();
    const promise = this.rpc.request(this.service, "GuildBankMint", data);
    return promise.then((data) => MsgGuildBankMintResponse.decode(new BinaryReader(data)));
  }

  GuildBankRedeem(request: MsgGuildBankRedeem): Promise<MsgGuildBankRedeemResponse> {
    const data = MsgGuildBankRedeem.encode(request).finish();
    const promise = this.rpc.request(this.service, "GuildBankRedeem", data);
    return promise.then((data) => MsgGuildBankRedeemResponse.decode(new BinaryReader(data)));
  }

  GuildBankConfiscateAndBurn(request: MsgGuildBankConfiscateAndBurn): Promise<MsgGuildBankConfiscateAndBurnResponse> {
    const data = MsgGuildBankConfiscateAndBurn.encode(request).finish();
    const promise = this.rpc.request(this.service, "GuildBankConfiscateAndBurn", data);
    return promise.then((data) => MsgGuildBankConfiscateAndBurnResponse.decode(new BinaryReader(data)));
  }

  GuildUpdateOwnerId(request: MsgGuildUpdateOwnerId): Promise<MsgGuildUpdateResponse> {
    const data = MsgGuildUpdateOwnerId.encode(request).finish();
    const promise = this.rpc.request(this.service, "GuildUpdateOwnerId", data);
    return promise.then((data) => MsgGuildUpdateResponse.decode(new BinaryReader(data)));
  }

  GuildUpdateEntrySubstationId(request: MsgGuildUpdateEntrySubstationId): Promise<MsgGuildUpdateResponse> {
    const data = MsgGuildUpdateEntrySubstationId.encode(request).finish();
    const promise = this.rpc.request(this.service, "GuildUpdateEntrySubstationId", data);
    return promise.then((data) => MsgGuildUpdateResponse.decode(new BinaryReader(data)));
  }

  GuildUpdateEndpoint(request: MsgGuildUpdateEndpoint): Promise<MsgGuildUpdateResponse> {
    const data = MsgGuildUpdateEndpoint.encode(request).finish();
    const promise = this.rpc.request(this.service, "GuildUpdateEndpoint", data);
    return promise.then((data) => MsgGuildUpdateResponse.decode(new BinaryReader(data)));
  }

  GuildUpdateJoinInfusionMinimum(request: MsgGuildUpdateJoinInfusionMinimum): Promise<MsgGuildUpdateResponse> {
    const data = MsgGuildUpdateJoinInfusionMinimum.encode(request).finish();
    const promise = this.rpc.request(this.service, "GuildUpdateJoinInfusionMinimum", data);
    return promise.then((data) => MsgGuildUpdateResponse.decode(new BinaryReader(data)));
  }

  GuildUpdateJoinInfusionMinimumBypassByInvite(
    request: MsgGuildUpdateJoinInfusionMinimumBypassByInvite,
  ): Promise<MsgGuildUpdateResponse> {
    const data = MsgGuildUpdateJoinInfusionMinimumBypassByInvite.encode(request).finish();
    const promise = this.rpc.request(this.service, "GuildUpdateJoinInfusionMinimumBypassByInvite", data);
    return promise.then((data) => MsgGuildUpdateResponse.decode(new BinaryReader(data)));
  }

  GuildUpdateJoinInfusionMinimumBypassByRequest(
    request: MsgGuildUpdateJoinInfusionMinimumBypassByRequest,
  ): Promise<MsgGuildUpdateResponse> {
    const data = MsgGuildUpdateJoinInfusionMinimumBypassByRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "GuildUpdateJoinInfusionMinimumBypassByRequest", data);
    return promise.then((data) => MsgGuildUpdateResponse.decode(new BinaryReader(data)));
  }

  GuildMembershipInvite(request: MsgGuildMembershipInvite): Promise<MsgGuildMembershipResponse> {
    const data = MsgGuildMembershipInvite.encode(request).finish();
    const promise = this.rpc.request(this.service, "GuildMembershipInvite", data);
    return promise.then((data) => MsgGuildMembershipResponse.decode(new BinaryReader(data)));
  }

  GuildMembershipInviteApprove(request: MsgGuildMembershipInviteApprove): Promise<MsgGuildMembershipResponse> {
    const data = MsgGuildMembershipInviteApprove.encode(request).finish();
    const promise = this.rpc.request(this.service, "GuildMembershipInviteApprove", data);
    return promise.then((data) => MsgGuildMembershipResponse.decode(new BinaryReader(data)));
  }

  GuildMembershipInviteDeny(request: MsgGuildMembershipInviteDeny): Promise<MsgGuildMembershipResponse> {
    const data = MsgGuildMembershipInviteDeny.encode(request).finish();
    const promise = this.rpc.request(this.service, "GuildMembershipInviteDeny", data);
    return promise.then((data) => MsgGuildMembershipResponse.decode(new BinaryReader(data)));
  }

  GuildMembershipInviteRevoke(request: MsgGuildMembershipInviteRevoke): Promise<MsgGuildMembershipResponse> {
    const data = MsgGuildMembershipInviteRevoke.encode(request).finish();
    const promise = this.rpc.request(this.service, "GuildMembershipInviteRevoke", data);
    return promise.then((data) => MsgGuildMembershipResponse.decode(new BinaryReader(data)));
  }

  GuildMembershipJoin(request: MsgGuildMembershipJoin): Promise<MsgGuildMembershipResponse> {
    const data = MsgGuildMembershipJoin.encode(request).finish();
    const promise = this.rpc.request(this.service, "GuildMembershipJoin", data);
    return promise.then((data) => MsgGuildMembershipResponse.decode(new BinaryReader(data)));
  }

  GuildMembershipJoinProxy(request: MsgGuildMembershipJoinProxy): Promise<MsgGuildMembershipResponse> {
    const data = MsgGuildMembershipJoinProxy.encode(request).finish();
    const promise = this.rpc.request(this.service, "GuildMembershipJoinProxy", data);
    return promise.then((data) => MsgGuildMembershipResponse.decode(new BinaryReader(data)));
  }

  GuildMembershipKick(request: MsgGuildMembershipKick): Promise<MsgGuildMembershipResponse> {
    const data = MsgGuildMembershipKick.encode(request).finish();
    const promise = this.rpc.request(this.service, "GuildMembershipKick", data);
    return promise.then((data) => MsgGuildMembershipResponse.decode(new BinaryReader(data)));
  }

  GuildMembershipRequest(request: MsgGuildMembershipRequest): Promise<MsgGuildMembershipResponse> {
    const data = MsgGuildMembershipRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "GuildMembershipRequest", data);
    return promise.then((data) => MsgGuildMembershipResponse.decode(new BinaryReader(data)));
  }

  GuildMembershipRequestApprove(request: MsgGuildMembershipRequestApprove): Promise<MsgGuildMembershipResponse> {
    const data = MsgGuildMembershipRequestApprove.encode(request).finish();
    const promise = this.rpc.request(this.service, "GuildMembershipRequestApprove", data);
    return promise.then((data) => MsgGuildMembershipResponse.decode(new BinaryReader(data)));
  }

  GuildMembershipRequestDeny(request: MsgGuildMembershipRequestDeny): Promise<MsgGuildMembershipResponse> {
    const data = MsgGuildMembershipRequestDeny.encode(request).finish();
    const promise = this.rpc.request(this.service, "GuildMembershipRequestDeny", data);
    return promise.then((data) => MsgGuildMembershipResponse.decode(new BinaryReader(data)));
  }

  GuildMembershipRequestRevoke(request: MsgGuildMembershipRequestRevoke): Promise<MsgGuildMembershipResponse> {
    const data = MsgGuildMembershipRequestRevoke.encode(request).finish();
    const promise = this.rpc.request(this.service, "GuildMembershipRequestRevoke", data);
    return promise.then((data) => MsgGuildMembershipResponse.decode(new BinaryReader(data)));
  }

  PermissionGrantOnAddress(request: MsgPermissionGrantOnAddress): Promise<MsgPermissionResponse> {
    const data = MsgPermissionGrantOnAddress.encode(request).finish();
    const promise = this.rpc.request(this.service, "PermissionGrantOnAddress", data);
    return promise.then((data) => MsgPermissionResponse.decode(new BinaryReader(data)));
  }

  PermissionGrantOnObject(request: MsgPermissionGrantOnObject): Promise<MsgPermissionResponse> {
    const data = MsgPermissionGrantOnObject.encode(request).finish();
    const promise = this.rpc.request(this.service, "PermissionGrantOnObject", data);
    return promise.then((data) => MsgPermissionResponse.decode(new BinaryReader(data)));
  }

  PermissionRevokeOnAddress(request: MsgPermissionRevokeOnAddress): Promise<MsgPermissionResponse> {
    const data = MsgPermissionRevokeOnAddress.encode(request).finish();
    const promise = this.rpc.request(this.service, "PermissionRevokeOnAddress", data);
    return promise.then((data) => MsgPermissionResponse.decode(new BinaryReader(data)));
  }

  PermissionRevokeOnObject(request: MsgPermissionRevokeOnObject): Promise<MsgPermissionResponse> {
    const data = MsgPermissionRevokeOnObject.encode(request).finish();
    const promise = this.rpc.request(this.service, "PermissionRevokeOnObject", data);
    return promise.then((data) => MsgPermissionResponse.decode(new BinaryReader(data)));
  }

  PermissionSetOnAddress(request: MsgPermissionSetOnAddress): Promise<MsgPermissionResponse> {
    const data = MsgPermissionSetOnAddress.encode(request).finish();
    const promise = this.rpc.request(this.service, "PermissionSetOnAddress", data);
    return promise.then((data) => MsgPermissionResponse.decode(new BinaryReader(data)));
  }

  PermissionSetOnObject(request: MsgPermissionSetOnObject): Promise<MsgPermissionResponse> {
    const data = MsgPermissionSetOnObject.encode(request).finish();
    const promise = this.rpc.request(this.service, "PermissionSetOnObject", data);
    return promise.then((data) => MsgPermissionResponse.decode(new BinaryReader(data)));
  }

  PlanetExplore(request: MsgPlanetExplore): Promise<MsgPlanetExploreResponse> {
    const data = MsgPlanetExplore.encode(request).finish();
    const promise = this.rpc.request(this.service, "PlanetExplore", data);
    return promise.then((data) => MsgPlanetExploreResponse.decode(new BinaryReader(data)));
  }

  PlanetRaidComplete(request: MsgPlanetRaidComplete): Promise<MsgPlanetRaidCompleteResponse> {
    const data = MsgPlanetRaidComplete.encode(request).finish();
    const promise = this.rpc.request(this.service, "PlanetRaidComplete", data);
    return promise.then((data) => MsgPlanetRaidCompleteResponse.decode(new BinaryReader(data)));
  }

  PlayerUpdatePrimaryAddress(request: MsgPlayerUpdatePrimaryAddress): Promise<MsgPlayerUpdatePrimaryAddressResponse> {
    const data = MsgPlayerUpdatePrimaryAddress.encode(request).finish();
    const promise = this.rpc.request(this.service, "PlayerUpdatePrimaryAddress", data);
    return promise.then((data) => MsgPlayerUpdatePrimaryAddressResponse.decode(new BinaryReader(data)));
  }

  PlayerResume(request: MsgPlayerResume): Promise<MsgPlayerResumeResponse> {
    const data = MsgPlayerResume.encode(request).finish();
    const promise = this.rpc.request(this.service, "PlayerResume", data);
    return promise.then((data) => MsgPlayerResumeResponse.decode(new BinaryReader(data)));
  }

  ProviderCreate(request: MsgProviderCreate): Promise<MsgProviderResponse> {
    const data = MsgProviderCreate.encode(request).finish();
    const promise = this.rpc.request(this.service, "ProviderCreate", data);
    return promise.then((data) => MsgProviderResponse.decode(new BinaryReader(data)));
  }

  ProviderWithdrawBalance(request: MsgProviderWithdrawBalance): Promise<MsgProviderResponse> {
    const data = MsgProviderWithdrawBalance.encode(request).finish();
    const promise = this.rpc.request(this.service, "ProviderWithdrawBalance", data);
    return promise.then((data) => MsgProviderResponse.decode(new BinaryReader(data)));
  }

  ProviderUpdateCapacityMinimum(request: MsgProviderUpdateCapacityMinimum): Promise<MsgProviderResponse> {
    const data = MsgProviderUpdateCapacityMinimum.encode(request).finish();
    const promise = this.rpc.request(this.service, "ProviderUpdateCapacityMinimum", data);
    return promise.then((data) => MsgProviderResponse.decode(new BinaryReader(data)));
  }

  ProviderUpdateCapacityMaximum(request: MsgProviderUpdateCapacityMaximum): Promise<MsgProviderResponse> {
    const data = MsgProviderUpdateCapacityMaximum.encode(request).finish();
    const promise = this.rpc.request(this.service, "ProviderUpdateCapacityMaximum", data);
    return promise.then((data) => MsgProviderResponse.decode(new BinaryReader(data)));
  }

  ProviderUpdateDurationMinimum(request: MsgProviderUpdateDurationMinimum): Promise<MsgProviderResponse> {
    const data = MsgProviderUpdateDurationMinimum.encode(request).finish();
    const promise = this.rpc.request(this.service, "ProviderUpdateDurationMinimum", data);
    return promise.then((data) => MsgProviderResponse.decode(new BinaryReader(data)));
  }

  ProviderUpdateDurationMaximum(request: MsgProviderUpdateDurationMaximum): Promise<MsgProviderResponse> {
    const data = MsgProviderUpdateDurationMaximum.encode(request).finish();
    const promise = this.rpc.request(this.service, "ProviderUpdateDurationMaximum", data);
    return promise.then((data) => MsgProviderResponse.decode(new BinaryReader(data)));
  }

  ProviderUpdateAccessPolicy(request: MsgProviderUpdateAccessPolicy): Promise<MsgProviderResponse> {
    const data = MsgProviderUpdateAccessPolicy.encode(request).finish();
    const promise = this.rpc.request(this.service, "ProviderUpdateAccessPolicy", data);
    return promise.then((data) => MsgProviderResponse.decode(new BinaryReader(data)));
  }

  ProviderGuildGrant(request: MsgProviderGuildGrant): Promise<MsgProviderResponse> {
    const data = MsgProviderGuildGrant.encode(request).finish();
    const promise = this.rpc.request(this.service, "ProviderGuildGrant", data);
    return promise.then((data) => MsgProviderResponse.decode(new BinaryReader(data)));
  }

  ProviderGuildRevoke(request: MsgProviderGuildRevoke): Promise<MsgProviderResponse> {
    const data = MsgProviderGuildRevoke.encode(request).finish();
    const promise = this.rpc.request(this.service, "ProviderGuildRevoke", data);
    return promise.then((data) => MsgProviderResponse.decode(new BinaryReader(data)));
  }

  ProviderDelete(request: MsgProviderDelete): Promise<MsgProviderResponse> {
    const data = MsgProviderDelete.encode(request).finish();
    const promise = this.rpc.request(this.service, "ProviderDelete", data);
    return promise.then((data) => MsgProviderResponse.decode(new BinaryReader(data)));
  }

  StructActivate(request: MsgStructActivate): Promise<MsgStructStatusResponse> {
    const data = MsgStructActivate.encode(request).finish();
    const promise = this.rpc.request(this.service, "StructActivate", data);
    return promise.then((data) => MsgStructStatusResponse.decode(new BinaryReader(data)));
  }

  StructDeactivate(request: MsgStructDeactivate): Promise<MsgStructStatusResponse> {
    const data = MsgStructDeactivate.encode(request).finish();
    const promise = this.rpc.request(this.service, "StructDeactivate", data);
    return promise.then((data) => MsgStructStatusResponse.decode(new BinaryReader(data)));
  }

  StructBuildInitiate(request: MsgStructBuildInitiate): Promise<MsgStructStatusResponse> {
    const data = MsgStructBuildInitiate.encode(request).finish();
    const promise = this.rpc.request(this.service, "StructBuildInitiate", data);
    return promise.then((data) => MsgStructStatusResponse.decode(new BinaryReader(data)));
  }

  StructBuildComplete(request: MsgStructBuildComplete): Promise<MsgStructStatusResponse> {
    const data = MsgStructBuildComplete.encode(request).finish();
    const promise = this.rpc.request(this.service, "StructBuildComplete", data);
    return promise.then((data) => MsgStructStatusResponse.decode(new BinaryReader(data)));
  }

  StructBuildCancel(request: MsgStructBuildCancel): Promise<MsgStructStatusResponse> {
    const data = MsgStructBuildCancel.encode(request).finish();
    const promise = this.rpc.request(this.service, "StructBuildCancel", data);
    return promise.then((data) => MsgStructStatusResponse.decode(new BinaryReader(data)));
  }

  StructDefenseSet(request: MsgStructDefenseSet): Promise<MsgStructStatusResponse> {
    const data = MsgStructDefenseSet.encode(request).finish();
    const promise = this.rpc.request(this.service, "StructDefenseSet", data);
    return promise.then((data) => MsgStructStatusResponse.decode(new BinaryReader(data)));
  }

  StructDefenseClear(request: MsgStructDefenseClear): Promise<MsgStructStatusResponse> {
    const data = MsgStructDefenseClear.encode(request).finish();
    const promise = this.rpc.request(this.service, "StructDefenseClear", data);
    return promise.then((data) => MsgStructStatusResponse.decode(new BinaryReader(data)));
  }

  StructMove(request: MsgStructMove): Promise<MsgStructStatusResponse> {
    const data = MsgStructMove.encode(request).finish();
    const promise = this.rpc.request(this.service, "StructMove", data);
    return promise.then((data) => MsgStructStatusResponse.decode(new BinaryReader(data)));
  }

  StructAttack(request: MsgStructAttack): Promise<MsgStructAttackResponse> {
    const data = MsgStructAttack.encode(request).finish();
    const promise = this.rpc.request(this.service, "StructAttack", data);
    return promise.then((data) => MsgStructAttackResponse.decode(new BinaryReader(data)));
  }

  StructStealthActivate(request: MsgStructStealthActivate): Promise<MsgStructStatusResponse> {
    const data = MsgStructStealthActivate.encode(request).finish();
    const promise = this.rpc.request(this.service, "StructStealthActivate", data);
    return promise.then((data) => MsgStructStatusResponse.decode(new BinaryReader(data)));
  }

  StructStealthDeactivate(request: MsgStructStealthDeactivate): Promise<MsgStructStatusResponse> {
    const data = MsgStructStealthDeactivate.encode(request).finish();
    const promise = this.rpc.request(this.service, "StructStealthDeactivate", data);
    return promise.then((data) => MsgStructStatusResponse.decode(new BinaryReader(data)));
  }

  StructGeneratorInfuse(request: MsgStructGeneratorInfuse): Promise<MsgStructGeneratorStatusResponse> {
    const data = MsgStructGeneratorInfuse.encode(request).finish();
    const promise = this.rpc.request(this.service, "StructGeneratorInfuse", data);
    return promise.then((data) => MsgStructGeneratorStatusResponse.decode(new BinaryReader(data)));
  }

  StructOreMinerComplete(request: MsgStructOreMinerComplete): Promise<MsgStructOreMinerStatusResponse> {
    const data = MsgStructOreMinerComplete.encode(request).finish();
    const promise = this.rpc.request(this.service, "StructOreMinerComplete", data);
    return promise.then((data) => MsgStructOreMinerStatusResponse.decode(new BinaryReader(data)));
  }

  StructOreRefineryComplete(request: MsgStructOreRefineryComplete): Promise<MsgStructOreRefineryStatusResponse> {
    const data = MsgStructOreRefineryComplete.encode(request).finish();
    const promise = this.rpc.request(this.service, "StructOreRefineryComplete", data);
    return promise.then((data) => MsgStructOreRefineryStatusResponse.decode(new BinaryReader(data)));
  }

  SubstationCreate(request: MsgSubstationCreate): Promise<MsgSubstationCreateResponse> {
    const data = MsgSubstationCreate.encode(request).finish();
    const promise = this.rpc.request(this.service, "SubstationCreate", data);
    return promise.then((data) => MsgSubstationCreateResponse.decode(new BinaryReader(data)));
  }

  SubstationDelete(request: MsgSubstationDelete): Promise<MsgSubstationDeleteResponse> {
    const data = MsgSubstationDelete.encode(request).finish();
    const promise = this.rpc.request(this.service, "SubstationDelete", data);
    return promise.then((data) => MsgSubstationDeleteResponse.decode(new BinaryReader(data)));
  }

  SubstationAllocationConnect(
    request: MsgSubstationAllocationConnect,
  ): Promise<MsgSubstationAllocationConnectResponse> {
    const data = MsgSubstationAllocationConnect.encode(request).finish();
    const promise = this.rpc.request(this.service, "SubstationAllocationConnect", data);
    return promise.then((data) => MsgSubstationAllocationConnectResponse.decode(new BinaryReader(data)));
  }

  SubstationAllocationDisconnect(
    request: MsgSubstationAllocationDisconnect,
  ): Promise<MsgSubstationAllocationDisconnectResponse> {
    const data = MsgSubstationAllocationDisconnect.encode(request).finish();
    const promise = this.rpc.request(this.service, "SubstationAllocationDisconnect", data);
    return promise.then((data) => MsgSubstationAllocationDisconnectResponse.decode(new BinaryReader(data)));
  }

  SubstationPlayerConnect(request: MsgSubstationPlayerConnect): Promise<MsgSubstationPlayerConnectResponse> {
    const data = MsgSubstationPlayerConnect.encode(request).finish();
    const promise = this.rpc.request(this.service, "SubstationPlayerConnect", data);
    return promise.then((data) => MsgSubstationPlayerConnectResponse.decode(new BinaryReader(data)));
  }

  SubstationPlayerDisconnect(request: MsgSubstationPlayerDisconnect): Promise<MsgSubstationPlayerDisconnectResponse> {
    const data = MsgSubstationPlayerDisconnect.encode(request).finish();
    const promise = this.rpc.request(this.service, "SubstationPlayerDisconnect", data);
    return promise.then((data) => MsgSubstationPlayerDisconnectResponse.decode(new BinaryReader(data)));
  }

  SubstationPlayerMigrate(request: MsgSubstationPlayerMigrate): Promise<MsgSubstationPlayerMigrateResponse> {
    const data = MsgSubstationPlayerMigrate.encode(request).finish();
    const promise = this.rpc.request(this.service, "SubstationPlayerMigrate", data);
    return promise.then((data) => MsgSubstationPlayerMigrateResponse.decode(new BinaryReader(data)));
  }
}

interface Rpc {
  request(service: string, method: string, data: Uint8Array): Promise<Uint8Array>;
}

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

type KeysOfUnion<T> = T extends T ? keyof T : never;
export type Exact<P, I extends P> = P extends Builtin ? P
  : P & { [K in keyof P]: Exact<P[K], I[K]> } & { [K in Exclude<keyof I, KeysOfUnion<P>>]: never };

function longToNumber(int64: { toString(): string }): number {
  const num = globalThis.Number(int64.toString());
  if (num > globalThis.Number.MAX_SAFE_INTEGER) {
    throw new globalThis.Error("Value is larger than Number.MAX_SAFE_INTEGER");
  }
  if (num < globalThis.Number.MIN_SAFE_INTEGER) {
    throw new globalThis.Error("Value is smaller than Number.MIN_SAFE_INTEGER");
  }
  return num;
}

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create<I extends Exact<DeepPartial<T>, I>>(base?: I): T;
  fromPartial<I extends Exact<DeepPartial<T>, I>>(object: I): T;
}
